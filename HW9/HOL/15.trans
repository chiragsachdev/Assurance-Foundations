> > > > > > > > > val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val && = fn: simpset * thm list -> simpset
val ++ = fn: simpset * ssfrag -> simpset
val -- = fn: term frag list -> 'a -> term
val --> = fn: hol_type * hol_type -> hol_type
val == = fn: hol_type frag list -> 'a -> hol_type
val >- = fn: tactic * tactic -> tactic
val >> = fn: ('a, 'b) gentactic * tactic -> ('a, 'b) gentactic
val >>> = fn: ('a, 'b) gentactic * list_tactic -> ('a, 'b) gentactic
val >| = fn: ('a, 'b) gentactic * tactic list -> ('a, 'b) gentactic
val ?> = fn: ('a, 'b) verdict * ('a -> ('c, 'b) verdict) -> ('c, 'b) verdict
val ABS = fn: term -> thm -> thm
val ABS_CONV = fn: conv -> conv
val ABS_REP_THM =
   |- !(P :'a -> bool).
     (?(rep :'b -> 'a). TYPE_DEFINITION P rep) ==>
     ?(rep :'b -> 'a) (abs :'a -> 'b).
       (!(a :'b). abs (rep a) = a) /\
       !(r :'a). P r <=> (rep (abs r) = r):
   thm
val ABS_SIMP =
   |- !(t1 :'a) (t2 :'b). (\(x :'b). t1) t2 = t1:
   thm
val ABS_TAC = fn: tactic
val AC = fn: thm -> thm -> thm
val ACCEPT_TAC = fn: thm_tactic
val AC_CONV = fn: thm * thm -> conv
val ADD_ASSUM = fn: term -> thm -> thm
val ADD_SGS_TAC = fn: term list -> tactic -> tactic
val ALLGOALS = fn: tactic -> list_tactic
val ALL_CONV = fn: conv
val ALL_LT = fn: list_tactic
val ALL_TAC = fn: tactic
val ALL_THEN = fn: thm_tactical
val ALPHA = fn: term -> term -> thm
val ALPHA_CONV = fn: term -> term -> thm
val AND1_THM =
   |- !(t1 :bool) (t2 :bool). t1 /\ t2 ==> t1:
   thm
val AND2_THM =
   |- !(t1 :bool) (t2 :bool). t1 /\ t2 ==> t2:
   thm
val AND_CLAUSES =
   |- !(t :bool).
     (T /\ t <=> t) /\ (t /\ T <=> t) /\ (F /\ t <=> F) /\
     (t /\ F <=> F) /\ (t /\ t <=> t):
   thm
val AND_CONG =
   |- !(P :bool) (P' :bool) (Q :bool) (Q' :bool).
     (Q ==> (P <=> P')) /\ (P' ==> (Q <=> Q')) ==> (P /\ Q <=> P' /\ Q'):
   thm
val AND_DEF =
   |- $/\ = (\(t1 :bool) (t2 :bool). !(t :bool). (t1 ==> t2 ==> t) ==> t):
   thm
val AND_EXISTS_CONV = fn: conv
val AND_FORALL_CONV = fn: conv
val AND_IMP_INTRO =
   |- !(t1 :bool) (t2 :bool) (t3 :bool).
     t1 ==> t2 ==> t3 <=> t1 /\ t2 ==> t3:
   thm
val AND_IMP_INTRO_CONV = fn: conv
val AND_INTRO_THM =
   |- !(t1 :bool) (t2 :bool). t1 ==> t2 ==> t1 /\ t2:
   thm
val ANTE_CONJ_CONV = fn: conv
val ANTE_RES_THEN = fn: thm_tactical
val AP_TERM = fn: term -> thm -> thm
val AP_TERM_TAC = fn: tactic
val AP_THM = fn: thm -> term -> thm
val AP_THM_TAC = fn: tactic
val ARITH_ss =
   Simplification set: ARITH_RWTS, ARITH_DP
Conversions:
   MUL_CANON_CONV, keyed on pattern  ``(x :num) * (y :num)``
Decision procedures:
   ARITH_REDUCER
Rewrite rules:
   |- !(x :num).
        ((SUC x = (1 :num)) <=> (x = (0 :num))) /\
        (((1 :num) = SUC x) <=> (x = (0 :num)))
   |- !(x :num).
        ((SUC x = (2 :num)) <=> (x = (1 :num))) /\
        (((2 :num) = SUC x) <=> (x = (1 :num)))
   |- !(m :num). m + (0 :num) = m
   |- !(m :num). (0 :num) + m = m
   |- !(m :num) (n :num).
        (m + n = (0 :num)) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m + n) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num). (m + n = m) <=> (n = (0 :num))
   |- !(m :num) (n :num). (n + m = m) <=> (n = (0 :num))
   |- !(m :num) (n :num).
        (m * n = (0 :num)) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m * n) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(x :num) (y :num).
        (x * y = (1 :num)) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(x :num) (y :num).
        ((1 :num) = x * y) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(m :num). m * (0 :num) = (0 :num)
   |- !(m :num). (0 :num) * m = (0 :num)
   |- !(x :num) (y :num).
        (x * y = SUC (0 :num)) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(x :num) (y :num).
        (SUC (0 :num) = x * y) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(m :num). m * (1 :num) = m
   |- !(m :num). (1 :num) * m = m
   |- !(c :num). c - c = (0 :num)
   |- !(m :num). SUC m - (1 :num) = m
   |- !(m :num). ((0 :num) - m = (0 :num)) /\ (m - (0 :num) = m)
   |- !(a :num) (c :num). a + c - c = a
   |- !(a :num) (c :num). c + a - c = a
   |- !(m :num) (n :num). (m - n = (0 :num)) <=> m <= n
   |- !(m :num) (n :num). ((0 :num) = m - n) <=> m <= n
   |- !(n :num) (m :num). n - m <= n
   |- !(n :num) (m :num). SUC n - SUC m = n - m
   |- !(m :num) (n :num) (p :num). m - n > p <=> m > n + p
   |- !(m :num) (n :num) (p :num).
        m - n < p <=> m < n + p /\ (0 :num) < p
   |- !(m :num) (n :num) (p :num).
        m - n >= p <=> m >= n + p \/ (0 :num) >= p
   |- !(m :num) (n :num) (p :num). m - n <= p <=> m <= n + p
   |- (PRE (0 :num) = (0 :num)) /\ !(m :num). PRE (SUC m) = m
   |- !(n :num) (m :num).
        (n ** m = (0 :num)) <=> (n = (0 :num)) /\ (0 :num) < m
   |- !(n :num). ((1 :num) ** n = (1 :num)) /\ (n ** (1 :num) = n)
   |- !(n :num) (m :num).
        (n ** m = (1 :num)) <=> (n = (1 :num)) \/ (m = (0 :num))
   |- (0 :num) < (x :num) ** (y :num) <=> (0 :num) < x \/ (y = (0 :num))
   |- !(b1 :num) (b2 :num) (x :num).
        (b1 ** x = b2 ** x) <=> (x = (0 :num)) \/ (b1 = b2)
   |- !(b :num).
        (1 :num) < b ==>
        !(n :num) (m :num). (b ** n = b ** m) <=> (n = m)
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m < b ** n <=> m < n
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m <= b ** n <=> m <= n
   |- !(a :num) (b :num).
        a ** (n :num) < b ** n <=> a < b /\ (0 :num) < n
   |- !(a :num) (b :num).
        a ** (n :num) <= b ** n <=> a <= b \/ (n = (0 :num))
   |- !(n :num). n <= (0 :num) <=> (n = (0 :num))
   |- !(n :num). (0 :num) < SUC n
   |- !(m :num) (n :num). m <= m + n
   |- (0 :num) <= (x :num)
   |- SUC (x :num) > (0 :num)
   |- (x :num) >= (0 :num)
   |- (x :num) < SUC x
   |- (x :num) <= SUC x
   |- (x :num) < x + (c :num) <=> (0 :num) < c
   |- (x :num) < (c :num) + x <=> (0 :num) < c
   |- (x :num) <= x + (c :num) <=> (0 :num) <= c
   |- (x :num) <= (c :num) + x <=> (0 :num) <= c
   |- !(m :num). m <= m
   |- (x :num) >= x
   |- !(m :num) (n :num) (p :num). m + p < n + p <=> m < n
   |- !(m :num) (n :num) (p :num). p + m < p + n <=> m < n
   |- !(m :num) (n :num) (p :num). m + n <= m + p <=> n <= p
   |- !(m :num) (n :num) (p :num). n + m <= p + m <=> n <= p
   |- !(m :num) (n :num) (p :num). (m + p = n + p) <=> (m = n)
   |- !(m :num) (n :num) (p :num). (p + m = p + n) <=> (m = n)
   |- (x :num) + (y :num) < (w :num) + x <=> y < w
   |- (y :num) + (x :num) < x + (w :num) <=> y < w
   |- !(m :num) (n :num). (SUC m = SUC n) <=> (m = n)
   |- !(m :num) (n :num). SUC m < SUC n <=> m < n
   |- !(n :num) (m :num). SUC n <= SUC m <=> n <= m
   |- !(m :num) (i :num) (n :num). SUC n * m < SUC n * i <=> m < i
   |- !(p :num) (m :num) (n :num). (n * SUC p = m * SUC p) <=> (n = m)
   |- !(m :num) (i :num) (n :num). (SUC n * m = SUC n * i) <=> (m = i)
   |- !(n :num) (m :num). ~(SUC n <= m) <=> m <= n
   |- !(p :num) (q :num) (n :num) (m :num).
        (n * SUC q ** p = m * SUC q ** p) <=> (n = m)
   |- !(m :num) (n :num) (p :num).
        m * n <= m * p <=> (m = (0 :num)) \/ n <= p
   |- !(m :num) (n :num) (p :num).
        m * n <= p * n <=> (n = (0 :num)) \/ m <= p
   |- !(m :num) (n :num) (p :num).
        m * n < m * p <=> (0 :num) < m /\ n < p
   |- !(m :num) (n :num) (p :num).
        m * n < p * n <=> (0 :num) < n /\ m < p
   |- ((m :num) < m * (n :num) <=> (0 :num) < m /\ (1 :num) < n) /\
      (m < n * m <=> (0 :num) < m /\ (1 :num) < n)
   |- ((m :num) * (n :num) < m <=> (0 :num) < m /\ (n = (0 :num))) /\
      (m * n < n <=> (0 :num) < n /\ (m = (0 :num)))
   |- ((m :num) <= m * (n :num) <=> (m = (0 :num)) \/ (0 :num) < n) /\
      (m <= n * m <=> (m = (0 :num)) \/ (0 :num) < n)
   |- ((m :num) * (n :num) <= m <=> (m = (0 :num)) \/ n <= (1 :num)) /\
      (m * n <= n <=> (n = (0 :num)) \/ m <= (1 :num))
   |- !(m :num) (n :num). SUC n ** m <> (0 :num)
   |- !(n :num) (m :num). SUC (n + n) <> m + m
   |- !(m :num) (n :num). ~(SUC (m + n) <= m)
   |- !(n :num). ~(SUC n <= (0 :num))
   |- !(n :num). ~(n < (0 :num))
   |- !(n :num). ~(n < n)
   |- ~((x :num) > x)
   |- !(n :num).
        (MIN n (0 :num) = (0 :num)) /\ (MIN (0 :num) n = (0 :num))
   |- !(n :num). (MAX n (0 :num) = n) /\ (MAX (0 :num) n = n)
   |- !(n :num). MIN n n = n
   |- !(n :num). MAX n n = n
   |- !(n :num) (m :num) (p :num).
        (MIN m n <= p <=> m <= p \/ n <= p) /\
        (p <= MIN m n <=> p <= m /\ p <= n)
   |- !(n :num) (m :num) (p :num).
        (p <= MAX m n <=> p <= m \/ p <= n) /\
        (MAX m n <= p <=> m <= p /\ n <= p)
   |- !(n :num) (m :num) (p :num).
        (MIN m n < p <=> m < p \/ n < p) /\
        (p < MIN m n <=> p < m /\ p < n)
   |- !(n :num) (m :num) (p :num).
        (p < MAX m n <=> p < m \/ p < n) /\
        (MAX m n < p <=> m < p /\ n < p)
   |- !(m :num) (n :num). (MIN m n = MAX m n) <=> (m = n)
   |- !(m :num) (n :num). MIN m n < MAX m n <=> m <> n
   |- !(x :num) (y :num). (0 :num) < y ==> ((x MOD y = x) <=> x < y)
   |- !(n :num).
        (0 :num) < n ==> (n DIV n = (1 :num)) /\ (n MOD n = (0 :num))
   |- !(q :num). q DIV (1 :num) = q
   |- !(k :num). k MOD (1 :num) = (0 :num)
   |- !(n :num) (k :num). k < n ==> (k MOD n = k)
   |- !(n :num). (0 :num) < n ==> ((0 :num) MOD n = (0 :num))
   |- !(n :num). (0 :num) < n ==> !(k :num). k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 (x :num)) * (y :num) = NUMERAL (z :num)) <=>
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) /\
       (NUMERAL z MOD NUMERAL (BIT1 x) = (0 :num))) /\
      ((NUMERAL (BIT2 x) * y = NUMERAL z) <=>
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) /\
       (NUMERAL z MOD NUMERAL (BIT2 x) = (0 :num)))
   |- !(m :num) (n :num). (0 :num) < n ==> m MOD n < n
   |- !(n :num) (d :num). (0 :num) < n /\ (1 :num) < d ==> n DIV d < n
:
   ssfrag
val ASM_CASES_TAC = fn: term -> tactic
val ASM_QI_TAC = fn: tactic
val ASM_REWRITE_RULE = fn: thm list -> thm -> thm
val ASM_REWRITE_TAC = fn: thm list -> tactic
val ASM_SIMP_TAC = fn: simpset -> thm list -> tactic
val ASSUME = fn: term -> thm
val ASSUME_CONJS = fn: term -> thm
val ASSUME_TAC = fn: thm_tactic
val ASSUM_LIST = fn: (thm list -> tactic) -> tactic
val Abbr = fn: term quotation -> thm
val Absyn = fn: term frag list -> Absyn_dtype.absyn
val Always = Always: ParenStyle
val AroundEachPhrase = AroundEachPhrase: PhraseBlockStyle
val AroundSameName = AroundSameName: PhraseBlockStyle
val AroundSamePrec = AroundSamePrec: PhraseBlockStyle
val BETA_CONV = fn: term -> thm
val BETA_RULE = fn: thm -> thm
val BETA_TAC = fn: tactic
val BETA_THM =
   |- !(f :'a -> 'b) (y :'a). (\(x :'a). f x) y = f y:
   thm
val BETA_VAR = fn: term -> term -> term -> thm
val BINDER_CONV = fn: conv -> conv
val BINOP_CONV = fn: conv -> conv
val BINOP_TAC = fn: tactic
val BODY_CONJUNCTS = fn: thm -> thm list
val BOOL_CASES_AX =
   |- !(t :bool). (t <=> T) \/ (t <=> F):
   thm
val BOOL_CASES_TAC = fn: term -> tactic
val BOOL_EQ_DISTINCT =
   |- (T <=/=> F) /\ (F <=/=> T):
   thm
val BOOL_FUN_CASES_THM =
   |- !(f :bool -> bool).
     (f = (\(b :bool). T)) \/ (f = (\(b :bool). F)) \/
     (f = (\(b :bool). b)) \/ (f = (\(b :bool). ~b)):
   thm
val BOOL_FUN_INDUCT =
   |- !(P :(bool -> bool) -> bool).
     P (\(b :bool). T) /\ P (\(b :bool). F) /\ P (\(b :bool). b) /\
     P (\(b :bool). ~b) ==>
     !(f :bool -> bool). P f:
   thm
val BOTH_EXISTS_AND_THM =
   |- !(P :bool) (Q :bool).
     (?(x :'a). P /\ Q) <=> (?(x :'a). P) /\ ?(x :'a). Q:
   thm
val BOTH_EXISTS_IMP_CONV = fn: conv
val BOTH_EXISTS_IMP_THM =
   |- !(P :bool) (Q :bool).
     (?(x :'a). P ==> Q) <=> (!(x :'a). P) ==> ?(x :'a). Q:
   thm
val BOTH_FORALL_IMP_THM =
   |- !(P :bool) (Q :bool).
     (!(x :'a). P ==> Q) <=> (?(x :'a). P) ==> !(x :'a). Q:
   thm
val BOTH_FORALL_OR_THM =
   |- !(P :bool) (Q :bool).
     (!(x :'a). P \/ Q) <=> (!(x :'a). P) \/ !(x :'a). Q:
   thm
val BOUNDED_DEF =
   |- BOUNDED = (\(v :bool). T):
   thm
val BOUNDED_THM =
   |- !(v :bool). BOUNDED v <=> T:
   thm
val BeginFinalBlock = fn: block_info -> pp_element
val Beta = fn: thm -> thm
val BreakSpace = fn: int * int -> pp_element
val C = fn: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
val CASES_THENL = fn: thm_tactic list -> thm_tactic
val CASE_TAC = fn: tactic
val CCONTR = fn: term -> thm -> thm
val CCONTR_TAC = fn: tactic
val CHANGED_CONV = fn: conv -> conv
val CHANGED_TAC = fn: tactic -> tactic
val CHECK_ASSUME_TAC = fn: thm_tactic
val CHOOSE = fn: term * thm -> thm -> thm
val CHOOSE_TAC = fn: thm_tactic
val CHOOSE_THEN = fn: thm_tactical
val COMB2_CONV = fn: conv * conv -> conv
val COMB_CONV = fn: conv -> conv
val COND_ABS =
   |- !(b :bool) (f :'a -> 'b) (g :'a -> 'b).
     (\(x :'a). if b then f x else g x) = if b then f else g:
   thm
val COND_BOOL_CLAUSES =
   |- (!(b :bool) (e :bool). (if b then T else e) <=> b \/ e) /\
   (!(b :bool) (t :bool). (if b then t else T) <=> b ==> t) /\
   (!(b :bool) (e :bool). (if b then F else e) <=> ~b /\ e) /\
   !(b :bool) (t :bool). (if b then t else F) <=> b /\ t:
   thm
val COND_CASES_TAC = fn: tactic
val COND_CLAUSES =
   |- !(t1 :'a) (t2 :'a).
     ((if T then t1 else t2) = t1) /\ ((if F then t1 else t2) = t2):
   thm
val COND_CONG =
   |- !(P :bool) (Q :bool) (x :'a) (x' :'a) (y :'a) (y' :'a).
     (P <=> Q) /\ (Q ==> (x = x')) /\ (~Q ==> (y = y')) ==>
     ((if P then x else y) = if Q then x' else y'):
   thm
val COND_CONV = fn: conv
val COND_DEF =
   |- (COND :bool -> 'a -> 'a -> 'a) =
   (\(t :bool) (t1 :'a) (t2 :'a).
      @(x :'a). ((t <=> T) ==> (x = t1)) /\ ((t <=> F) ==> (x = t2))):
   thm
val COND_EXPAND =
   |- !(b :bool) (t1 :bool) (t2 :bool).
     (if b then t1 else t2) <=> (~b \/ t1) /\ (b \/ t2):
   thm
val COND_EXPAND_IMP =
   |- !(b :bool) (t1 :bool) (t2 :bool).
     (if b then t1 else t2) <=> (b ==> t1) /\ (~b ==> t2):
   thm
val COND_EXPAND_OR =
   |- !(b :bool) (t1 :bool) (t2 :bool).
     (if b then t1 else t2) <=> b /\ t1 \/ ~b /\ t2:
   thm
val COND_ID =
   |- !(b :bool) (t :'a). (if b then t else t) = t:
   thm
val COND_RAND =
   |- !(f :'a -> 'b) (b :bool) (x :'a) (y :'a).
     f (if b then x else y) = if b then f x else f y:
   thm
val COND_RATOR =
   |- !(b :bool) (f :'a -> 'b) (g :'a -> 'b) (x :'a).
     ((if b then f else g) x :'b) = if b then f x else g x:
   thm
val CONJ = fn: thm -> thm -> thm
val CONJUNCT1 = fn: thm -> thm
val CONJUNCT2 = fn: thm -> thm
val CONJUNCTS = fn: thm -> thm list
val CONJUNCTS_AC = fn: term * term -> thm
val CONJUNCTS_THEN = fn: thm_tactical
val CONJUNCTS_THEN2 = fn: thm_tactic -> thm_tactical
val CONJ_ASM1_TAC = fn: tactic
val CONJ_ASM2_TAC = fn: tactic
val CONJ_ASSOC =
   |- !(t1 :bool) (t2 :bool) (t3 :bool).
     t1 /\ t2 /\ t3 <=> (t1 /\ t2) /\ t3:
   thm
val CONJ_COMM =
   |- !(t1 :bool) (t2 :bool). t1 /\ t2 <=> t2 /\ t1:
   thm
val CONJ_DISCH = fn: term -> thm -> thm
val CONJ_DISCHL = fn: term list -> thm -> thm
val CONJ_LIST = fn: int -> thm -> thm list
val CONJ_PAIR = fn: thm -> thm * thm
val CONJ_SYM =
   |- !(t1 :bool) (t2 :bool). t1 /\ t2 <=> t2 /\ t1:
   thm
val CONJ_TAC = fn: tactic
val CONTR = fn: term -> thm -> thm
val CONTRAPOS = fn: thm -> thm
val CONTRAPOS_CONV = fn: conv
val CONTR_TAC = fn: thm_tactic
val CONV_RULE = fn: conv -> thm -> thm
val CONV_TAC = fn: conv -> tactic
val CT = fn:
   unit ->
     (string,
     (string, DB.data list) Redblackmap.dict *
     (string, DB.data list) Redblackmap.dict) Redblackmap.dict
val Cases = fn: tactic
val Cases_on = fn: term quotation -> tactic
val Cong = fn: thm -> thm
val DATATYPE_BOOL =
   |- DATATYPE ((bool :bool -> bool -> bool) T F) <=> T:
   thm
val DATATYPE_TAG_DEF =
   |- (DATATYPE :'a -> bool) = (\(x :'a). T):
   thm
val DATATYPE_TAG_THM =
   |- !(x :'a). DATATYPE x <=> T:
   thm
val DECIDE = fn: term -> thm
val DECIDE_TAC = fn: tactic
val DEEP_INTRO_TAC = fn: thm -> tactic
val DEEP_INTROk_TAC = fn: thm -> tactic -> tactic
val DEPTH_CONV = fn: conv -> conv
val DEST_BOUNDED = fn: thm -> thm * int
val DE_MORGAN_THM =
   |- !(A :bool) (B :bool).
     (~(A /\ B) <=> ~A \/ ~B) /\ (~(A \/ B) <=> ~A /\ ~B):
   thm
val DISCARD_TAC = fn: thm -> tactic
val DISCH = fn: term -> thm -> thm
val DISCH_ALL = fn: thm -> thm
val DISCH_TAC = fn: tactic
val DISCH_THEN = fn: thm_tactic -> tactic
val DISJ1 = fn: thm -> term -> thm
val DISJ1_TAC = fn: tactic
val DISJ2 = fn: term -> thm -> thm
val DISJ2_TAC = fn: tactic
val DISJUNCTS_AC = fn: term * term -> thm
val DISJ_ASSOC =
   |- !(A :bool) (B :bool) (C :bool). A \/ B \/ C <=> (A \/ B) \/ C:
   thm
val DISJ_CASES = fn: thm -> thm -> thm -> thm
val DISJ_CASESL = fn: thm -> thm list -> thm
val DISJ_CASES_TAC = fn: thm_tactic
val DISJ_CASES_THEN = fn: thm_tactical
val DISJ_CASES_THEN2 = fn: thm_tactic -> thm_tactical
val DISJ_CASES_THENL = fn: thm_tactic list -> thm_tactic
val DISJ_CASES_UNION = fn: thm -> thm -> thm -> thm
val DISJ_COMM =
   |- !(A :bool) (B :bool). A \/ B <=> B \/ A:
   thm
val DISJ_IMP = fn: thm -> thm
val DISJ_IMP_THM =
   |- !(P :bool) (Q :bool) (R :bool).
     P \/ Q ==> R <=> (P ==> R) /\ (Q ==> R):
   thm
val DISJ_SYM =
   |- !(A :bool) (B :bool). A \/ B <=> B \/ A:
   thm
val Datatype = fn: hol_type quotation -> unit
val Define = fn: term quotation -> thm
structure Definition:
  sig
    val gen_new_specification: string * thm -> thm
    val new_definition: string * term -> thm
    val new_definition_hook:
       ((term -> term list * term) * (term list * thm -> thm)) ref
    val new_specification: string * string list * thm -> thm
    val new_type_definition: string * thm -> thm
  end
val EQF_ELIM = fn: thm -> thm
val EQF_INTRO = fn: thm -> thm
val EQT_ELIM = fn: thm -> thm
val EQT_INTRO = fn: thm -> thm
val EQ_CLAUSES =
   |- !(t :bool).
     ((T <=> t) <=> t) /\ ((t <=> T) <=> t) /\ ((F <=> t) <=> ~t) /\
     ((t <=> F) <=> ~t):
   thm
val EQ_EXPAND =
   |- !(t1 :bool) (t2 :bool). (t1 <=> t2) <=> t1 /\ t2 \/ ~t1 /\ ~t2:
   thm
val EQ_EXT =
   |- !(f :'a -> 'b) (g :'a -> 'b). (!(x :'a). f x = g x) ==> (f = g):
   thm
val EQ_IMP_RULE = fn: thm -> thm * thm
val EQ_IMP_THM =
   |- !(t1 :bool) (t2 :bool). (t1 <=> t2) <=> (t1 ==> t2) /\ (t2 ==> t1):
   thm
val EQ_MP = fn: thm -> thm -> thm
val EQ_REFL =
   |- !(x :'a). x = x:
   thm
val EQ_SYM =
   |- !(x :'a) (y :'a). (x = y) ==> (y = x):
   thm
val EQ_SYM_EQ =
   |- !(x :'a) (y :'a). (x = y) <=> (y = x):
   thm
val EQ_TAC = fn: tactic
val EQ_TRANS =
   |- !(x :'a) (y :'a) (z :'a). (x = y) /\ (y = z) ==> (x = z):
   thm
val ERR = fn: string -> string -> exn
val ERR_outstream = ref fn: (string -> unit) ref
val ERR_to_string = ref fn: (error_record -> string) ref
val ETA_AX =
   |- !(t :'a -> 'b). (\(x :'a). t x) = t:
   thm
val ETA_CONV = fn: term -> thm
val ETA_THM =
   |- !(M :'a -> 'b). (\(x :'a). M x) = M:
   thm
val EVAL = fn: term -> thm
val EVAL_RULE = fn: thm -> thm
val EVAL_TAC = fn: tactic
val EVERY = fn: tactic list -> tactic
val EVERY_ASSUM = fn: thm_tactic -> tactic
val EVERY_CONJ_CONV = fn: conv -> conv
val EVERY_CONV = fn: conv list -> conv
val EVERY_DISJ_CONV = fn: conv -> conv
val EVERY_LT = fn: list_tactic list -> list_tactic
val EVERY_TCL = fn: thm_tactical list -> thm_tactical
val EXCLUDED_MIDDLE =
   |- !(t :bool). t \/ ~t:
   thm
val EXISTENCE = fn: thm -> thm
val EXISTS = fn: term * term -> thm -> thm
val EXISTS_AND_CONV = fn: conv
val EXISTS_AND_REORDER_CONV = fn: conv
val EXISTS_DEF =
   |- ($? :('a -> bool) -> bool) = (\(P :'a -> bool). P ($@ P)):
   thm
val EXISTS_EQ = fn: term -> thm -> thm
val EXISTS_EQUATION = fn: term -> thm -> thm
val EXISTS_IMP = fn: term -> thm -> thm
val EXISTS_IMP_CONV = fn: conv
val EXISTS_LEFT = fn: term list -> thm -> thm
val EXISTS_LEFT1 = fn: term -> thm -> thm
val EXISTS_NOT_CONV = fn: conv
val EXISTS_OR_CONV = fn: conv
val EXISTS_OR_THM =
   |- !(P :'a -> bool) (Q :'a -> bool).
     (?(x :'a). P x \/ Q x) <=> (?(x :'a). P x) \/ ?(x :'a). Q x:
   thm
val EXISTS_REFL =
   |- !(a :'a). ?(x :'a). x = a:
   thm
val EXISTS_SIMP =
   |- !(t :bool). (?(x :'a). t) <=> t:
   thm
val EXISTS_SIMP_CONV = fn: conv
val EXISTS_TAC = fn: term -> tactic
val EXISTS_THM =
   |- $? (f :'a -> bool) <=> ?(x :'a). f x:
   thm
val EXISTS_UNIQUE_ALT =
   |- !(P :'a -> bool).
     (?!(x :'a). P x) <=> ?(x :'a). !(y :'a). P y <=> (x = y):
   thm
val EXISTS_UNIQUE_CONV = fn: conv
val EXISTS_UNIQUE_DEF =
   |- ($?! :('a -> bool) -> bool) =
   (\(P :'a -> bool). $? P /\ !(x :'a) (y :'a). P x /\ P y ==> (x = y)):
   thm
val EXISTS_UNIQUE_REFL =
   |- !(a :'a). ?!(x :'a). x = a:
   thm
val EXISTS_UNIQUE_THM =
   |- (?!(x :'a). (P :'a -> bool) x) <=>
   (?(x :'a). P x) /\ !(x :'a) (y :'a). P x /\ P y ==> (x = y):
   thm
val EXT = fn: thm -> thm
val EndInitialBlock = fn: block_info -> pp_element
val F = ``F``: term
val FAIL_LT = fn: string -> list_tactic
val FAIL_TAC = fn: string -> tactic
val FALSITY =
   |- !(t :bool). F ==> t:
   thm
val FILTER_ASM_REWRITE_RULE = fn: pred -> thm list -> thm -> thm
val FILTER_ASM_REWRITE_TAC = fn: pred -> thm list -> tactic
val FILTER_DISCH_TAC = fn: term -> tactic
val FILTER_DISCH_THEN = fn: thm_tactic -> term -> tactic
val FILTER_GEN_TAC = fn: term -> tactic
val FILTER_ONCE_ASM_REWRITE_RULE = fn: pred -> thm list -> thm -> thm
val FILTER_ONCE_ASM_REWRITE_TAC = fn: pred -> thm list -> tactic
val FILTER_PURE_ASM_REWRITE_RULE = fn: pred -> thm list -> thm -> thm
val FILTER_PURE_ASM_REWRITE_TAC = fn: pred -> thm list -> tactic
val FILTER_PURE_ONCE_ASM_REWRITE_RULE = fn: pred -> thm list -> thm -> thm
val FILTER_PURE_ONCE_ASM_REWRITE_TAC = fn: pred -> thm list -> tactic
val FILTER_STRIP_TAC = fn: term -> tactic
val FILTER_STRIP_THEN = fn: thm_tactic -> term -> tactic
val FIRST = fn: tactic list -> tactic
val FIRST_ASSUM = fn: thm_tactic -> tactic
val FIRST_CONV = fn: conv list -> conv
val FIRST_PROVE = fn: tactic list -> tactic
val FIRST_TCL = fn: thm_tactical list -> thm_tactical
val FIRST_X_ASSUM = fn: thm_tactic -> tactic
val FORALL_AND_CONV = fn: conv
val FORALL_AND_THM =
   |- !(P :'a -> bool) (Q :'a -> bool).
     (!(x :'a). P x /\ Q x) <=> (!(x :'a). P x) /\ !(x :'a). Q x:
   thm
val FORALL_BOOL =
   |- (!(b :bool). (P :bool -> bool) b) <=> P T /\ P F:
   thm
val FORALL_DEF =
   |- ($! :('a -> bool) -> bool) = (\(P :'a -> bool). P = (\(x :'a). T)):
   thm
val FORALL_EQ = fn: term -> thm -> thm
val FORALL_IMP_CONV = fn: conv
val FORALL_NOT_CONV = fn: conv
val FORALL_OR_CONV = fn: conv
val FORALL_SIMP =
   |- !(t :bool). (!(x :'a). t) <=> t:
   thm
val FORALL_SIMP_CONV = fn: conv
val FORALL_THM =
   |- $! (f :'a -> bool) <=> !(x :'a). f x:
   thm
val FORK_CONV = fn: conv * conv -> conv
val FREEZE_THEN = fn: thm_tactical
val FULL_SIMP_TAC = fn: simpset -> thm list -> tactic
val FULL_STRUCT_CASES_TAC = fn: thm_tactic
val FUN_EQ_CONV = fn: conv
val FUN_EQ_THM =
   |- !(f :'a -> 'b) (g :'a -> 'b). (f = g) <=> !(x :'a). f x = g x:
   thm
val FVL = fn: term list -> term set -> term set
val F_DEF =
   |- F <=> !(t :bool). t:
   thm
val F_IMP =
   |- !(t :bool). ~t ==> t ==> F:
   thm
val GEN = fn: term -> thm -> thm
val GENL = fn: term list -> thm -> thm
val GEN_ABS = fn: term option -> term list -> thm -> thm
val GEN_ALL = fn: thm -> thm
val GEN_ALPHA_CONV = fn: term -> term -> thm
val GEN_COND_CASES_TAC = fn: (term -> bool) -> tactic
val GEN_EXISTS_TAC = fn: string -> term frag list -> tactic
val GEN_REWRITE_CONV = fn: (conv -> conv) -> rewrites -> thm list -> conv
val GEN_REWRITE_RULE = fn:
   (conv -> conv) -> rewrites -> thm list -> thm -> thm
val GEN_REWRITE_TAC = fn: (conv -> conv) -> rewrites -> thm list -> tactic
val GEN_TAC = fn: tactic
val GEN_VALIDATE = fn: bool -> tactic -> tactic
val GEN_VALIDATE_LT = fn: bool -> list_tactic -> list_tactic
val GSPEC = fn: thm -> thm
val GSUBS = fn:
   ((term, term) subst -> term -> term) -> thm list -> thm -> thm
val GSUBST_TAC = fn:
   ((term, term) Lib.subst -> term -> term) -> thm list -> tactic
val GSYM = fn: thm -> thm
val HEADGOAL = fn: tactic -> list_tactic
val HINT_EXISTS_TAC = fn: tactic
val HOLDIR = "/usr/local/share/HOL": string
exception HOL_ERR of error_record
val HOL_MESG = fn: string -> unit
val HOL_PROGRESS_MESG = fn: string * string -> ('a -> 'b) -> 'a -> 'b
val HOL_WARNING = fn: string -> string -> string -> unit
val HOL_WARNINGloc = fn: string -> string -> locn.locn -> string -> unit
val HO_BACKCHAIN_TAC = fn: thm -> tactic
val HO_MATCH_ACCEPT_TAC = fn: thm -> tactic
val HO_MATCH_MP = fn: thm -> thm -> thm
val HO_MATCH_MP_TAC = fn: thm -> tactic
val HO_PART_MATCH = fn: (term -> term) -> thm -> term -> thm
val HO_REWR_CONV = fn: thm -> conv
val HYP_CONV_RULE = fn: (term -> bool) -> conv -> thm -> thm
val HardSpace = fn: int -> pp_element
val Hol_coreln = fn: term quotation -> thm * thm * thm
val Hol_datatype = fn: hol_type quotation -> unit
val Hol_defn = fn: string -> term quotation -> defn
val Hol_reln = fn: term quotation -> thm * thm * thm
val I = fn: 'a -> 'a
val ID_EX_TAC = fn: tactic
val ID_SPEC_TAC = fn: term -> tactic
val IFC = fn: conv -> conv -> conv -> conv
val IF_CASES_TAC = fn: tactic
val IF_THEN_T_IMP =
   |- !(b :bool) (e :bool). (if b then T else e) <=> ~b ==> e:
   thm
val IMP_ANTISYM_AX =
   |- !(t1 :bool) (t2 :bool). (t1 ==> t2) ==> (t2 ==> t1) ==> (t1 <=> t2):
   thm
val IMP_ANTISYM_RULE = fn: thm -> thm -> thm
val IMP_CANON = fn: thm -> thm list
val IMP_CLAUSES =
   |- !(t :bool).
     (T ==> t <=> t) /\ (t ==> T <=> T) /\ (F ==> t <=> T) /\
     (t ==> t <=> T) /\ (t ==> F <=> ~t):
   thm
val IMP_CONG =
   |- !(x :bool) (x' :bool) (y :bool) (y' :bool).
     (x <=> x') /\ (x' ==> (y <=> y')) ==> (x ==> y <=> x' ==> y'):
   thm
val IMP_CONJ = fn: thm -> thm -> thm
val IMP_CONJ_THM =
   |- !(P :bool) (Q :bool) (R :bool).
     P ==> Q /\ R <=> (P ==> Q) /\ (P ==> R):
   thm
val IMP_DISJ_THM =
   |- !(A :bool) (B :bool). A ==> B <=> ~A \/ B:
   thm
val IMP_ELIM = fn: thm -> thm
val IMP_F =
   |- !(t :bool). (t ==> F) ==> ~t:
   thm
val IMP_F_EQ_F =
   |- !(t :bool). t ==> F <=> (t <=> F):
   thm
val IMP_RES_TAC = fn: thm -> tactic
val IMP_RES_THEN = fn: thm_tactic -> thm -> tactic
val IMP_TRANS = fn: thm -> thm -> thm
val INDUCT_THEN = fn: thm -> (thm -> tactic) -> tactic
val INFINITY_AX =
   |- ?(f :ind -> ind). ONE_ONE f /\ ~ONTO f:
   thm
val INST = fn: (term, term) Lib.subst -> thm -> thm
val INST_TT_HYPS = fn:
   (term, term) subst * (hol_type, hol_type) subst -> thm -> thm * term list
val INST_TYPE = fn: (hol_type, hol_type) Lib.subst -> thm -> thm
val INST_TY_TERM = fn:
   (term, term) subst * (hol_type, hol_type) subst -> thm -> thm
val IN_DEF =
   |- ($IN :'a -> ('a -> bool) -> bool) = (\(x :'a) (f :'a -> bool). f x):
   thm
val IN_tm =
   ``($IN :'a -> ('a -> bool) -> bool)``:
   term
val IRULE_CANON = fn: thm -> thm
val IRULE_TAC = fn: thm -> tactic
val ISPEC = fn: term -> thm -> thm
val ISPECL = fn: term list -> thm -> thm
val ITSELF_UNIQUE =
   |- !(i :'a itself). i = ((:'a) :'a itself):
   thm
val Induct = fn: tactic
val Induct_on = fn: term quotation -> tactic
val Infixl = fn: int -> fixity
val Infixr = fn: int -> fixity
val JRH_INDUCT_UTIL =
   |- !(P :'a -> bool) (t :'a). (!(x :'a). (x = t) ==> P x) ==> $? P:
   thm
val K = fn: 'a -> 'b -> 'a
val KNOW_TAC = fn: term -> tactic
val LAND_CONV = fn: conv -> conv
val LASTGOAL = fn: tactic -> list_tactic
val LAST_ASSUM = fn: thm_tactic -> tactic
val LAST_EXISTS_CONV = fn: conv -> conv
val LAST_FORALL_CONV = fn: conv -> conv
val LAST_X_ASSUM = fn: thm_tactic -> tactic
val LCOMM_THM =
   |- !(f :'a -> 'a -> 'a).
     (!(x :'a) (y :'a) (z :'a). f x (f y z) = f (f x y) z) ==>
     (!(x :'a) (y :'a). f x y = f y x) ==>
     !(x :'a) (y :'a) (z :'a). f x (f y z) = f y (f x z):
   thm
val LEFT = LEFT: associativity
val LEFT_AND_CONG =
   |- !(P :bool) (P' :bool) (Q :bool) (Q' :bool).
     (P <=> P') /\ (P' ==> (Q <=> Q')) ==> (P /\ Q <=> P' /\ Q'):
   thm
val LEFT_AND_EXISTS_CONV = fn: conv
val LEFT_AND_FORALL_CONV = fn: conv
val LEFT_AND_FORALL_THM =
   |- !(P :'a -> bool) (Q :bool).
     (!(x :'a). P x) /\ Q <=> !(x :'a). P x /\ Q:
   thm
val LEFT_AND_OVER_OR =
   |- !(A :bool) (B :bool) (C :bool). A /\ (B \/ C) <=> A /\ B \/ A /\ C:
   thm
val LEFT_EXISTS_AND_THM =
   |- !(P :'a -> bool) (Q :bool).
     (?(x :'a). P x /\ Q) <=> (?(x :'a). P x) /\ Q:
   thm
val LEFT_EXISTS_IMP_THM =
   |- !(P :'a -> bool) (Q :bool).
     (?(x :'a). P x ==> Q) <=> (!(x :'a). P x) ==> Q:
   thm
val LEFT_FORALL_IMP_THM =
   |- !(P :'a -> bool) (Q :bool).
     (!(x :'a). P x ==> Q) <=> (?(x :'a). P x) ==> Q:
   thm
val LEFT_FORALL_OR_THM =
   |- !(Q :bool) (P :'a -> bool).
     (!(x :'a). P x \/ Q) <=> (!(x :'a). P x) \/ Q:
   thm
val LEFT_IMP_EXISTS_CONV = fn: conv
val LEFT_IMP_FORALL_CONV = fn: conv
val LEFT_OR_CONG =
   |- !(P :bool) (P' :bool) (Q :bool) (Q' :bool).
     (P <=> P') /\ (~P' ==> (Q <=> Q')) ==> (P \/ Q <=> P' \/ Q'):
   thm
val LEFT_OR_EXISTS_CONV = fn: conv
val LEFT_OR_EXISTS_THM =
   |- !(P :'a -> bool) (Q :bool).
     (?(x :'a). P x) \/ Q <=> ?(x :'a). P x \/ Q:
   thm
val LEFT_OR_FORALL_CONV = fn: conv
val LEFT_OR_OVER_AND =
   |- !(A :bool) (B :bool) (C :bool). A \/ B /\ C <=> (A \/ B) /\ (A \/ C):
   thm
val LET_CONG =
   |- !(f :'a -> 'b) (g :'a -> 'b) (M :'a) (N :'a).
     (M = N) /\ (!(x :'a). (x = N) ==> (f x = g x)) ==>
     (LET f M = LET g N):
   thm
val LET_DEF =
   |- (LET :('a -> 'b) -> 'a -> 'b) = (\(f :'a -> 'b) (x :'a). f x):
   thm
val LET_RAND =
   |- (P :'b -> bool) (let (x :'a) = (M :'a) in (N :'a -> 'b) x) <=>
   (let (x :'a) = M in P (N x)):
   thm
val LET_RATOR =
   |- (let (x :'a) = (M :'a) in (N :'a -> 'b -> 'c) x) (b :'b) =
   (let (x :'a) = M in N x b):
   thm
val LET_THM =
   |- !(f :'a -> 'b) (x :'a). LET f x = f x:
   thm
val LHS_CONV = fn: conv -> conv
val LIST_BETA_CONV = fn: term -> thm
val LIST_CONJ = fn: thm list -> thm
val LIST_EXISTS_AND_CONV = fn: conv
val LIST_EXISTS_IMP_CONV = fn: bool -> conv
val LIST_EXISTS_NOT_CONV = fn: conv
val LIST_EXISTS_OR_CONV = fn: conv
val LIST_EXISTS_SIMP_CONV = fn: conv
val LIST_FORALL_AND_CONV = fn: conv
val LIST_FORALL_IMP_CONV = fn: bool -> conv
val LIST_FORALL_NOT_CONV = fn: conv
val LIST_FORALL_OR_CONV = fn: conv
val LIST_FORALL_SIMP_CONV = fn: conv
val LIST_MK_EXISTS = fn: term list -> thm -> thm
val LIST_MP = fn: thm list -> thm -> thm
val ListForm = fn:
   {block_info: block_info,
     cons: string, nilstr: string, separator: pp_element list} -> pp_element
structure LoadableThyData:
  sig
    val new:
       {merge: 'a * 'a -> 'a,
         read: (string -> term) -> string -> 'a option,
         terms: 'a -> term list,
         thydataty: string, write: (term -> string) -> 'a -> string} ->
         ('a -> t) * (t -> 'a option)
    val segment_data: {thy: string, thydataty: string} -> t option
    val set_theory_data: {data: t, thydataty: string} -> unit
    type t
    val temp_encoded_update:
       {data: string, read: string -> term, thy: string, thydataty: string}
         -> unit
    val write_data_update: {data: t, thydataty: string} -> unit
  end
val MAP_EVERY = fn: ('a -> tactic) -> 'a list -> tactic
val MAP_FIRST = fn: ('a -> tactic) -> 'a list -> tactic
val MAP_THM = fn: conv -> thm -> thm
val MATCH_ACCEPT_TAC = fn: thm -> tactic
val MATCH_MP = fn: thm -> thm -> thm
val MATCH_MP_TAC = fn: thm -> tactic
val MESG_outstream = ref fn: (string -> unit) ref
val MESG_to_string = ref fn: (string -> string) ref
val METIS_PROVE = fn: thm list -> term -> thm
val METIS_TAC = fn: thm list -> tactic
val MINISCOPE_EXISTS_CONV = fn: bool -> conv
val MINISCOPE_FORALL_CONV = fn: bool -> conv
val MK_ABS = fn: thm -> thm
val MK_AC_LCOMM = fn: thm * thm -> thm * thm * thm
val MK_BOUNDED = fn: thm -> int -> thm
val MK_COMB = fn: thm * thm -> thm
val MK_COMB_TAC = fn: tactic
val MK_EXISTS = fn: thm -> thm
val MODIFY_CONS = fn: (thm -> thm) -> thm -> thm
val MONO_ALL =
   |- (!(x :'a). (P :'a -> bool) x ==> (Q :'a -> bool) x) ==>
   (!(x :'a). P x) ==>
   !(x :'a). Q x:
   thm
val MONO_AND =
   |- ((x :bool) ==> (y :bool)) /\ ((z :bool) ==> (w :bool)) ==>
   x /\ z ==>
   y /\ w:
   thm
val MONO_COND =
   |- ((x :bool) ==> (y :bool)) ==>
   ((z :bool) ==> (w :bool)) ==>
   (if (b :bool) then x else z) ==>
   if b then y else w:
   thm
val MONO_EXISTS =
   |- (!(x :'a). (P :'a -> bool) x ==> (Q :'a -> bool) x) ==>
   (?(x :'a). P x) ==>
   ?(x :'a). Q x:
   thm
val MONO_IMP =
   |- ((y :bool) ==> (x :bool)) /\ ((z :bool) ==> (w :bool)) ==>
   (x ==> z) ==>
   y ==>
   w:
   thm
val MONO_NOT =
   |- ((y :bool) ==> (x :bool)) ==> ~x ==> ~y:
   thm
val MONO_NOT_EQ =
   |- (y :bool) ==> (x :bool) <=> ~x ==> ~y:
   thm
val MONO_OR =
   |- ((x :bool) ==> (y :bool)) /\ ((z :bool) ==> (w :bool)) ==>
   x \/ z ==>
   y \/ w:
   thm
val MP = fn: thm -> thm -> thm
val MP_CANON = fn: thm -> thm
val MP_GENEQ_CANON = fn: bool list -> thm -> thm
val MP_LEQ_CANON = fn: thm -> thm
val MP_REQ_CANON = fn: thm -> thm
val MP_TAC = fn: thm_tactic
val Mk_abs = fn: thm -> term * thm * (thm -> thm)
val Mk_comb = fn: thm -> thm * thm * (thm -> thm -> thm)
val NEG_DISCH = fn: term -> thm -> thm
val NONASSOC = NONASSOC: associativity
val NOT_AND =
   |- ~((t :bool) /\ ~t):
   thm
val NOT_CLAUSES =
   |- (!(t :bool). ~~t <=> t) /\ (~T <=> F) /\ (~F <=> T):
   thm
val NOT_DEF =
   |- $~ = (\(t :bool). t ==> F):
   thm
val NOT_ELIM = fn: thm -> thm
val NOT_EQ_SYM = fn: thm -> thm
val NOT_EXISTS_CONV = fn: conv
val NOT_EXISTS_THM =
   |- !(P :'a -> bool). ~(?(x :'a). P x) <=> !(x :'a). ~P x:
   thm
val NOT_F =
   |- !(t :bool). ~t ==> (t <=> F):
   thm
val NOT_FORALL_CONV = fn: conv
val NOT_FORALL_THM =
   |- !(P :'a -> bool). ~(!(x :'a). P x) <=> ?(x :'a). ~P x:
   thm
val NOT_IMP =
   |- !(A :bool) (B :bool). ~(A ==> B) <=> A /\ ~B:
   thm
val NOT_INTRO = fn: thm -> thm
val NO_CONV = fn: conv
val NO_LT = fn: list_tactic
val NO_STRIP_FULL_SIMP_TAC = fn: simpset -> thm list -> tactic
val NO_STRIP_REV_FULL_SIMP_TAC = fn: simpset -> thm list -> tactic
val NO_TAC = fn: tactic
val NO_THEN = fn: thm_tactical
val NTAC = fn: int -> tactic -> tactic
val NTH_GOAL = fn: tactic -> int -> list_tactic
val NULL_OK_LT = fn: list_tactic -> list_tactic
val NoPhrasing = NoPhrasing: PhraseBlockStyle
val NotEvenIfRand = NotEvenIfRand: ParenStyle
val Ntimes = fn: thm -> int -> thm
val ONCE_ASM_REWRITE_RULE = fn: thm list -> thm -> thm
val ONCE_ASM_REWRITE_TAC = fn: thm list -> tactic
val ONCE_DEPTH_CONV = fn: conv -> conv
val ONCE_REWRITE_CONV = fn: thm list -> conv
val ONCE_REWRITE_RULE = fn: thm list -> thm -> thm
val ONCE_REWRITE_TAC = fn: thm list -> tactic
val ONE_ONE_DEF =
   |- (ONE_ONE :('a -> 'b) -> bool) =
   (\(f :'a -> 'b). !(x1 :'a) (x2 :'a). (f x1 = f x2) ==> (x1 = x2)):
   thm
val ONE_ONE_THM =
   |- !(f :'a -> 'b).
     ONE_ONE f <=> !(x1 :'a) (x2 :'a). (f x1 = f x2) ==> (x1 = x2):
   thm
val ONTO_DEF =
   |- (ONTO :('a -> 'b) -> bool) =
   (\(f :'a -> 'b). !(y :'b). ?(x :'a). y = f x):
   thm
val ONTO_THM =
   |- !(f :'a -> 'b). ONTO f <=> !(y :'b). ?(x :'a). y = f x:
   thm
val ORELSE = fn: tactic * tactic -> tactic
val ORELSEC = fn: conv * conv -> conv
val ORELSE_LT = fn: list_tactic * list_tactic -> list_tactic
val ORELSE_TCL = fn: thm_tactical * thm_tactical -> thm_tactical
val OR_CLAUSES =
   |- !(t :bool).
     (T \/ t <=> T) /\ (t \/ T <=> T) /\ (F \/ t <=> t) /\
     (t \/ F <=> t) /\ (t \/ t <=> t):
   thm
val OR_CONG =
   |- !(P :bool) (P' :bool) (Q :bool) (Q' :bool).
     (~Q ==> (P <=> P')) /\ (~P' ==> (Q <=> Q')) ==>
     (P \/ Q <=> P' \/ Q'):
   thm
val OR_DEF =
   |- $\/ =
   (\(t1 :bool) (t2 :bool). !(t :bool). (t1 ==> t) ==> (t2 ==> t) ==> t):
   thm
val OR_ELIM_THM =
   |- !(t :bool) (t1 :bool) (t2 :bool).
     t1 \/ t2 ==> (t1 ==> t) ==> (t2 ==> t) ==> t:
   thm
val OR_EXISTS_CONV = fn: conv
val OR_FORALL_CONV = fn: conv
val OR_IMP_THM =
   |- !(A :bool) (B :bool). (A <=> B \/ A) <=> B ==> A:
   thm
val OR_INTRO_THM1 =
   |- !(t1 :bool) (t2 :bool). t1 ==> t1 \/ t2:
   thm
val OR_INTRO_THM2 =
   |- !(t1 :bool) (t2 :bool). t2 ==> t1 \/ t2:
   thm
val Once = fn: thm -> thm
val OnlyIfNecessary = OnlyIfNecessary: ParenStyle
val PART_MATCH = fn: (term -> term) -> thm -> term -> thm
val PART_MATCH_A = fn: (term -> term) -> thm -> term -> thm
val PATH_CONV = fn: string -> conv -> conv
val PAT_ASSUM = fn: term -> thm_tactic -> tactic
val PAT_CONV = fn: term -> conv -> conv
val PAT_X_ASSUM = fn: term -> thm_tactic -> tactic
val PEIRCE =
   |- (((P :bool) ==> (Q :bool)) ==> P) ==> P:
   thm
val POP_ASSUM = fn: thm_tactic -> tactic
val POP_ASSUM_LIST = fn: (thm list -> tactic) -> tactic
val PPBlock = fn: pp_element list * block_info -> pp_element
val PRED_ASSUM = fn: (term -> bool) -> thm_tactic -> tactic
val PRINT_CONV = fn: conv
val PROVE = fn: thm list -> term -> thm
val PROVE_HYP = fn: thm -> thm -> thm
val PROVE_TAC = fn: thm list -> tactic
val PULL_EXISTS =
   |- !(P :'a -> bool) (Q :bool).
     ((?(x :'a). P x) ==> Q <=> !(x :'a). P x ==> Q) /\
     ((?(x :'a). P x) /\ Q <=> ?(x :'a). P x /\ Q) /\
     (Q /\ (?(x :'a). P x) <=> ?(x :'a). Q /\ P x):
   thm
val PULL_FORALL =
   |- !(P :'a -> bool) (Q :bool).
     (Q ==> (!(x :'a). P x) <=> !(x :'a). Q ==> P x) /\
     ((!(x :'a). P x) /\ Q <=> !(x :'a). P x /\ Q) /\
     (Q /\ (!(x :'a). P x) <=> !(x :'a). Q /\ P x):
   thm
val PURE_ASM_REWRITE_RULE = fn: thm list -> thm -> thm
val PURE_ASM_REWRITE_TAC = fn: thm list -> tactic
val PURE_ONCE_ASM_REWRITE_RULE = fn: thm list -> thm -> thm
val PURE_ONCE_ASM_REWRITE_TAC = fn: thm list -> tactic
val PURE_ONCE_REWRITE_CONV = fn: thm list -> conv
val PURE_ONCE_REWRITE_RULE = fn: thm list -> thm -> thm
val PURE_ONCE_REWRITE_TAC = fn: thm list -> tactic
val PURE_REWRITE_CONV = fn: thm list -> conv
val PURE_REWRITE_RULE = fn: thm list -> thm -> thm
val PURE_REWRITE_TAC = fn: thm list -> tactic
val PairCases_on = fn: term quotation -> tactic
eqtype ParenStyle
val ParoundName = ParoundName: ParenStyle
val ParoundPrec = ParoundPrec: ParenStyle
eqtype PhraseBlockStyle
val Preterm = fn: term frag list -> Preterm_dtype.preterm
val QCHANGED_CONV = fn: conv -> conv
val QCONV = fn: conv -> conv
val QI_TAC = fn: tactic
val QI_ss =
   Simplification set: <anonymous>
Decision procedures:
   QUANT_INSTANTIATE
:
   ssfrag
val QTY_TAC = fn: hol_type -> (term -> tactic) -> term frag list -> tactic
val QUANT_CONV = fn: conv -> conv
val Q_TAC = fn: (term -> tactic) -> term frag list -> tactic
val Q_TAC0 = fn:
   {traces: (string * int) list} ->
     hol_type option -> (term -> tactic) -> term frag list -> tactic
val RAND_CONV = fn: conv -> conv
val RATOR_CONV = fn: conv -> conv
val REABBREV_TAC = fn: tactic
val REDEPTH_CONV = fn: conv -> conv
val REFL = fn: term -> thm
val REFL_CLAUSE =
   |- !(x :'a). (x = x) <=> T:
   thm
val REFL_TAC = fn: tactic
val RENAME_VARS_CONV = fn: string list -> conv
val REORDER_ANTS = fn: (term list -> term list) -> thm -> thm
val REORDER_ANTS_MOD = fn:
   (term list -> term list) -> (thm -> thm) -> thm -> thm
val REPEAT = fn: tactic -> tactic
val REPEATC = fn: conv -> conv
val REPEAT_GTCL = fn: thm_tactical -> (thm -> tactic) -> thm_tactic
val REPEAT_LT = fn: list_tactic -> list_tactic
val REPEAT_TCL = fn: thm_tactical -> thm_tactical
val RESORT_EXISTS_CONV = fn: (term list -> term list) -> conv
val RESORT_FORALL_CONV = fn: (term list -> term list) -> conv
val RES_ABSTRACT_DEF =
   |- (!(p :'a -> bool) (m :'a -> 'b) (x :'a).
      x IN p ==> (RES_ABSTRACT p m x = m x)) /\
   !(p :'a -> bool) (m1 :'a -> 'b) (m2 :'a -> 'b).
     (!(x :'a). x IN p ==> (m1 x = m2 x)) ==>
     (RES_ABSTRACT p m1 = RES_ABSTRACT p m2):
   thm
val RES_CANON = fn: thm -> thm list
val RES_EXISTS_CONG =
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
   (!(x :'a). x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
   (RES_EXISTS P f <=> RES_EXISTS Q g):
   thm
val RES_EXISTS_DEF =
   |- (RES_EXISTS :('a -> bool) -> ('a -> bool) -> bool) =
   (\(p :'a -> bool) (m :'a -> bool). ?(x :'a). x IN p /\ m x):
   thm
val RES_EXISTS_FALSE =
   |- (?(x :'a)::(P :'a -> bool). F) <=> F:
   thm
val RES_EXISTS_THM =
   |- !(P :'a -> bool) (f :'a -> bool).
     RES_EXISTS P f <=> ?(x :'a). x IN P /\ f x:
   thm
val RES_EXISTS_UNIQUE_DEF =
   |- (RES_EXISTS_UNIQUE :('a -> bool) -> ('a -> bool) -> bool) =
   (\(p :'a -> bool) (m :'a -> bool).
      (?(x :'a)::p. m x) /\ !(x :'a) (y :'a)::p. m x /\ m y ==> (x = y)):
   thm
val RES_EXISTS_UNIQUE_THM =
   |- !(P :'a -> bool) (f :'a -> bool).
     RES_EXISTS_UNIQUE P f <=>
     (?(x :'a)::P. f x) /\ !(x :'a) (y :'a)::P. f x /\ f y ==> (x = y):
   thm
val RES_FORALL_CONG =
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
   (!(x :'a). x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
   (RES_FORALL P f <=> RES_FORALL Q g):
   thm
val RES_FORALL_DEF =
   |- (RES_FORALL :('a -> bool) -> ('a -> bool) -> bool) =
   (\(p :'a -> bool) (m :'a -> bool). !(x :'a). x IN p ==> m x):
   thm
val RES_FORALL_THM =
   |- !(P :'a -> bool) (f :'a -> bool).
     RES_FORALL P f <=> !(x :'a). x IN P ==> f x:
   thm
val RES_FORALL_TRUE =
   |- (!(x :'a)::(P :'a -> bool). T) <=> T:
   thm
val RES_SELECT_DEF =
   |- (RES_SELECT :('a -> bool) -> ('a -> bool) -> 'a) =
   (\(p :'a -> bool) (m :'a -> bool). @(x :'a). x IN p /\ m x):
   thm
val RES_SELECT_THM =
   |- !(P :'a -> bool) (f :'a -> bool).
     RES_SELECT P f = @(x :'a). x IN P /\ f x:
   thm
val RES_TAC = fn: tactic
val RES_THEN = fn: thm_tactic -> tactic
val REVERSE = fn: tactic -> tactic
val REVERSE_LT = fn: list_tactic
val REV_FULL_SIMP_TAC = fn: simpset -> thm list -> tactic
val REWRITES_CONV = fn: rewrites -> conv
val REWRITE_CONV = fn: thm list -> conv
val REWRITE_RULE = fn: thm list -> thm -> thm
val REWRITE_TAC = fn: thm list -> tactic
val REWR_CONV = fn: thm -> conv
val REWR_CONV_A = fn: thm -> conv
val RHS_CONV = fn: conv -> conv
val RIGHT = RIGHT: associativity
val RIGHT_AND_EXISTS_CONV = fn: conv
val RIGHT_AND_FORALL_CONV = fn: conv
val RIGHT_AND_FORALL_THM =
   |- !(P :bool) (Q :'a -> bool).
     P /\ (!(x :'a). Q x) <=> !(x :'a). P /\ Q x:
   thm
val RIGHT_AND_OVER_OR =
   |- !(A :bool) (B :bool) (C :bool). (B \/ C) /\ A <=> B /\ A \/ C /\ A:
   thm
val RIGHT_BETA = fn: thm -> thm
val RIGHT_CONV_RULE = fn: conv -> thm -> thm
val RIGHT_ETA = fn: thm -> thm
val RIGHT_EXISTS_AND_THM =
   |- !(P :bool) (Q :'a -> bool).
     (?(x :'a). P /\ Q x) <=> P /\ ?(x :'a). Q x:
   thm
val RIGHT_EXISTS_IMP_THM =
   |- !(P :bool) (Q :'a -> bool).
     (?(x :'a). P ==> Q x) <=> P ==> ?(x :'a). Q x:
   thm
val RIGHT_FORALL_IMP_THM =
   |- !(P :bool) (Q :'a -> bool).
     (!(x :'a). P ==> Q x) <=> P ==> !(x :'a). Q x:
   thm
val RIGHT_FORALL_OR_THM =
   |- !(P :bool) (Q :'a -> bool).
     (!(x :'a). P \/ Q x) <=> P \/ !(x :'a). Q x:
   thm
val RIGHT_IMP_EXISTS_CONV = fn: conv
val RIGHT_IMP_FORALL_CONV = fn: conv
val RIGHT_LIST_BETA = fn: thm -> thm
val RIGHT_OR_EXISTS_CONV = fn: conv
val RIGHT_OR_EXISTS_THM =
   |- !(P :bool) (Q :'a -> bool).
     P \/ (?(x :'a). Q x) <=> ?(x :'a). P \/ Q x:
   thm
val RIGHT_OR_FORALL_CONV = fn: conv
val RIGHT_OR_OVER_AND =
   |- !(A :bool) (B :bool) (C :bool). B /\ C \/ A <=> (B \/ A) /\ (C \/ A):
   thm
val ROTATE_LT = fn: int -> list_tactic
val RULE_ASSUM_TAC = fn: (thm -> thm) -> tactic
val RULE_L_ASSUM_TAC = fn: (thm -> thm list) -> tactic
val RW_TAC = fn: simpset -> thm list -> tactic
val Raise = fn: exn -> 'a
val S = fn: ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
val SELECT_AX =
   |- !(P :'a -> bool) (x :'a). P x ==> P ($@ P):
   thm
val SELECT_CONV = fn: conv
val SELECT_ELIM = fn: thm -> term * thm -> thm
val SELECT_ELIM_TAC = fn: tactic
val SELECT_ELIM_THM =
   |- !(P :'a -> bool) (Q :'a -> bool).
     (?(x :'a). P x) /\ (!(x :'a). P x ==> Q x) ==> Q ($@ P):
   thm
val SELECT_EQ = fn: term -> thm -> thm
val SELECT_INTRO = fn: thm -> thm
val SELECT_REFL =
   |- !(x :'a). (@(y :'a). y = x) = x:
   thm
val SELECT_REFL_2 =
   |- !(x :'a). (@(y :'a). x = y) = x:
   thm
val SELECT_RULE = fn: thm -> thm
val SELECT_THM =
   |- !(P :'a -> bool). P (@(x :'a). P x) <=> ?(x :'a). P x:
   thm
val SELECT_UNIQUE =
   |- !(P :'a -> bool) (x :'a). (!(y :'a). P y <=> (y = x)) ==> ($@ P = x):
   thm
val SIMPLE_CHOOSE = fn: term -> thm -> thm
val SIMPLE_EXISTS = fn: term -> thm -> thm
val SIMP_CONV = fn: simpset -> thm list -> conv
val SIMP_RULE = fn: simpset -> thm list -> thm -> thm
val SIMP_TAC = fn: simpset -> thm list -> tactic
val SKOLEM_CONV = fn: conv
val SKOLEM_THM =
   |- !(P :'a -> 'b -> bool).
     (!(x :'a). ?(y :'b). P x y) <=> ?(f :'a -> 'b). !(x :'a). P x (f x):
   thm
val SPEC = fn: term -> thm -> thm
val SPECL = fn: term list -> thm -> thm
val SPEC_ALL = fn: thm -> thm
val SPEC_TAC = fn: term * term -> tactic
val SPEC_UNDISCH_EXL = fn: thm -> thm
val SPEC_VAR = fn: thm -> term * thm
val SPLIT_LT = fn: int -> list_tactic * list_tactic -> list_tactic
val SPOSE_NOT_THEN = fn: (thm -> tactic) -> tactic
val SQI_ss =
   Simplification set: SIMPLE_QUANT_INSTANTIATE_GEN
Conversions:
   SIMPLE_EXISTS_INSTANTIATE_CONV_GEN, keyed on pattern
   ``?(x :'a). (P :bool)``
   SIMPLE_FORALL_INSTANTIATE_CONV_GEN, keyed on pattern
   ``!(x :'a). (P :bool)``
   SIMPLE_UEXISTS_INSTANTIATE_CONV_GEN, keyed on pattern
   ``?!(x :'a). (P :bool)``
   SIMPLE_SOME_INSTANTIATE_CONV_GEN, keyed on pattern
   ``some(x :'a). (P :bool)``
   SIMPLE_SELECT_INSTANTIATE_CONV_GEN, keyed on pattern
   ``@(x :'a). (P :bool)``
Rewrite rules:
   |- (!(l :'a list). (HD l::TL l = l) <=> l <> ([] :'a list)) /\
      (!(l :'a list).
         (HD l::HD (TL l)::TL (TL l) = l) <=> LENGTH l > (1 :num)) /\
      (!(l :'a list).
         (HD l::HD (TL l)::HD (TL (TL l))::TL (TL (TL l)) = l) <=>
         LENGTH l > (2 :num)) /\
      (!(l :'a list).
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              TL (TL (TL (TL l))) =
          l) <=> LENGTH l > (3 :num)) /\
      (!(l :'a list).
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::TL (TL (TL (TL (TL l)))) =
          l) <=> LENGTH l > (4 :num)) /\
      (!(l :'a list).
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              TL (TL (TL (TL (TL (TL l))))) =
          l) <=> LENGTH l > (5 :num)) /\
      (!(l :'a list).
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              TL (TL (TL (TL (TL (TL (TL l)))))) =
          l) <=> LENGTH l > (6 :num)) /\
      (!(l :'a list).
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              HD (TL (TL (TL (TL (TL (TL (TL l)))))))::
              TL (TL (TL (TL (TL (TL (TL (TL l))))))) =
          l) <=> LENGTH l > (7 :num)) /\
      (!(l :'a list).
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              HD (TL (TL (TL (TL (TL (TL (TL l)))))))::
              HD (TL (TL (TL (TL (TL (TL (TL (TL l))))))))::
              TL (TL (TL (TL (TL (TL (TL (TL (TL l)))))))) =
          l) <=> LENGTH l > (8 :num)) /\
      (!(l :'a list). ([HD l] = l) <=> (LENGTH l = (1 :num))) /\
      (!(l :'a list).
         ([HD l; HD (TL l)] = l) <=> (LENGTH l = (2 :num))) /\
      (!(l :'a list).
         ([HD l; HD (TL l); HD (TL (TL l))] = l) <=>
         (LENGTH l = (3 :num))) /\
      (!(l :'a list).
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)))] =
          l) <=> (LENGTH l = (4 :num))) /\
      (!(l :'a list).
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l))))] =
          l) <=> (LENGTH l = (5 :num))) /\
      (!(l :'a list).
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))))] =
          l) <=> (LENGTH l = (6 :num))) /\
      (!(l :'a list).
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))))] =
          l) <=> (LENGTH l = (7 :num))) /\
      (!(l :'a list).
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))));
           HD (TL (TL (TL (TL (TL (TL (TL l)))))))] =
          l) <=> (LENGTH l = (8 :num))) /\
      (!(l :'a list).
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))));
           HD (TL (TL (TL (TL (TL (TL (TL l)))))));
           HD (TL (TL (TL (TL (TL (TL (TL (TL l))))))))] =
          l) <=> (LENGTH l = (9 :num))) /\
      (!(l :'a list). (l = HD l::TL l) <=> l <> ([] :'a list)) /\
      (!(l :'a list).
         (l = HD l::HD (TL l)::TL (TL l)) <=> LENGTH l > (1 :num)) /\
      (!(l :'a list).
         (l = HD l::HD (TL l)::HD (TL (TL l))::TL (TL (TL l))) <=>
         LENGTH l > (2 :num)) /\
      (!(l :'a list).
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              TL (TL (TL (TL l)))) <=> LENGTH l > (3 :num)) /\
      (!(l :'a list).
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::TL (TL (TL (TL (TL l))))) <=>
         LENGTH l > (4 :num)) /\
      (!(l :'a list).
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              TL (TL (TL (TL (TL (TL l)))))) <=> LENGTH l > (5 :num)) /\
      (!(l :'a list).
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              TL (TL (TL (TL (TL (TL (TL l))))))) <=>
         LENGTH l > (6 :num)) /\
      (!(l :'a list).
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              HD (TL (TL (TL (TL (TL (TL (TL l)))))))::
              TL (TL (TL (TL (TL (TL (TL (TL l)))))))) <=>
         LENGTH l > (7 :num)) /\
      (!(l :'a list).
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              HD (TL (TL (TL (TL (TL (TL (TL l)))))))::
              HD (TL (TL (TL (TL (TL (TL (TL (TL l))))))))::
              TL (TL (TL (TL (TL (TL (TL (TL (TL l))))))))) <=>
         LENGTH l > (8 :num)) /\
      (!(l :'a list). (l = [HD l]) <=> (LENGTH l = (1 :num))) /\
      (!(l :'a list).
         (l = [HD l; HD (TL l)]) <=> (LENGTH l = (2 :num))) /\
      (!(l :'a list).
         (l = [HD l; HD (TL l); HD (TL (TL l))]) <=>
         (LENGTH l = (3 :num))) /\
      (!(l :'a list).
         (l =
          [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)))]) <=>
         (LENGTH l = (4 :num))) /\
      (!(l :'a list).
         (l =
          [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l))))]) <=> (LENGTH l = (5 :num))) /\
      (!(l :'a list).
         (l =
          [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))))]) <=>
         (LENGTH l = (6 :num))) /\
      (!(l :'a list).
         (l =
          [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))))]) <=>
         (LENGTH l = (7 :num))) /\
      (!(l :'a list).
         (l =
          [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))));
           HD (TL (TL (TL (TL (TL (TL (TL l)))))))]) <=>
         (LENGTH l = (8 :num))) /\
      !(l :'a list).
        (l =
         [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
          HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
          HD (TL (TL (TL (TL (TL (TL l))))));
          HD (TL (TL (TL (TL (TL (TL (TL l)))))));
          HD (TL (TL (TL (TL (TL (TL (TL (TL l))))))))]) <=>
        (LENGTH l = (9 :num))
   |- !(opt :'a option). (SOME (THE opt) = opt) <=> IS_SOME opt
   |- !(p :'a # 'b) (p2 :'b). ((FST p,p2) = p) <=> (p2 = SND p)
   |- !(p :'a # 'b) (p1 :'a). ((p1,SND p) = p) <=> (p1 = FST p)
   |- !(opt :'a option). (opt = SOME (THE opt)) <=> IS_SOME opt
   |- !(p :'a # 'b) (p2 :'b). (p = (FST p,p2)) <=> (SND p = p2)
   |- !(p :'a # 'b) (p1 :'a). (p = (p1,SND p)) <=> (FST p = p1)
:
   ssfrag
val SRW_TAC = fn: ssfrag list -> thm list -> tactic
val STRIP_ASSUME_TAC = fn: thm_tactic
val STRIP_BINDER_CONV = fn: term option -> conv -> conv
val STRIP_GOAL_THEN = fn: thm_tactic -> tactic
val STRIP_QUANT_CONV = fn: conv -> conv
val STRIP_TAC = fn: tactic
val STRIP_THM_THEN = fn: thm_tactical
val STRUCT_CASES_TAC = fn: thm_tactic
val SUBGOAL_THEN = fn: term -> thm_tactic -> tactic
val SUBS = fn: thm list -> thm -> thm
val SUBST = fn: (term, thm) Lib.subst -> term -> thm -> thm
val SUBST1_TAC = fn: thm -> tactic
val SUBST_ALL_TAC = fn: thm -> tactic
val SUBST_CONV = fn: (term, thm) subst -> term -> term -> thm
val SUBST_MATCH = fn: thm -> thm -> thm
val SUBST_OCCS_TAC = fn: (int list * thm) list -> tactic
val SUBST_TAC = fn: thm list -> tactic
val SUBS_OCCS = fn: (int list * thm) list -> thm -> thm
val SUB_CONV = fn: conv -> conv
val SUFF_TAC = fn: term -> tactic
val SWAP_EXISTS_CONV = fn: conv
val SWAP_EXISTS_THM =
   |- !(P :'a -> 'b -> bool).
     (?(x :'a) (y :'b). P x y) <=> ?(y :'b) (x :'a). P x y:
   thm
val SWAP_FORALL_CONV = fn: conv
val SWAP_FORALL_THM =
   |- !(P :'a -> 'b -> bool).
     (!(x :'a) (y :'b). P x y) <=> !(y :'b) (x :'a). P x y:
   thm
val SWAP_VARS_CONV = fn: conv
val SYM = fn: thm -> thm
val SYM_CONV = fn: conv
val SimpL = fn: term -> thm
val SimpLHS =
   |- Cong (((x :'a) = (x' :'a)) ==> ((x = (y :'a)) <=> (x' = y))):
   thm
val SimpR = fn: term -> thm
val SimpRHS =
   |- Cong (((y :'a) = (y' :'a)) ==> (((x :'a) = y) <=> (x = y'))):
   thm
val Specialize = fn: term -> thm -> thm
val T = ``T``: term
val TACS_TO_LT = fn: tactic list -> list_tactic
val TAC_PROOF = fn: goal * tactic -> thm
val THEN = fn: ('a, 'b) gentactic * tactic -> ('a, 'b) gentactic
val THEN1 = fn: tactic * tactic -> tactic
val THENC = fn: conv * conv -> conv
val THENL = fn: ('a, 'b) gentactic * tactic list -> ('a, 'b) gentactic
val THEN_LT = fn: ('a, 'b) gentactic * list_tactic -> ('a, 'b) gentactic
val THEN_TCL = fn: thm_tactical * thm_tactical -> thm_tactical
val TM = RE TM: pp_element
val TOK = fn: string -> pp_element
val TOP_DEPTH_CONV = fn: conv -> conv
val TOP_SWEEP_CONV = fn: conv -> conv
val TRANS = fn: thm -> thm -> thm
val TRUTH = |- T: thm
val TRY = fn: tactic -> tactic
val TRYALL = fn: tactic -> list_tactic
val TRY_CONV = fn: conv -> conv
val TRY_LT = fn: list_tactic -> list_tactic
val TYPE_DEFINITION =
   |- (TYPE_DEFINITION :('a -> bool) -> ('b -> 'a) -> bool) =
   (\(P :'a -> bool) (rep :'b -> 'a).
      (!(x' :'b) (x'' :'b). (rep x' = rep x'') ==> (x' = x'')) /\
      !(x :'a). P x <=> ?(x' :'b). x = rep x'):
   thm
val TYPE_DEFINITION_THM =
   |- !(P :'a -> bool) (rep :'b -> 'a).
     TYPE_DEFINITION P rep <=>
     (!(x' :'b) (x'' :'b). (rep x' = rep x'') ==> (x' = x'')) /\
     !(x :'a). P x <=> ?(x' :'b). x = rep x':
   thm
val T_DEF =
   |- T <=> ((\(x :bool). x) = (\(x :bool). x)):
   thm
val TeX_notation = fn: {TeX: string * int, hol: string} -> unit
val Term = fn: term frag list -> term
val Type = fn: hol_type frag list -> hol_type
val U = fn: ''a list list -> ''a list
val UEXISTS_OR_THM =
   |- !(P :'a -> bool) (Q :'a -> bool).
     (?!(x :'a). P x \/ Q x) ==> (?!(x :'a). P x) \/ ?!(x :'a). Q x:
   thm
val UEXISTS_SIMP =
   |- (?!(x :'a). (t :bool)) <=> t /\ !(x :'a) (y :'a). x = y:
   thm
val UNABBREV_ALL_TAC = fn: tactic
val UNBETA_CONV = fn: term -> conv
exception UNCHANGED
val UNDISCH = fn: thm -> thm
val UNDISCH_ALL = fn: thm -> thm
val UNDISCH_SPLIT = fn: thm -> thm
val UNDISCH_TAC = fn: term -> tactic
val UNDISCH_THEN = fn: term -> thm_tactic -> tactic
val UNDISCH_TM = fn: thm -> term * thm
val UNIQUE_SKOLEM_ALT =
   |- !(P :'a -> 'b -> bool).
     (!(x :'a). ?!(y :'b). P x y) <=>
     ?(f :'a -> 'b). !(x :'a) (y :'b). P x y <=> (f x = y):
   thm
val UNIQUE_SKOLEM_THM =
   |- !(P :'a -> 'b -> bool).
     (!(x :'a). ?!(y :'b). P x y) <=>
     ?!(f :'a -> 'b). !(x :'a). P x (f x):
   thm
val UNWIND_FORALL_THM1 =
   |- !(f :'a -> bool) (v :'a). (!(x :'a). (v = x) ==> f x) <=> f v:
   thm
val UNWIND_FORALL_THM2 =
   |- !(f :'a -> bool) (v :'a). (!(x :'a). (x = v) ==> f x) <=> f v:
   thm
val UNWIND_THM1 =
   |- !(P :'a -> bool) (a :'a). (?(x :'a). (a = x) /\ P x) <=> P a:
   thm
val UNWIND_THM2 =
   |- !(P :'a -> bool) (a :'a). (?(x :'a). (x = a) /\ P x) <=> P a:
   thm
val USE_SG_THEN = fn: thm_tactic -> int -> int -> list_tactic
structure Unicode:
  sig
    structure UChar: UnicodeChars
    val temp_unicode_version: {tmnm: string, u: string} -> unit
    val unicode_version: {tmnm: string, u: string} -> unit
  end
val VALID = fn: tactic -> tactic
val VALIDATE = fn: tactic -> tactic
val VALIDATE_LT = fn: list_tactic -> list_tactic
val VALID_LT = fn: list_tactic -> list_tactic
val W = fn: ('a -> 'a -> 'b) -> 'a -> 'b
val WARNING_outstream = ref fn: (string -> unit) ref
val WARNING_to_string = ref fn: (string -> string -> string -> string) ref
val WARNINGs_as_ERRs = ref false: bool ref
val WEAKEN_TAC = fn: (term -> bool) -> tactic
val WF_REL_TAC = fn: term quotation -> tactic
val WITHOUT_ABBREVS = fn: tactic -> tactic
val X_CASES_THEN = fn: term list list -> thm_tactical
val X_CASES_THENL = fn:
   (('a list -> 'b list -> ('a * 'b) list) ->
     thm_tactic list -> (term list * thm_tactic) list) ->
     thm_tactic list -> thm_tactic
val X_CHOOSE_TAC = fn: term -> thm_tactic
val X_CHOOSE_THEN = fn: term -> thm_tactical
val X_FUN_EQ_CONV = fn: term -> conv
val X_GEN_TAC = fn: term -> tactic
val X_SKOLEM_CONV = fn: term -> conv
val ZAP_TAC = fn: simpset -> thm list -> tactic
val \\ = fn: ('a, 'b) gentactic * tactic -> ('a, 'b) gentactic
val absyn_to_preterm = fn:
   Absyn_dtype.absyn -> Preterm_dtype.preterm Pretype.in_env
val absyn_to_term = fn: term_grammar.grammar -> Absyn_dtype.absyn -> term
val aconv = fn: term -> term -> bool
val add_ML_dependency = fn: string -> unit
val add_absyn_postprocessor = fn: string -> unit
val add_bare_numeral_form = fn: char * string option -> unit
val add_const = fn: string -> unit
val add_implicit_rewrites = fn: thm list -> unit
val add_infix = fn: string * int * associativity -> unit
val add_infix_type = fn:
   {Assoc: associativity, Name: string, ParseName: string option, Prec: int}
     -> unit
val add_listform = fn:
   {block_info: block_info,
     cons: string,
     leftdelim: pp_element list,
     nilstr: string, rightdelim: pp_element list, separator: pp_element list}
     -> unit
val add_numeral_form = fn: char * string option -> unit
val add_qtype = fn: {Name: string, Thy: string} -> unit
val add_record_field = fn: string * term -> unit
val add_record_fupdate = fn: string * term -> unit
val add_rewrites = fn: rewrites -> thm list -> rewrites
val add_rule = fn:
   {block_style: PhraseBlockStyle * block_info,
     fixity: fixity,
     paren_style: ParenStyle, pp_elements: pp_element list, term_name: string}
     -> unit
val add_style_to_string = fn: term_pp_types.pp_style list -> string -> string
val add_tag = fn: tag * thm -> thm
val add_type = fn: string -> unit
val add_user_printer = fn: string * term -> unit
val adjoin_to_theory = fn: thy_addon -> unit
val all = fn: ('a -> bool) -> 'a list -> bool
val all2 = fn: ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
val all_atoms = fn: term -> term set
val all_atomsl = fn: term list -> term set -> term set
val all_consts = fn: unit -> term list
val all_data = fn: string -> (string * (string * thm) list) list
val all_set_types = fn: unit -> string list
val all_tac = fn: tactic
val all_vars = fn: term -> term list
val all_varsl = fn: term list -> term list
val allow_schema_definition = ref false: bool ref
val alpha = ``:'a``: hol_type
val ancestry = fn: string -> string list
val apfst = fn: ('a -> 'b) -> 'a * 'c -> 'b * 'c
val apnth = fn: ('a -> 'a) -> int -> 'a list -> 'a list
val append = fn: 'a list -> 'a list -> 'a list
val appi = fn: (int -> 'a -> unit) -> 'a list -> unit
val apropos = fn: term -> DB.data list
val apropos_in = fn: term -> DB.data list -> DB.data list
val apsnd = fn: ('a -> 'b) -> 'c * 'a -> 'c * 'b
val arb = ``(ARB :'a)``: term
val arith_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern
   ``(\(x :'a). (y :'b)) (z :'a)``
Congruence rules:
   |- ((v :'a) = (v' :'a)) ==>
      ((literal_case (f :'a -> 'b) v :'b) = (literal_case f (I v') :'b))
Rewrite rules:
   |- !(x :'a). (x = x) <=> T
   |- !(t :bool).
        ((T <=> t) <=> t) /\ ((t <=> T) <=> t) /\ ((F <=> t) <=> ~t) /\
        ((t <=> F) <=> ~t)
   |- (!(t :bool). ~~t <=> t) /\ (~T <=> F) /\ (~F <=> T)
   |- !(t :bool).
        (T /\ t <=> t) /\ (t /\ T <=> t) /\ (F /\ t <=> F) /\
        (t /\ F <=> F) /\ (t /\ t <=> t)
   |- !(t :bool).
        (T \/ t <=> T) /\ (t \/ T <=> T) /\ (F \/ t <=> t) /\
        (t \/ F <=> t) /\ (t \/ t <=> t)
   |- !(t :bool).
        (T ==> t <=> t) /\ (t ==> T <=> T) /\ (F ==> t <=> T) /\
        (t ==> t <=> T) /\ (t ==> F <=> ~t)
   |- !(t1 :'a) (t2 :'a).
        ((if T then t1 else t2) = t1) /\ ((if F then t1 else t2) = t2)
   |- !(t :bool). (!(x :'a). t) <=> t
   |- !(t :bool). (?(x :'a). t) <=> t
   |- !(b :bool) (t :'a). (if b then t else t) = t
   |- !(a :'a). ?(x :'a). x = a
   |- !(a :'a). ?(x :'a). a = x
   |- !(a :'a). ?!(x :'a). x = a
   |- !(a :'a). ?!(x :'a). a = x
   |- (!(b :bool) (e :bool). (if b then T else e) <=> b \/ e) /\
      (!(b :bool) (t :bool). (if b then t else T) <=> b ==> t) /\
      (!(b :bool) (e :bool). (if b then F else e) <=> ~b /\ e) /\
      !(b :bool) (t :bool). (if b then t else F) <=> b /\ t
   |- (literal_case (f :'a -> 'b) (I (x :'a)) :'b) = f x
   |- !(t :bool). t \/ ~t
   |- !(t :bool). ~t \/ t
   |- (!(t1 :'a) (t2 :'a). (if T then t1 else t2) = t1) /\
      !(t1 :'a) (t2 :'a). (if F then t1 else t2) = t2
   |- ~((t :bool) /\ ~t)
   |- !(x :'a). (@(y :'a). y = x) = x
   |- !(x :'a). (@(y :'a). x = y) = x
   |- (!(x :'a)::(P :'a -> bool). T) <=> T
   |- (?(x :'a)::(P :'a -> bool). F) <=> F

Simplification set: NOT
Rewrite rules:
   |- !(A :bool) (B :bool). ~(A ==> B) <=> A /\ ~B
   |- !(A :bool) (B :bool).
        (~(A /\ B) <=> ~A \/ ~B) /\ (~(A \/ B) <=> ~A /\ ~B)
   |- !(P :'a -> bool). ~(!(x :'a). P x) <=> ?(x :'a). ~P x
   |- !(P :'a -> bool). ~(?(x :'a). P x) <=> !(x :'a). ~P x
   |- (~(p :bool) <=> ~(q :bool)) <=> (p <=> q)

Simplification set: CONG
Congruence rules:
   |- !(x :bool) (x' :bool) (y :bool) (y' :bool).
        (x <=> x') ==> (x' ==> (y <=> y')) ==> (x ==> y <=> x' ==> y')
   |- !(P :bool) (Q :bool) (x :'a) (x' :'a) (y :'a) (y' :'a).
        (P <=> Q) ==>
        (Q ==> (x = x')) ==>
        (~Q ==> (y = y')) ==>
        ((if P then x else y) = if Q then x' else y')
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_FORALL P f <=> RES_FORALL Q g)
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_EXISTS P f <=> RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  ``?(x :'a). (P :bool)``
   UNWIND_FORALL_CONV, keyed on pattern  ``!(x :'a). (P :bool)``

Simplification set: PAIR
Rewrite rules:
   |- !(x :'a # 'b). (FST x,SND x) = x
   |- !(x :'a) (y :'b). FST (x,y) = x
   |- !(x :'a) (y :'b). SND (x,y) = y
   |- !(x :'a) (y :'b) (a :'a) (b :'b).
        ((x,y) = (a,b)) <=> (x = a) /\ (y = b)
   |- !(f :'a -> 'b -> 'c). CURRY (UNCURRY f) = f
   |- !(f :'a # 'b -> 'c). UNCURRY (CURRY f) = f
   |- (CURRY (f :'a # 'b -> 'c) = CURRY (g :'a # 'b -> 'c)) <=> (f = g)
   |- (UNCURRY (f :'a -> 'b -> 'c) = UNCURRY (g :'a -> 'b -> 'c)) <=>
      (f = g)
   |- !(f :'a # 'b -> 'c) (x :'a) (y :'b). CURRY f x y = f (x,y)
   |- !(f :'a -> 'b) (g :'c -> 'd) (x :'a) (y :'c).
        (f ## g) (x,y) = (f x,g y)
   |- !(f :'a -> 'b -> 'c) (x :'a) (y :'b). UNCURRY f (x,y) = f x y

Simplification set: option
Rewrite rules:
   |- !(x :'a) (y :'a). (SOME x = SOME y) <=> (x = y)
   |- !(x :'a option).
        (option_CASE x x (SOME :'a -> 'a option) :'a option) = x
   |- (OPTION_JOIN (NONE :'a option option) = (NONE :'a option)) /\
      !(x :'a option). OPTION_JOIN (SOME x) = x
   |- (!(v :'b) (f :'a -> 'b).
         (option_CASE (NONE :'a option) v f :'b) = v) /\
      !(x :'a) (v :'b) (f :'a -> 'b).
        (option_CASE (SOME x) v f :'b) = f x
   |- !(x :'a). THE (SOME x) = x
   |- !(x :'a option).
        (option_CASE x (NONE :'a option) (SOME :'a -> 'a option) :
           'a option) =
        x
   |- !(x :'a option). ~IS_SOME x <=> (x = (NONE :'a option))
   |- !(x :'a option). IS_NONE x <=> (x = (NONE :'a option))
   |- (!(x :'a). IS_SOME (SOME x) <=> T) /\
      (IS_SOME (NONE :'a option) <=> F)
   |- ((some(x :'a). x = (y :'a)) = SOME y) /\
      ((some(x :'a). y = x) = SOME y)
   |- (!(P :'a -> bool). OPTION_ALL P (NONE :'a option) <=> T) /\
      !(P :'a -> bool) (x :'a). OPTION_ALL P (SOME x) <=> P x
   |- (some(x :'a). F) = (NONE :'a option)
   |- (!(x :'a). (R :'a -> 'a -> bool) x x) ==>
      !(x :'a option). OPTREL R x x
   |- ((OPTION_MAP (f :'b -> 'a) (x :'b option) = (NONE :'a option)) <=>
       (x = (NONE :'b option))) /\
      (((NONE :'a option) = OPTION_MAP f x) <=> (x = (NONE :'b option)))
   |- (!(x :'b option).
         (((NONE :('b -> 'a) option) <*> x) :'a option) =
         (NONE :'a option)) /\
      !(f :'b -> 'a) (x :'b option).
        ((SOME f <*> x) :'a option) = OPTION_MAP f x
   |- OPTION_CHOICE (m1 :'a option) (NONE :'a option) = m1
   |- (!(m2 :'a option). OPTION_CHOICE (NONE :'a option) m2 = m2) /\
      !(x :'a) (m2 :'a option). OPTION_CHOICE (SOME x) m2 = SOME x
   |- ((OPTION_GUARD (b :bool) = SOME ()) <=> b) /\
      ((OPTION_GUARD b = (NONE :unit option)) <=> ~b)
   |- (OPTION_GUARD T = SOME ()) /\
      (OPTION_GUARD F = (NONE :unit option))
   |- ((OPTION_IGNORE_BIND (m1 :'a option) (m2 :'b option) =
        (NONE :'b option)) <=>
       (m1 = (NONE :'a option)) \/ (m2 = (NONE :'b option))) /\
      ((OPTION_IGNORE_BIND m1 m2 = SOME (y :'b)) <=>
       ?(x :'a). (m1 = SOME x) /\ (m2 = SOME y))
   |- (OPTION_IGNORE_BIND (NONE :'b option) (m :'a option) =
       (NONE :'a option)) /\ (OPTION_IGNORE_BIND (SOME (v :'c)) m = m)
   |- ((OPTION_BIND (p :'a option) (f :'a -> 'b option) =
        (NONE :'b option)) <=>
       (p = (NONE :'a option)) \/
       ?(x :'a). (p = SOME x) /\ (f x = (NONE :'b option))) /\
      ((OPTION_BIND p f = SOME (y :'b)) <=>
       ?(x :'a). (p = SOME x) /\ (f x = SOME y))
   |- (!(f :'b -> 'a option).
         OPTION_BIND (NONE :'b option) f = (NONE :'a option)) /\
      !(x :'b) (f :'b -> 'a option). OPTION_BIND (SOME x) f = f x
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
       (NONE :'c option)) <=>
      (o1 = (NONE :'a option)) \/ (o2 = (NONE :'b option))
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
       SOME (v :'c)) <=>
      ?(x1 :'a) (x2 :'b).
        (o1 = SOME x1) /\ (o2 = SOME x2) /\ (v = f x1 x2)
   |- !(f :'a -> 'b) (x :'a option) (y :'b).
        (OPTION_MAP f x = SOME y) <=>
        ?(z :'a). (x = SOME z) /\ (y = f z)
   |- (((if (P :bool) then SOME (x :'a) else (NONE :'a option)) =
        (NONE :'a option)) <=> ~P) /\
      (((if P then (NONE :'a option) else SOME x) =
        (NONE :'a option)) <=> P) /\
      (((if P then SOME x else (NONE :'a option)) = SOME (y :'a)) <=>
       P /\ (x = y)) /\
      (((if P then (NONE :'a option) else SOME x) = SOME y) <=>
       ~P /\ (x = y))
   |- (((if (P :bool) then (X :'a option) else (NONE :'a option)) =
        (NONE :'a option)) <=> P ==> IS_NONE X) /\
      (((if P then (NONE :'a option) else X) = (NONE :'a option)) <=>
       IS_SOME X ==> P) /\
      (((if P then X else (NONE :'a option)) = SOME (x :'a)) <=>
       P /\ (X = SOME x)) /\
      (((if P then (NONE :'a option) else X) = SOME x) <=>
       ~P /\ (X = SOME x))
   |- !(x :'a). (NONE :'a option) <> SOME x
   |- (OPTION_MAP2 (f :'b -> 'c -> 'a) (SOME (x :'b)) (SOME (y :'c)) =
       SOME (f x y)) /\
      (OPTION_MAP2 f (SOME x) (NONE :'c option) = (NONE :'a option)) /\
      (OPTION_MAP2 f (NONE :'b option) (SOME y) = (NONE :'a option)) /\
      (OPTION_MAP2 f (NONE :'b option) (NONE :'c option) =
       (NONE :'a option))
   |- (!(f :'a -> 'b) (x :'a). OPTION_MAP f (SOME x) = SOME (f x)) /\
      !(f :'a -> 'b). OPTION_MAP f (NONE :'a option) = (NONE :'b option)

Simplification set: REDUCE
Conversions:
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``EVEN (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``ODD (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``PRE (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``SUC (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``DIV2 (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) * (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) + (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) - (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) DIV (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) MOD (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) ** (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) < (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) <= (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) > (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) >= (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``MIN (x :num) (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``MAX (x :num) (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) = (y :num)``

Simplification set: sum
Rewrite rules:
   |- (!(y :'a) (x :'a).
         ((INL x :'a + 'b) = (INL y :'a + 'b)) <=> (x = y)) /\
      !(y :'b) (x :'b).
        ((INR x :'a + 'b) = (INR y :'a + 'b)) <=> (x = y)
   |- (!(P :'a -> bool) (Q :'b -> bool) (x :'a).
         SUM_ALL P Q (INL x :'a + 'b) <=> P x) /\
      !(P :'a -> bool) (Q :'b -> bool) (y :'b).
        SUM_ALL P Q (INR y :'a + 'b) <=> Q y
   |- (!(f :'a -> 'c) (g :'b -> 'd) (a :'a).
         ((f ++ g) (INL a :'a + 'b) :'c + 'd) = (INL (f a) :'c + 'd)) /\
      !(f :'a -> 'c) (g :'b -> 'd) (b :'b).
        ((f ++ g) (INR b :'a + 'b) :'c + 'd) = (INR (g b) :'c + 'd)
   |- !(x :'a + 'b). ~ISR x <=> ISL x
   |- !(x :'a + 'b). ~ISL x <=> ISR x
   |- (!(x :'a) (y :'b) (z :'a).
         ((if (P :bool) then (INR x :'b + 'a) else (INL y :'b + 'a)) =
          (INR z :'b + 'a)) <=> P /\ (z = x)) /\
      (!(x :'c) (y :'d) (z :'d).
         ((if P then (INR x :'d + 'c) else (INL y :'d + 'c)) =
          (INL z :'d + 'c)) <=> ~P /\ (z = y)) /\
      (!(x :'e) (y :'f) (z :'e).
         ((if P then (INL x :'e + 'f) else (INR y :'e + 'f)) =
          (INL z :'e + 'f)) <=> P /\ (z = x)) /\
      !(x :'g) (y :'h) (z :'h).
        ((if P then (INL x :'g + 'h) else (INR y :'g + 'h)) =
         (INR z :'g + 'h)) <=> ~P /\ (z = y)
   |- (!(x :'a) (f :'a -> 'c) (f1 :'b -> 'c).
         (sum_CASE (INL x :'a + 'b) f f1 :'c) = f x) /\
      !(y :'b) (f :'a -> 'c) (f1 :'b -> 'c).
        (sum_CASE (INR y :'a + 'b) f f1 :'c) = f1 y
   |- !(x :'a). OUTL (INL x :'a + 'b) = x
   |- !(x :'a + 'b). ISR x ==> ((INR (OUTR x) :'a + 'b) = x)
   |- !(x :'a + 'b). ISL x ==> ((INL (OUTL x) :'a + 'b) = x)
   |- !(x :'b). OUTR (INR x :'a + 'b) = x
   |- (!(x :'a). ISL (INL x :'a + 'b)) /\
      !(y :'b). ~ISL (INR y :'a + 'b)
   |- (!(x :'b). ISR (INR x :'a + 'b)) /\
      !(y :'a). ~ISR (INL y :'a + 'b)
   |- !(x :'a) (y :'b). (INL x :'a + 'b) <> (INR y :'a + 'b)

Simplification set: COMBIN
Rewrite rules:
   |- !(x :'a). I x = x
   |- !(f :'a -> 'b). ((I :'b -> 'b) o f = f) /\ (f o (I :'a -> 'a) = f)
   |- !(x :'a) (y :'b). K x y = x
   |- !(f :'a -> 'b -> 'c) (g :'a -> 'b) (x :'a). S f g x = f x (g x)
   |- !(f :'a -> 'b) (g :'c -> 'a) (h :'d -> 'c).
        (f o g) o h = f o g o h
   |- !(f :'a -> 'b) (g :'c -> 'a) (x :'c). (f o g) x = f (g x)
   |- !(f :'a -> 'a -> 'b) (x :'a). W f x = f x x
   |- !(f :'a -> 'b -> 'c) (x :'b) (y :'a). combin$C f x y = f y x
   |- (!(f :'a -> 'b) (v :'c). (K v :'b -> 'c) o f = (K v :'a -> 'c)) /\
      !(f :'d -> 'e) (v :'d). f o (K v :'f -> 'd) = (K (f v) :'f -> 'e)

Simplification set: ARITH_RWTS
Rewrite rules:
   |- !(x :num).
        ((SUC x = (1 :num)) <=> (x = (0 :num))) /\
        (((1 :num) = SUC x) <=> (x = (0 :num)))
   |- !(x :num).
        ((SUC x = (2 :num)) <=> (x = (1 :num))) /\
        (((2 :num) = SUC x) <=> (x = (1 :num)))
   |- !(m :num). m + (0 :num) = m
   |- !(m :num). (0 :num) + m = m
   |- !(m :num) (n :num).
        (m + n = (0 :num)) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m + n) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num). (m + n = m) <=> (n = (0 :num))
   |- !(m :num) (n :num). (n + m = m) <=> (n = (0 :num))
   |- !(m :num) (n :num).
        (m * n = (0 :num)) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m * n) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(x :num) (y :num).
        (x * y = (1 :num)) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(x :num) (y :num).
        ((1 :num) = x * y) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(m :num). m * (0 :num) = (0 :num)
   |- !(m :num). (0 :num) * m = (0 :num)
   |- !(x :num) (y :num).
        (x * y = SUC (0 :num)) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(x :num) (y :num).
        (SUC (0 :num) = x * y) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(m :num). m * (1 :num) = m
   |- !(m :num). (1 :num) * m = m
   |- !(c :num). c - c = (0 :num)
   |- !(m :num). SUC m - (1 :num) = m
   |- !(m :num). ((0 :num) - m = (0 :num)) /\ (m - (0 :num) = m)
   |- !(a :num) (c :num). a + c - c = a
   |- !(a :num) (c :num). c + a - c = a
   |- !(m :num) (n :num). (m - n = (0 :num)) <=> m <= n
   |- !(m :num) (n :num). ((0 :num) = m - n) <=> m <= n
   |- !(n :num) (m :num). n - m <= n
   |- !(n :num) (m :num). SUC n - SUC m = n - m
   |- !(m :num) (n :num) (p :num). m - n > p <=> m > n + p
   |- !(m :num) (n :num) (p :num).
        m - n < p <=> m < n + p /\ (0 :num) < p
   |- !(m :num) (n :num) (p :num).
        m - n >= p <=> m >= n + p \/ (0 :num) >= p
   |- !(m :num) (n :num) (p :num). m - n <= p <=> m <= n + p
   |- (PRE (0 :num) = (0 :num)) /\ !(m :num). PRE (SUC m) = m
   |- !(n :num) (m :num).
        (n ** m = (0 :num)) <=> (n = (0 :num)) /\ (0 :num) < m
   |- !(n :num). ((1 :num) ** n = (1 :num)) /\ (n ** (1 :num) = n)
   |- !(n :num) (m :num).
        (n ** m = (1 :num)) <=> (n = (1 :num)) \/ (m = (0 :num))
   |- (0 :num) < (x :num) ** (y :num) <=> (0 :num) < x \/ (y = (0 :num))
   |- !(b1 :num) (b2 :num) (x :num).
        (b1 ** x = b2 ** x) <=> (x = (0 :num)) \/ (b1 = b2)
   |- !(b :num).
        (1 :num) < b ==>
        !(n :num) (m :num). (b ** n = b ** m) <=> (n = m)
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m < b ** n <=> m < n
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m <= b ** n <=> m <= n
   |- !(a :num) (b :num).
        a ** (n :num) < b ** n <=> a < b /\ (0 :num) < n
   |- !(a :num) (b :num).
        a ** (n :num) <= b ** n <=> a <= b \/ (n = (0 :num))
   |- !(n :num). n <= (0 :num) <=> (n = (0 :num))
   |- !(n :num). (0 :num) < SUC n
   |- !(m :num) (n :num). m <= m + n
   |- (0 :num) <= (x :num)
   |- SUC (x :num) > (0 :num)
   |- (x :num) >= (0 :num)
   |- (x :num) < SUC x
   |- (x :num) <= SUC x
   |- (x :num) < x + (c :num) <=> (0 :num) < c
   |- (x :num) < (c :num) + x <=> (0 :num) < c
   |- (x :num) <= x + (c :num) <=> (0 :num) <= c
   |- (x :num) <= (c :num) + x <=> (0 :num) <= c
   |- !(m :num). m <= m
   |- (x :num) >= x
   |- !(m :num) (n :num) (p :num). m + p < n + p <=> m < n
   |- !(m :num) (n :num) (p :num). p + m < p + n <=> m < n
   |- !(m :num) (n :num) (p :num). m + n <= m + p <=> n <= p
   |- !(m :num) (n :num) (p :num). n + m <= p + m <=> n <= p
   |- !(m :num) (n :num) (p :num). (m + p = n + p) <=> (m = n)
   |- !(m :num) (n :num) (p :num). (p + m = p + n) <=> (m = n)
   |- (x :num) + (y :num) < (w :num) + x <=> y < w
   |- (y :num) + (x :num) < x + (w :num) <=> y < w
   |- !(m :num) (n :num). (SUC m = SUC n) <=> (m = n)
   |- !(m :num) (n :num). SUC m < SUC n <=> m < n
   |- !(n :num) (m :num). SUC n <= SUC m <=> n <= m
   |- !(m :num) (i :num) (n :num). SUC n * m < SUC n * i <=> m < i
   |- !(p :num) (m :num) (n :num). (n * SUC p = m * SUC p) <=> (n = m)
   |- !(m :num) (i :num) (n :num). (SUC n * m = SUC n * i) <=> (m = i)
   |- !(n :num) (m :num). ~(SUC n <= m) <=> m <= n
   |- !(p :num) (q :num) (n :num) (m :num).
        (n * SUC q ** p = m * SUC q ** p) <=> (n = m)
   |- !(m :num) (n :num) (p :num).
        m * n <= m * p <=> (m = (0 :num)) \/ n <= p
   |- !(m :num) (n :num) (p :num).
        m * n <= p * n <=> (n = (0 :num)) \/ m <= p
   |- !(m :num) (n :num) (p :num).
        m * n < m * p <=> (0 :num) < m /\ n < p
   |- !(m :num) (n :num) (p :num).
        m * n < p * n <=> (0 :num) < n /\ m < p
   |- ((m :num) < m * (n :num) <=> (0 :num) < m /\ (1 :num) < n) /\
      (m < n * m <=> (0 :num) < m /\ (1 :num) < n)
   |- ((m :num) * (n :num) < m <=> (0 :num) < m /\ (n = (0 :num))) /\
      (m * n < n <=> (0 :num) < n /\ (m = (0 :num)))
   |- ((m :num) <= m * (n :num) <=> (m = (0 :num)) \/ (0 :num) < n) /\
      (m <= n * m <=> (m = (0 :num)) \/ (0 :num) < n)
   |- ((m :num) * (n :num) <= m <=> (m = (0 :num)) \/ n <= (1 :num)) /\
      (m * n <= n <=> (n = (0 :num)) \/ m <= (1 :num))
   |- !(m :num) (n :num). SUC n ** m <> (0 :num)
   |- !(n :num) (m :num). SUC (n + n) <> m + m
   |- !(m :num) (n :num). ~(SUC (m + n) <= m)
   |- !(n :num). ~(SUC n <= (0 :num))
   |- !(n :num). ~(n < (0 :num))
   |- !(n :num). ~(n < n)
   |- ~((x :num) > x)
   |- !(n :num).
        (MIN n (0 :num) = (0 :num)) /\ (MIN (0 :num) n = (0 :num))
   |- !(n :num). (MAX n (0 :num) = n) /\ (MAX (0 :num) n = n)
   |- !(n :num). MIN n n = n
   |- !(n :num). MAX n n = n
   |- !(n :num) (m :num) (p :num).
        (MIN m n <= p <=> m <= p \/ n <= p) /\
        (p <= MIN m n <=> p <= m /\ p <= n)
   |- !(n :num) (m :num) (p :num).
        (p <= MAX m n <=> p <= m \/ p <= n) /\
        (MAX m n <= p <=> m <= p /\ n <= p)
   |- !(n :num) (m :num) (p :num).
        (MIN m n < p <=> m < p \/ n < p) /\
        (p < MIN m n <=> p < m /\ p < n)
   |- !(n :num) (m :num) (p :num).
        (p < MAX m n <=> p < m \/ p < n) /\
        (MAX m n < p <=> m < p /\ n < p)
   |- !(m :num) (n :num). (MIN m n = MAX m n) <=> (m = n)
   |- !(m :num) (n :num). MIN m n < MAX m n <=> m <> n
   |- !(x :num) (y :num). (0 :num) < y ==> ((x MOD y = x) <=> x < y)
   |- !(n :num).
        (0 :num) < n ==> (n DIV n = (1 :num)) /\ (n MOD n = (0 :num))
   |- !(q :num). q DIV (1 :num) = q
   |- !(k :num). k MOD (1 :num) = (0 :num)
   |- !(n :num) (k :num). k < n ==> (k MOD n = k)
   |- !(n :num). (0 :num) < n ==> ((0 :num) MOD n = (0 :num))
   |- !(n :num). (0 :num) < n ==> !(k :num). k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 (x :num)) * (y :num) = NUMERAL (z :num)) <=>
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) /\
       (NUMERAL z MOD NUMERAL (BIT1 x) = (0 :num))) /\
      ((NUMERAL (BIT2 x) * y = NUMERAL z) <=>
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) /\
       (NUMERAL z MOD NUMERAL (BIT2 x) = (0 :num)))
   |- !(m :num) (n :num). (0 :num) < n ==> m MOD n < n
   |- !(n :num) (d :num). (0 :num) < n /\ (1 :num) < d ==> n DIV d < n

Simplification set: ARITH_DP
Conversions:
   MUL_CANON_CONV, keyed on pattern  ``(x :num) * (y :num)``
Decision procedures:
   ARITH_REDUCER

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER
:
   simpset
val asm_rewrite_tac = fn: thm list -> tactic
val asm_simp_tac = fn: simpset -> thm list -> tactic
val assert = fn: ('a -> bool) -> 'a -> 'a
val assert_exn = fn: ('a -> bool) -> 'a -> exn -> 'a
val assoc = fn: ''a -> (''a * 'b) list -> 'b
val assoc1 = fn: ''a -> (''a * 'b) list -> (''a * 'b) option
val assoc2 = fn: ''a -> ('b * ''a) list -> ('b * ''a) option
val assoc_tm =
   ``(f :'a -> 'a -> 'a) (x :'a) (f (y :'a) (z :'a)) = f (f x y) z``:
   term
val associate_restriction = fn: string * string -> unit
eqtype associativity
val assume_tac = fn: thm_tactic
val augment_srw_ss = fn: ssfrag list -> unit
val axiom = fn: string -> thm
val axioms = fn: string -> (string * thm) list
val beta = ``:'b``: hol_type
val beta_conv = fn: term -> term
val bindl = fn: string -> (string * thm * class) list -> unit
type block_info = term_grammar.block_info
val body = fn: term -> term
val bool = ``:bool``: hol_type
val boolAxiom =
   |- !(t1 :'a) (t2 :'a). ?(fn :bool -> 'a). (fn T = t1) /\ (fn F = t2):
   thm
val bool_EQ_CONV = fn: conv
val bool_INDUCT =
   |- !(P :bool -> bool). P T /\ P F ==> !(b :bool). P b:
   thm
val bool_case =
   ``(COND :bool -> 'a -> 'a -> 'a)``:
   term
val bool_case_CONG =
   |- !(P :bool) (Q :bool) (x :'a) (x' :'a) (y :'a) (y' :'a).
     (P <=> Q) /\ (Q ==> (x = x')) /\ (~Q ==> (y = y')) ==>
     ((if P then x else y) = if Q then x' else y'):
   thm
val bool_case_ID =
   |- !(b :bool) (t :'a). (if b then t else t) = t:
   thm
val bool_case_thm =
   |- (!(t1 :'a) (t2 :'a). (if T then t1 else t2) = t1) /\
   !(t1 :'a) (t2 :'a). (if F then t1 else t2) = t2:
   thm
val bool_compare = fn: bool cmp
val bool_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
         TY  ::=  bool | (TY, TY)fun | ind | TY itself
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  bool = min$bool                                        
  ('a, 'b) fun = ('a, 'b) min$fun                        
  ind = min$ind                                          
  'a itself = 'a bool$itself                             ,
    (0)    TM  ::=  "!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(100)  TM  ::=  TM "" TM  [<=/=>] | TM "<=/=>" TM | TM "" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "" TM  [\/] | TM "\/" TM   (R-associative)
(400)  TM  ::=  TM "" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "" TM  [NOTIN] | TM "NOTIN" TM | TM "" TM  [IN] |
                TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "" TM | TM "<>" TM   (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
   _ fakeconst4.case,S10.case magic,7.default ! /\ <=/=> <=> <> = ==> ?
  ?! @ ARB BOUNDED COND DATATYPE F IN LET NOTIN ONE_ONE ONTO
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT T
  TYPE_DEFINITION \/ case itself_case literal_case the_value ~ 
Overloading:
  <=/=> ->  (\(x :bool) (y :bool). bool$~ (min$= x y))
  <=>   ->  =
  <>    ->  (\(x :'a) (y :'a). bool$~ (min$= x y))
  NOTIN ->  (\(x :'a) (y :'a -> bool). bool$~ (bool$IN x y))
  case  ->  itself_case literal_case COND
       ->  (\(x :'a) (y :'a). bool$~ (min$= x y))
User printing functions:
  if (gd :bool) then (tr :'a) else (fl :'a)       ->  bool.COND
  LET (f :'a -> 'b) (x :'a)       ->  bool.LET):
   type_grammar.grammar * term_grammar.grammar
val bool_rewrites =
   |- ((x :'a) = x) <=> T;  |- (T <=> (t :bool)) <=> t;
|- ((t :bool) <=> T) <=> t;  |- (F <=> (t :bool)) <=> ~t;
|- ((t :bool) <=> F) <=> ~t;  |- ~~(t :bool) <=> t;  |- ~T <=> F;
|- ~F <=> T;  |- T /\ (t :bool) <=> t;  |- (t :bool) /\ T <=> t;
|- F /\ (t :bool) <=> F;  |- (t :bool) /\ F <=> F;
|- (t :bool) /\ t <=> t;  |- T \/ (t :bool) <=> T;
|- (t :bool) \/ T <=> T;  |- F \/ (t :bool) <=> t;
|- (t :bool) \/ F <=> t;  |- (t :bool) \/ t <=> t;
|- T ==> (t :bool) <=> t;  |- (t :bool) ==> T <=> T;
|- F ==> (t :bool) <=> T;  |- (t :bool) ==> t <=> T;
|- (t :bool) ==> F <=> ~t;  |- (if T then (t1 :'a) else (t2 :'a)) = t1;
|- (if F then (t1 :'a) else (t2 :'a)) = t2;
|- (!(x :'a). (t :bool)) <=> t;  |- (?(x :'a). (t :bool)) <=> t;
|- (\(x :'b). (t1 :'a)) (t2 :'b) = t1
Number of rewrite rules = 28
:
   rewrites
val bool_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern
   ``(\(x :'a). (y :'b)) (z :'a)``
Congruence rules:
   |- ((v :'a) = (v' :'a)) ==>
      ((literal_case (f :'a -> 'b) v :'b) = (literal_case f (I v') :'b))
Rewrite rules:
   |- !(x :'a). (x = x) <=> T
   |- !(t :bool).
        ((T <=> t) <=> t) /\ ((t <=> T) <=> t) /\ ((F <=> t) <=> ~t) /\
        ((t <=> F) <=> ~t)
   |- (!(t :bool). ~~t <=> t) /\ (~T <=> F) /\ (~F <=> T)
   |- !(t :bool).
        (T /\ t <=> t) /\ (t /\ T <=> t) /\ (F /\ t <=> F) /\
        (t /\ F <=> F) /\ (t /\ t <=> t)
   |- !(t :bool).
        (T \/ t <=> T) /\ (t \/ T <=> T) /\ (F \/ t <=> t) /\
        (t \/ F <=> t) /\ (t \/ t <=> t)
   |- !(t :bool).
        (T ==> t <=> t) /\ (t ==> T <=> T) /\ (F ==> t <=> T) /\
        (t ==> t <=> T) /\ (t ==> F <=> ~t)
   |- !(t1 :'a) (t2 :'a).
        ((if T then t1 else t2) = t1) /\ ((if F then t1 else t2) = t2)
   |- !(t :bool). (!(x :'a). t) <=> t
   |- !(t :bool). (?(x :'a). t) <=> t
   |- !(b :bool) (t :'a). (if b then t else t) = t
   |- !(a :'a). ?(x :'a). x = a
   |- !(a :'a). ?(x :'a). a = x
   |- !(a :'a). ?!(x :'a). x = a
   |- !(a :'a). ?!(x :'a). a = x
   |- (!(b :bool) (e :bool). (if b then T else e) <=> b \/ e) /\
      (!(b :bool) (t :bool). (if b then t else T) <=> b ==> t) /\
      (!(b :bool) (e :bool). (if b then F else e) <=> ~b /\ e) /\
      !(b :bool) (t :bool). (if b then t else F) <=> b /\ t
   |- (literal_case (f :'a -> 'b) (I (x :'a)) :'b) = f x
   |- !(t :bool). t \/ ~t
   |- !(t :bool). ~t \/ t
   |- (!(t1 :'a) (t2 :'a). (if T then t1 else t2) = t1) /\
      !(t1 :'a) (t2 :'a). (if F then t1 else t2) = t2
   |- ~((t :bool) /\ ~t)
   |- !(x :'a). (@(y :'a). y = x) = x
   |- !(x :'a). (@(y :'a). x = y) = x
   |- (!(x :'a)::(P :'a -> bool). T) <=> T
   |- (?(x :'a)::(P :'a -> bool). F) <=> F

Simplification set: NOT
Rewrite rules:
   |- !(A :bool) (B :bool). ~(A ==> B) <=> A /\ ~B
   |- !(A :bool) (B :bool).
        (~(A /\ B) <=> ~A \/ ~B) /\ (~(A \/ B) <=> ~A /\ ~B)
   |- !(P :'a -> bool). ~(!(x :'a). P x) <=> ?(x :'a). ~P x
   |- !(P :'a -> bool). ~(?(x :'a). P x) <=> !(x :'a). ~P x
   |- (~(p :bool) <=> ~(q :bool)) <=> (p <=> q)

Simplification set: CONG
Congruence rules:
   |- !(x :bool) (x' :bool) (y :bool) (y' :bool).
        (x <=> x') ==> (x' ==> (y <=> y')) ==> (x ==> y <=> x' ==> y')
   |- !(P :bool) (Q :bool) (x :'a) (x' :'a) (y :'a) (y' :'a).
        (P <=> Q) ==>
        (Q ==> (x = x')) ==>
        (~Q ==> (y = y')) ==>
        ((if P then x else y) = if Q then x' else y')
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_FORALL P f <=> RES_FORALL Q g)
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_EXISTS P f <=> RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  ``?(x :'a). (P :bool)``
   UNWIND_FORALL_CONV, keyed on pattern  ``!(x :'a). (P :bool)``
:
   simpset
val bounded_tm = ``BOUNDED``: term
val bring_to_front_overload = fn:
   string -> {Name: string, Thy: string} -> unit
val butlast = fn: 'a list -> 'a list
val bvar = fn: term -> term
val bvk_find_term = fn:
   (term list * term -> bool) -> (term -> 'a) -> term -> 'a option
val by = fn: term quotation * tactic -> tactic
val can = fn: ('a -> 'b) -> 'a -> bool
val case_cong_thm = fn: thm -> thm -> thm
val case_constant_defn_name = fn: {type_name: string} -> string
val case_constant_name = fn: {type_name: string} -> string
val cheat = fn: tactic
val checking_const_names = ref true: bool ref
val checking_type_names = ref true: bool ref
datatype class = Axm | Def | Thm
val clear_overloads_on = fn: string -> unit
type 'a cmp = 'a * 'a -> order
val combine = fn: 'a list * 'b list -> ('a * 'b) list
val comm_tm =
   ``(f :'a -> 'a -> 'a) (x :'a) (y :'a) = f y x``:
   term
val commafy = fn: string list -> string list
val compare = fn: term * term -> order
val completeInduct_on = fn: term quotation -> tactic
val concl = fn: thm -> term
val conditional =
   ``(COND :bool -> 'a -> 'a -> 'a)``:
   term
val condprinter = fn: term_grammar.userprinter
val conj_asm1_tac = fn: tactic
val conj_asm2_tac = fn: tactic
val conj_tac = fn: tactic
val conjunction = ``$/\``: term
val cons = fn: 'a -> 'a list -> 'a list
val constants = fn: string -> term list
datatype control = BOUNDED of int ref | UNBOUNDED
type controlled_thm = thm * control
type conv = term -> thm
val csimp = fn: thm list -> tactic
val current_ML_deps = fn: unit -> string list
val current_axioms = fn: unit -> (string * thm) list
val current_backend =
   ref
      {add_break = fn, add_newline = fn, add_string = fn, add_xstring = fn,
       begin_block = fn, begin_style = fn, end_block = fn, end_style = fn,
       name = "emacs_terminal", tm_grammar_upd = fn, ty_grammar_upd = fn}:
   PPBackEnd.t ref
val current_data = fn: string -> (string * thm) list
val current_definitions = fn: unit -> (string * thm) list
val current_grammars = fn:
   unit -> type_grammar.grammar * term_grammar.grammar
val current_theorems = fn: unit -> (string * thm) list
val current_theory = fn: unit -> string
val current_trace = fn: string -> int
val curry = fn: ('a * 'b -> 'c) -> 'a -> 'b -> 'c
type data
val data_exportfn = fn:
   string -> (string -> (string * thm) list -> unit) option
val data_list_to_string = fn: DB.data list -> string
val data_storefn = fn: string -> (string -> unit) option
val decide_tac = fn: tactic
val decls = fn: string -> term list
val def_suffix = ref "_def": string ref
val default_prover = fn: term * tactic -> thm
val define_case_constant = fn: thm -> thm list
val define_new_type_bijections = fn:
   {ABS: string, REP: string, name: string, tyax: thm} -> thm
val definition = fn: string -> thm
val definitions = fn: string -> (string * thm) list
type defn
val deinitcomment = fn: string -> string
val deinitcommentss = fn: substring -> substring
val del_segment = fn: string -> unit
val delete_binding = fn: string -> unit
val delete_const = fn: string -> unit
val delete_hook = fn: string -> unit
val delete_type = fn: string -> unit
datatype 'a delta = DIFF of 'a | SAME
val delta = ``:'d``: hol_type
val delta_apply = fn: ('a -> 'a delta) -> 'a -> 'a
val delta_map = fn: ('a -> 'a delta) -> 'a list -> 'a list delta
val delta_pair = fn:
   ('a -> 'a delta) -> ('b -> 'b delta) -> 'a * 'b -> ('a * 'b) delta
type depdisk = (string * int) * (string * int list) list
val dest_IN = fn: term -> term * term
val dest_abs = fn: term -> term * term
val dest_arb = fn: term -> hol_type
val dest_binder = fn: term -> exn -> term -> term * term
val dest_binop = fn: term -> exn -> term -> term * term
val dest_bool_case = fn: term -> term * term * term
val dest_comb = fn: term -> term * term
val dest_cond = fn: term -> term * term * term
val dest_conj = fn: term -> term * term
val dest_const = fn: term -> string * hol_type
val dest_disj = fn: term -> term * term
val dest_eq = fn: term -> term * term
val dest_eq_ty = fn: term -> term * term * hol_type
val dest_exists = fn: term -> term * term
val dest_exists1 = fn: term -> term * term
val dest_forall = fn: term -> term * term
val dest_imp = fn: term -> term * term
val dest_imp_only = fn: term -> term * term
val dest_itself = fn: term -> hol_type
val dest_let = fn: term -> term * term
val dest_literal_case = fn: term -> term * term
val dest_monop = fn: term -> exn -> term -> term
val dest_neg = fn: term -> term
val dest_quadop = fn: term -> exn -> term -> term * term * term * term
val dest_res_abstract = fn: term -> term * term * term
val dest_res_exists = fn: term -> term * term * term
val dest_res_exists_unique = fn: term -> term * term * term
val dest_res_forall = fn: term -> term * term * term
val dest_res_select = fn: term -> term * term * term
val dest_rewrites = fn: rewrites -> thm list
val dest_select = fn: term -> term * term
val dest_strip_comb = fn: term -> string * term list
val dest_tagged_rewrite = fn: thm -> controlled_thm
val dest_temp_binding = fn: string -> string
val dest_term = fn: term -> lambda
val dest_theory = fn: string -> theory
val dest_thm = fn: thm -> term list * term
val dest_thy_const = fn: term -> {Name: string, Thy: string, Ty: hol_type}
val dest_thy_type = fn:
   hol_type -> {Args: hol_type list, Thy: string, Tyop: string}
val dest_triop = fn: term -> exn -> term -> term * term * term
val dest_type = fn: hol_type -> string * hol_type list
val dest_var = fn: term -> string * hol_type
val dest_vartype = fn: hol_type -> string
val dict_topsort = fn: ('a, 'a list) Redblackmap.dict -> 'a list
val diminish_srw_ss = fn: string list -> ssfrag list
val disable_hook = fn: string -> ('a -> 'b) -> 'a -> 'b
val disable_tyabbrev_printing = fn: string -> unit
val disch = fn: term * term list -> term list
val disch_then = fn: thm_tactic -> tactic
val disj1_tac = fn: tactic
val disj2_tac = fn: tactic
val disjunction = ``$\/``: term
val disk_thm = fn: (depdisk * string list) * term list -> thm
val dom_rng = fn: hol_type -> hol_type * hol_type
val doms_of_tyaxiom = fn: thm -> hol_type list
val dsimp = fn: thm list -> tactic
val el = fn: int -> 'a list -> 'a
val emitCAMLDir = ref "/usr/local/share/HOL/src/emit/Caml/": string ref
val emitMLDir = ref "/usr/local/share/HOL/src/emit/ML/": string ref
val emit_ERR = ref true: bool ref
val emit_MESG = ref true: bool ref
val emit_WARNING = ref true: bool ref
val empty_rewrites = <empty rule set>
Number of rewrite rules = 0
: rewrites
val empty_tmset = ?: term set
val empty_varset = ?: term set
val enable_hook = fn: string -> ('a -> 'b) -> 'a -> 'b
val end_itlist = fn: ('a -> 'a -> 'a) -> 'a list -> 'a
val end_real_time = fn: Timer.real_timer -> unit
val end_time = fn: Timer.cpu_timer -> unit
val enumerate = fn: int -> 'a list -> (int * 'a) list
val eq_tac = fn: tactic
val equal = fn: ''a -> ''a -> bool
val equality =
   ``($= :'a -> 'a -> bool)``:
   term
type error_record =
   {message: string, origin_function: string, origin_structure: string}
val eta_conv = fn: term -> term
val etyvar = ``:'e``: hol_type
val existential =
   ``($? :('a -> bool) -> bool)``:
   term
val exists = fn: ('a -> bool) -> 'a list -> bool
val exists1 =
   ``($?! :('a -> bool) -> bool)``:
   term
val exists_tac = fn: term -> tactic
val exists_tyvar = fn: (hol_type -> bool) -> hol_type -> bool
val exn_to_string = fn: exn -> string
val export_mono = fn: string -> unit
val export_rewrites = fn: string list -> unit
val export_theorems_as_docfiles = fn: string -> (string * thm) list -> unit
val export_theory = fn: unit -> unit
val export_theory_as_docfiles = fn: string -> unit
val fail = fn: unit -> 'a
val failwith = fn: string -> 'a
val fetch = fn: string -> string -> thm
val filter = fn: ('a -> bool) -> 'a list -> 'a list
val find = fn: string -> DB.data list
val find_in = fn: string -> DB.data list -> DB.data list
val find_maximal_terms = fn: (term -> bool) -> term -> term set
val find_maximal_termsl = fn: (term -> bool) -> term -> term list
val find_term = fn: (term -> bool) -> term -> term
val find_terms = fn: (term -> bool) -> term -> term list
val first = fn: ('a -> bool) -> 'a list -> 'a
val first_assum = fn: thm_tactic -> tactic
val first_opt = fn: (int -> 'a -> 'b option) -> 'a list -> 'b option
val first_x_assum = fn: thm_tactic -> tactic
datatype fixity =
    Binder
  | Closefix
  | Infix of associativity * int
  | Prefix of int
  | Suffix of int
val fixity = fn: string -> fixity option
val fixityToString = fn: fixity -> string
val flatten = fn: 'a list list -> 'a list
val flip_cmp = fn: 'a cmp -> 'a cmp
val flip_order = fn: order -> order
val foldl_map = fn: ('a * 'b -> 'a * 'c) -> 'a * 'b list -> 'a * 'c list
val for = fn: int -> int -> (int -> 'a) -> 'a list
val for_se = fn: int -> int -> (int -> unit) -> unit
val format_ERR = fn: error_record -> string
val format_MESG = fn: string -> string
val format_WARNING = fn: string -> string -> string -> string
eqtype 'a frag
val free_in = fn: term -> term -> bool
val free_vars = fn: term -> term list
val free_vars_lr = fn: term -> term list
val free_varsl = fn: term list -> term list
val front_last = fn: 'a list -> 'a list * 'a
val fs = fn: thm list -> tactic
val fsrw_tac = fn: ssfrag list -> thm list -> tactic
val fst = fn: 'a * 'b -> 'a
val ftyvar = ``:'f``: hol_type
val full_simp_tac = fn: simpset -> thm list -> tactic
val funpow = fn: int -> ('a -> 'a) -> 'a -> 'a
val gamma = ``:'c``: hol_type
val gen_all = fn: term -> term
val gen_find_term = fn: (term list * term -> 'a option) -> term -> 'a option
val gen_find_terms = fn: (term list * term -> 'a option) -> term -> 'a list
val gen_new_specification = fn: string * thm -> thm
val gen_prim_specification = fn: string -> thm -> string list * thm
val gen_remove_ovl_mapping = fn: string -> term -> unit
val gen_tac = fn: tactic
val gen_tyvar = fn: unit -> hol_type
val gen_variant = fn: (string -> bool) -> string -> term list -> term -> term
type ('a, 'b) gentactic = 'a -> goal list * (thm list -> 'b)
val genvar = fn: hol_type -> term
val genvars = fn: hol_type -> int -> term list
val get_first = fn: ('a -> 'b option) -> 'a list -> 'b option
val get_hooks = fn: unit -> (string * (TheoryDelta.t -> unit)) list
val get_term_printer = fn: unit -> ppstream -> term -> unit
val get_tracefn = fn: string -> unit -> int
val give_num_priority = fn: char -> unit
type goal = term list * term
val goal_assum = fn: thm_tactic -> tactic
val goal_line = ref "------------------------------------": string ref
val grammarDB = fn: string -> grammarDB_info option
val grammarDB_fold = fn: (string * grammarDB_info * 'a -> 'a) -> 'a -> 'a
type grammarDB_info = type_grammar.grammar * term_grammar.grammar
val grammarDB_insert = fn: string * grammarDB_info -> unit
val guessing_overloads = ref true: bool ref
val guessing_tyvars = ref true: bool ref
val hash = fn: int -> string -> int * int -> int
val hdtm_assum = fn: term -> thm_tactic -> tactic
val hdtm_x_assum = fn: term -> thm_tactic -> tactic
val hidden = fn: string -> bool
val hide = fn:
   string ->
     {Name: string, Thy: string} list * {Name: string, Thy: string} list
val ho_match_mp_tac = fn: thm -> tactic
val ho_match_term = fn:
   hol_type list ->
     term set ->
       term ->
         term ->
           {redex: term, residue: term} list * (hol_type, hol_type) Lib.subst
val ho_match_term0 = fn:
   hol_type list ->
     term set ->
       term ->
         term ->
           {redex: term, residue: int} list *
           {redex: term, residue: term} list *
           ((hol_type, hol_type) Lib.subst * hol_type list)
val hol_clock = ?: Timer.cpu_timer
eqtype hol_type
val html_theory = fn: string -> unit
val hyp = fn: thm -> term list
val hyp_frees = fn: thm -> term set
val hyp_tyvars = fn: thm -> hol_type set
val hypset = fn: thm -> term set
val idem_tm =
   ``(g :'a -> 'a) (g (x :'a)) = g x``:
   term
val imp_res_tac = fn: thm -> tactic
val impl_keep_tac = fn: tactic
val impl_tac = fn: tactic
val implication = ``$==>``:
   term
val implicit_rewrites = fn: unit -> rewrites
val incorporate_consts = fn:
   string -> hol_type vector -> (string * int) list -> unit
val incorporate_types = fn: string -> (string * int) list -> unit
val ind = ``:ind``: hol_type
val index = fn: ('a -> bool) -> 'a list -> int
val inferior_overload_on = fn: string * term -> unit
val insert = fn: ''a -> ''a list -> ''a list
val inst = fn: (hol_type, hol_type) Term.subst -> term -> term
val int_sort = fn: int list -> int list
val int_to_string = fn: int -> string
val interactive = ref true: bool ref
val interactive_ppbackend = fn: unit -> PPBackEnd.t
val intersect = fn: ''a list -> ''a list -> ''a list
val inv_img_cmp = fn: ('a -> 'b) -> 'b cmp -> 'a cmp
val irule = fn: thm -> tactic
val is_IN = fn: term -> bool
val is_abs = fn: term -> bool
val is_arb = fn: term -> bool
val is_bool_case = fn: term -> bool
val is_comb = fn: term -> bool
val is_cond = fn: term -> bool
val is_conj = fn: term -> bool
val is_const = fn: term -> bool
val is_constname = fn: string -> bool
val is_disj = fn: term -> bool
val is_eq = fn: term -> bool
val is_exists = fn: term -> bool
val is_exists1 = fn: term -> bool
val is_forall = fn: term -> bool
val is_gen_tyvar = fn: hol_type -> bool
val is_genvar = fn: term -> bool
val is_imp = fn: term -> bool
val is_imp_only = fn: term -> bool
val is_let = fn: term -> bool
val is_literal_case = fn: term -> bool
val is_neg = fn: term -> bool
val is_res_abstract = fn: term -> bool
val is_res_exists = fn: term -> bool
val is_res_exists_unique = fn: term -> bool
val is_res_forall = fn: term -> bool
val is_res_select = fn: term -> bool
val is_select = fn: term -> bool
val is_substring = fn: string -> string -> bool
val is_temp_binding = fn: string -> bool
val is_the_value = fn: term -> bool
val is_type = fn: hol_type -> bool
val is_var = fn: term -> bool
val is_vartype = fn: hol_type -> bool
type ('a, 'b) istream
val itlist = fn: ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val itlist2 = fn: ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val itself_Axiom =
   |- !(e :'a). ?(f :'b itself -> 'a). f ((:'b) :'b itself) = e:
   thm
val itself_TY_DEF =
   |- ?(rep :'a itself -> 'a). TYPE_DEFINITION ($= (ARB :'a)) rep:
   thm
val itself_case_thm =
   |- !(b :'b). (case ((:'a) :'a itself) of ((:'a) :'a itself) => b) = b:
   thm
val itself_induction =
   |- !(P :'a itself -> bool).
     P ((:'a) :'a itself) ==> !(i :'a itself). P i:
   thm
val kall_tac = fn: 'a -> tactic
val kernelid = "stdknl": string
val known_constants = fn: unit -> string list
datatype lambda =
    COMB of term * term
  | CONST of {Name: string, Thy: string, Ty: hol_type}
  | LAMB of term * term
  | VAR of string * hol_type
val last = fn: 'a list -> 'a
val last_assum = fn: thm_tactic -> tactic
val last_x_assum = fn: thm_tactic -> tactic
val ldistrib_tm =
   ``(f :'a -> 'a -> 'a) (x :'a) ((g :'a -> 'a -> 'a) (y :'a) (z :'a)) =
  g (f x y) (f x z)``:
   term
val let_tm =
   ``(LET :('a -> 'b) -> 'a -> 'b)``:
   term
val lex_cmp = fn: 'a cmp * 'b cmp -> ('c -> 'a) * ('c -> 'b) -> 'c cmp
val lfs = fn: thm list -> tactic
val lhand = fn: term -> term
val lhs = fn: term -> term
val lift_bool = fn: hol_type -> bool -> term
val limit = fn: int -> simpset -> simpset
val linewidth = ref 72: int ref
val link_parents = fn:
   string * num * num -> (string * num * num) list -> unit
val listDB = fn: unit -> DB.data list
val list_compare = fn: 'a cmp -> 'a list cmp
val list_mk_abs = fn: term list * term -> term
val list_mk_binder = fn: term option -> term list * term -> term
val list_mk_comb = fn: term * term list -> term
val list_mk_conj = fn: term list -> term
val list_mk_disj = fn: term list -> term
val list_mk_exists = fn: term list * term -> term
val list_mk_forall = fn: term list * term -> term
val list_mk_fun = fn: hol_type list * hol_type -> hol_type
val list_mk_icomb = fn: term * term list -> term
val list_mk_imp = fn: term list * term -> term
val list_mk_lbinop = fn: ('a -> 'a -> 'a) -> 'a list -> 'a
val list_mk_rbinop = fn: ('a -> 'a -> 'a) -> 'a list -> 'a
val list_mk_res_exists = fn: (term * term) list * term -> term
val list_mk_res_forall = fn: (term * term) list * term -> term
val list_of_pair = fn: 'a * 'a -> 'a list
val list_of_quadruple = fn: 'a * 'a * 'a * 'a -> 'a list
val list_of_singleton = fn: 'a -> 'a list
val list_of_triple = fn: 'a * 'a * 'a -> 'a list
val list_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern
   ``(\(x :'a). (y :'b)) (z :'a)``
Congruence rules:
   |- ((v :'a) = (v' :'a)) ==>
      ((literal_case (f :'a -> 'b) v :'b) = (literal_case f (I v') :'b))
Rewrite rules:
   |- !(x :'a). (x = x) <=> T
   |- !(t :bool).
        ((T <=> t) <=> t) /\ ((t <=> T) <=> t) /\ ((F <=> t) <=> ~t) /\
        ((t <=> F) <=> ~t)
   |- (!(t :bool). ~~t <=> t) /\ (~T <=> F) /\ (~F <=> T)
   |- !(t :bool).
        (T /\ t <=> t) /\ (t /\ T <=> t) /\ (F /\ t <=> F) /\
        (t /\ F <=> F) /\ (t /\ t <=> t)
   |- !(t :bool).
        (T \/ t <=> T) /\ (t \/ T <=> T) /\ (F \/ t <=> t) /\
        (t \/ F <=> t) /\ (t \/ t <=> t)
   |- !(t :bool).
        (T ==> t <=> t) /\ (t ==> T <=> T) /\ (F ==> t <=> T) /\
        (t ==> t <=> T) /\ (t ==> F <=> ~t)
   |- !(t1 :'a) (t2 :'a).
        ((if T then t1 else t2) = t1) /\ ((if F then t1 else t2) = t2)
   |- !(t :bool). (!(x :'a). t) <=> t
   |- !(t :bool). (?(x :'a). t) <=> t
   |- !(b :bool) (t :'a). (if b then t else t) = t
   |- !(a :'a). ?(x :'a). x = a
   |- !(a :'a). ?(x :'a). a = x
   |- !(a :'a). ?!(x :'a). x = a
   |- !(a :'a). ?!(x :'a). a = x
   |- (!(b :bool) (e :bool). (if b then T else e) <=> b \/ e) /\
      (!(b :bool) (t :bool). (if b then t else T) <=> b ==> t) /\
      (!(b :bool) (e :bool). (if b then F else e) <=> ~b /\ e) /\
      !(b :bool) (t :bool). (if b then t else F) <=> b /\ t
   |- (literal_case (f :'a -> 'b) (I (x :'a)) :'b) = f x
   |- !(t :bool). t \/ ~t
   |- !(t :bool). ~t \/ t
   |- (!(t1 :'a) (t2 :'a). (if T then t1 else t2) = t1) /\
      !(t1 :'a) (t2 :'a). (if F then t1 else t2) = t2
   |- ~((t :bool) /\ ~t)
   |- !(x :'a). (@(y :'a). y = x) = x
   |- !(x :'a). (@(y :'a). x = y) = x
   |- (!(x :'a)::(P :'a -> bool). T) <=> T
   |- (?(x :'a)::(P :'a -> bool). F) <=> F

Simplification set: NOT
Rewrite rules:
   |- !(A :bool) (B :bool). ~(A ==> B) <=> A /\ ~B
   |- !(A :bool) (B :bool).
        (~(A /\ B) <=> ~A \/ ~B) /\ (~(A \/ B) <=> ~A /\ ~B)
   |- !(P :'a -> bool). ~(!(x :'a). P x) <=> ?(x :'a). ~P x
   |- !(P :'a -> bool). ~(?(x :'a). P x) <=> !(x :'a). ~P x
   |- (~(p :bool) <=> ~(q :bool)) <=> (p <=> q)

Simplification set: CONG
Congruence rules:
   |- !(x :bool) (x' :bool) (y :bool) (y' :bool).
        (x <=> x') ==> (x' ==> (y <=> y')) ==> (x ==> y <=> x' ==> y')
   |- !(P :bool) (Q :bool) (x :'a) (x' :'a) (y :'a) (y' :'a).
        (P <=> Q) ==>
        (Q ==> (x = x')) ==>
        (~Q ==> (y = y')) ==>
        ((if P then x else y) = if Q then x' else y')
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_FORALL P f <=> RES_FORALL Q g)
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_EXISTS P f <=> RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  ``?(x :'a). (P :bool)``
   UNWIND_FORALL_CONV, keyed on pattern  ``!(x :'a). (P :bool)``

Simplification set: PAIR
Rewrite rules:
   |- !(x :'a # 'b). (FST x,SND x) = x
   |- !(x :'a) (y :'b). FST (x,y) = x
   |- !(x :'a) (y :'b). SND (x,y) = y
   |- !(x :'a) (y :'b) (a :'a) (b :'b).
        ((x,y) = (a,b)) <=> (x = a) /\ (y = b)
   |- !(f :'a -> 'b -> 'c). CURRY (UNCURRY f) = f
   |- !(f :'a # 'b -> 'c). UNCURRY (CURRY f) = f
   |- (CURRY (f :'a # 'b -> 'c) = CURRY (g :'a # 'b -> 'c)) <=> (f = g)
   |- (UNCURRY (f :'a -> 'b -> 'c) = UNCURRY (g :'a -> 'b -> 'c)) <=>
      (f = g)
   |- !(f :'a # 'b -> 'c) (x :'a) (y :'b). CURRY f x y = f (x,y)
   |- !(f :'a -> 'b) (g :'c -> 'd) (x :'a) (y :'c).
        (f ## g) (x,y) = (f x,g y)
   |- !(f :'a -> 'b -> 'c) (x :'a) (y :'b). UNCURRY f (x,y) = f x y

Simplification set: option
Rewrite rules:
   |- !(x :'a) (y :'a). (SOME x = SOME y) <=> (x = y)
   |- !(x :'a option).
        (option_CASE x x (SOME :'a -> 'a option) :'a option) = x
   |- (OPTION_JOIN (NONE :'a option option) = (NONE :'a option)) /\
      !(x :'a option). OPTION_JOIN (SOME x) = x
   |- (!(v :'b) (f :'a -> 'b).
         (option_CASE (NONE :'a option) v f :'b) = v) /\
      !(x :'a) (v :'b) (f :'a -> 'b).
        (option_CASE (SOME x) v f :'b) = f x
   |- !(x :'a). THE (SOME x) = x
   |- !(x :'a option).
        (option_CASE x (NONE :'a option) (SOME :'a -> 'a option) :
           'a option) =
        x
   |- !(x :'a option). ~IS_SOME x <=> (x = (NONE :'a option))
   |- !(x :'a option). IS_NONE x <=> (x = (NONE :'a option))
   |- (!(x :'a). IS_SOME (SOME x) <=> T) /\
      (IS_SOME (NONE :'a option) <=> F)
   |- ((some(x :'a). x = (y :'a)) = SOME y) /\
      ((some(x :'a). y = x) = SOME y)
   |- (!(P :'a -> bool). OPTION_ALL P (NONE :'a option) <=> T) /\
      !(P :'a -> bool) (x :'a). OPTION_ALL P (SOME x) <=> P x
   |- (some(x :'a). F) = (NONE :'a option)
   |- (!(x :'a). (R :'a -> 'a -> bool) x x) ==>
      !(x :'a option). OPTREL R x x
   |- ((OPTION_MAP (f :'b -> 'a) (x :'b option) = (NONE :'a option)) <=>
       (x = (NONE :'b option))) /\
      (((NONE :'a option) = OPTION_MAP f x) <=> (x = (NONE :'b option)))
   |- (!(x :'b option).
         (((NONE :('b -> 'a) option) <*> x) :'a option) =
         (NONE :'a option)) /\
      !(f :'b -> 'a) (x :'b option).
        ((SOME f <*> x) :'a option) = OPTION_MAP f x
   |- OPTION_CHOICE (m1 :'a option) (NONE :'a option) = m1
   |- (!(m2 :'a option). OPTION_CHOICE (NONE :'a option) m2 = m2) /\
      !(x :'a) (m2 :'a option). OPTION_CHOICE (SOME x) m2 = SOME x
   |- ((OPTION_GUARD (b :bool) = SOME ()) <=> b) /\
      ((OPTION_GUARD b = (NONE :unit option)) <=> ~b)
   |- (OPTION_GUARD T = SOME ()) /\
      (OPTION_GUARD F = (NONE :unit option))
   |- ((OPTION_IGNORE_BIND (m1 :'a option) (m2 :'b option) =
        (NONE :'b option)) <=>
       (m1 = (NONE :'a option)) \/ (m2 = (NONE :'b option))) /\
      ((OPTION_IGNORE_BIND m1 m2 = SOME (y :'b)) <=>
       ?(x :'a). (m1 = SOME x) /\ (m2 = SOME y))
   |- (OPTION_IGNORE_BIND (NONE :'b option) (m :'a option) =
       (NONE :'a option)) /\ (OPTION_IGNORE_BIND (SOME (v :'c)) m = m)
   |- ((OPTION_BIND (p :'a option) (f :'a -> 'b option) =
        (NONE :'b option)) <=>
       (p = (NONE :'a option)) \/
       ?(x :'a). (p = SOME x) /\ (f x = (NONE :'b option))) /\
      ((OPTION_BIND p f = SOME (y :'b)) <=>
       ?(x :'a). (p = SOME x) /\ (f x = SOME y))
   |- (!(f :'b -> 'a option).
         OPTION_BIND (NONE :'b option) f = (NONE :'a option)) /\
      !(x :'b) (f :'b -> 'a option). OPTION_BIND (SOME x) f = f x
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
       (NONE :'c option)) <=>
      (o1 = (NONE :'a option)) \/ (o2 = (NONE :'b option))
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
       SOME (v :'c)) <=>
      ?(x1 :'a) (x2 :'b).
        (o1 = SOME x1) /\ (o2 = SOME x2) /\ (v = f x1 x2)
   |- !(f :'a -> 'b) (x :'a option) (y :'b).
        (OPTION_MAP f x = SOME y) <=>
        ?(z :'a). (x = SOME z) /\ (y = f z)
   |- (((if (P :bool) then SOME (x :'a) else (NONE :'a option)) =
        (NONE :'a option)) <=> ~P) /\
      (((if P then (NONE :'a option) else SOME x) =
        (NONE :'a option)) <=> P) /\
      (((if P then SOME x else (NONE :'a option)) = SOME (y :'a)) <=>
       P /\ (x = y)) /\
      (((if P then (NONE :'a option) else SOME x) = SOME y) <=>
       ~P /\ (x = y))
   |- (((if (P :bool) then (X :'a option) else (NONE :'a option)) =
        (NONE :'a option)) <=> P ==> IS_NONE X) /\
      (((if P then (NONE :'a option) else X) = (NONE :'a option)) <=>
       IS_SOME X ==> P) /\
      (((if P then X else (NONE :'a option)) = SOME (x :'a)) <=>
       P /\ (X = SOME x)) /\
      (((if P then (NONE :'a option) else X) = SOME x) <=>
       ~P /\ (X = SOME x))
   |- !(x :'a). (NONE :'a option) <> SOME x
   |- (OPTION_MAP2 (f :'b -> 'c -> 'a) (SOME (x :'b)) (SOME (y :'c)) =
       SOME (f x y)) /\
      (OPTION_MAP2 f (SOME x) (NONE :'c option) = (NONE :'a option)) /\
      (OPTION_MAP2 f (NONE :'b option) (SOME y) = (NONE :'a option)) /\
      (OPTION_MAP2 f (NONE :'b option) (NONE :'c option) =
       (NONE :'a option))
   |- (!(f :'a -> 'b) (x :'a). OPTION_MAP f (SOME x) = SOME (f x)) /\
      !(f :'a -> 'b). OPTION_MAP f (NONE :'a option) = (NONE :'b option)

Simplification set: REDUCE
Conversions:
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``EVEN (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``ODD (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``PRE (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``SUC (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``DIV2 (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) * (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) + (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) - (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) DIV (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) MOD (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) ** (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) < (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) <= (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) > (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) >= (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``MIN (x :num) (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``MAX (x :num) (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) = (y :num)``

Simplification set: sum
Rewrite rules:
   |- (!(y :'a) (x :'a).
         ((INL x :'a + 'b) = (INL y :'a + 'b)) <=> (x = y)) /\
      !(y :'b) (x :'b).
        ((INR x :'a + 'b) = (INR y :'a + 'b)) <=> (x = y)
   |- (!(P :'a -> bool) (Q :'b -> bool) (x :'a).
         SUM_ALL P Q (INL x :'a + 'b) <=> P x) /\
      !(P :'a -> bool) (Q :'b -> bool) (y :'b).
        SUM_ALL P Q (INR y :'a + 'b) <=> Q y
   |- (!(f :'a -> 'c) (g :'b -> 'd) (a :'a).
         ((f ++ g) (INL a :'a + 'b) :'c + 'd) = (INL (f a) :'c + 'd)) /\
      !(f :'a -> 'c) (g :'b -> 'd) (b :'b).
        ((f ++ g) (INR b :'a + 'b) :'c + 'd) = (INR (g b) :'c + 'd)
   |- !(x :'a + 'b). ~ISR x <=> ISL x
   |- !(x :'a + 'b). ~ISL x <=> ISR x
   |- (!(x :'a) (y :'b) (z :'a).
         ((if (P :bool) then (INR x :'b + 'a) else (INL y :'b + 'a)) =
          (INR z :'b + 'a)) <=> P /\ (z = x)) /\
      (!(x :'c) (y :'d) (z :'d).
         ((if P then (INR x :'d + 'c) else (INL y :'d + 'c)) =
          (INL z :'d + 'c)) <=> ~P /\ (z = y)) /\
      (!(x :'e) (y :'f) (z :'e).
         ((if P then (INL x :'e + 'f) else (INR y :'e + 'f)) =
          (INL z :'e + 'f)) <=> P /\ (z = x)) /\
      !(x :'g) (y :'h) (z :'h).
        ((if P then (INL x :'g + 'h) else (INR y :'g + 'h)) =
         (INR z :'g + 'h)) <=> ~P /\ (z = y)
   |- (!(x :'a) (f :'a -> 'c) (f1 :'b -> 'c).
         (sum_CASE (INL x :'a + 'b) f f1 :'c) = f x) /\
      !(y :'b) (f :'a -> 'c) (f1 :'b -> 'c).
        (sum_CASE (INR y :'a + 'b) f f1 :'c) = f1 y
   |- !(x :'a). OUTL (INL x :'a + 'b) = x
   |- !(x :'a + 'b). ISR x ==> ((INR (OUTR x) :'a + 'b) = x)
   |- !(x :'a + 'b). ISL x ==> ((INL (OUTL x) :'a + 'b) = x)
   |- !(x :'b). OUTR (INR x :'a + 'b) = x
   |- (!(x :'a). ISL (INL x :'a + 'b)) /\
      !(y :'b). ~ISL (INR y :'a + 'b)
   |- (!(x :'b). ISR (INR x :'a + 'b)) /\
      !(y :'a). ~ISR (INL y :'a + 'b)
   |- !(x :'a) (y :'b). (INL x :'a + 'b) <> (INR y :'a + 'b)

Simplification set: COMBIN
Rewrite rules:
   |- !(x :'a). I x = x
   |- !(f :'a -> 'b). ((I :'b -> 'b) o f = f) /\ (f o (I :'a -> 'a) = f)
   |- !(x :'a) (y :'b). K x y = x
   |- !(f :'a -> 'b -> 'c) (g :'a -> 'b) (x :'a). S f g x = f x (g x)
   |- !(f :'a -> 'b) (g :'c -> 'a) (h :'d -> 'c).
        (f o g) o h = f o g o h
   |- !(f :'a -> 'b) (g :'c -> 'a) (x :'c). (f o g) x = f (g x)
   |- !(f :'a -> 'a -> 'b) (x :'a). W f x = f x x
   |- !(f :'a -> 'b -> 'c) (x :'b) (y :'a). combin$C f x y = f y x
   |- (!(f :'a -> 'b) (v :'c). (K v :'b -> 'c) o f = (K v :'a -> 'c)) /\
      !(f :'d -> 'e) (v :'d). f o (K v :'f -> 'd) = (K (f v) :'f -> 'e)

Simplification set: ARITH_RWTS
Rewrite rules:
   |- !(x :num).
        ((SUC x = (1 :num)) <=> (x = (0 :num))) /\
        (((1 :num) = SUC x) <=> (x = (0 :num)))
   |- !(x :num).
        ((SUC x = (2 :num)) <=> (x = (1 :num))) /\
        (((2 :num) = SUC x) <=> (x = (1 :num)))
   |- !(m :num). m + (0 :num) = m
   |- !(m :num). (0 :num) + m = m
   |- !(m :num) (n :num).
        (m + n = (0 :num)) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m + n) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num). (m + n = m) <=> (n = (0 :num))
   |- !(m :num) (n :num). (n + m = m) <=> (n = (0 :num))
   |- !(m :num) (n :num).
        (m * n = (0 :num)) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m * n) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(x :num) (y :num).
        (x * y = (1 :num)) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(x :num) (y :num).
        ((1 :num) = x * y) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(m :num). m * (0 :num) = (0 :num)
   |- !(m :num). (0 :num) * m = (0 :num)
   |- !(x :num) (y :num).
        (x * y = SUC (0 :num)) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(x :num) (y :num).
        (SUC (0 :num) = x * y) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(m :num). m * (1 :num) = m
   |- !(m :num). (1 :num) * m = m
   |- !(c :num). c - c = (0 :num)
   |- !(m :num). SUC m - (1 :num) = m
   |- !(m :num). ((0 :num) - m = (0 :num)) /\ (m - (0 :num) = m)
   |- !(a :num) (c :num). a + c - c = a
   |- !(a :num) (c :num). c + a - c = a
   |- !(m :num) (n :num). (m - n = (0 :num)) <=> m <= n
   |- !(m :num) (n :num). ((0 :num) = m - n) <=> m <= n
   |- !(n :num) (m :num). n - m <= n
   |- !(n :num) (m :num). SUC n - SUC m = n - m
   |- !(m :num) (n :num) (p :num). m - n > p <=> m > n + p
   |- !(m :num) (n :num) (p :num).
        m - n < p <=> m < n + p /\ (0 :num) < p
   |- !(m :num) (n :num) (p :num).
        m - n >= p <=> m >= n + p \/ (0 :num) >= p
   |- !(m :num) (n :num) (p :num). m - n <= p <=> m <= n + p
   |- (PRE (0 :num) = (0 :num)) /\ !(m :num). PRE (SUC m) = m
   |- !(n :num) (m :num).
        (n ** m = (0 :num)) <=> (n = (0 :num)) /\ (0 :num) < m
   |- !(n :num). ((1 :num) ** n = (1 :num)) /\ (n ** (1 :num) = n)
   |- !(n :num) (m :num).
        (n ** m = (1 :num)) <=> (n = (1 :num)) \/ (m = (0 :num))
   |- (0 :num) < (x :num) ** (y :num) <=> (0 :num) < x \/ (y = (0 :num))
   |- !(b1 :num) (b2 :num) (x :num).
        (b1 ** x = b2 ** x) <=> (x = (0 :num)) \/ (b1 = b2)
   |- !(b :num).
        (1 :num) < b ==>
        !(n :num) (m :num). (b ** n = b ** m) <=> (n = m)
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m < b ** n <=> m < n
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m <= b ** n <=> m <= n
   |- !(a :num) (b :num).
        a ** (n :num) < b ** n <=> a < b /\ (0 :num) < n
   |- !(a :num) (b :num).
        a ** (n :num) <= b ** n <=> a <= b \/ (n = (0 :num))
   |- !(n :num). n <= (0 :num) <=> (n = (0 :num))
   |- !(n :num). (0 :num) < SUC n
   |- !(m :num) (n :num). m <= m + n
   |- (0 :num) <= (x :num)
   |- SUC (x :num) > (0 :num)
   |- (x :num) >= (0 :num)
   |- (x :num) < SUC x
   |- (x :num) <= SUC x
   |- (x :num) < x + (c :num) <=> (0 :num) < c
   |- (x :num) < (c :num) + x <=> (0 :num) < c
   |- (x :num) <= x + (c :num) <=> (0 :num) <= c
   |- (x :num) <= (c :num) + x <=> (0 :num) <= c
   |- !(m :num). m <= m
   |- (x :num) >= x
   |- !(m :num) (n :num) (p :num). m + p < n + p <=> m < n
   |- !(m :num) (n :num) (p :num). p + m < p + n <=> m < n
   |- !(m :num) (n :num) (p :num). m + n <= m + p <=> n <= p
   |- !(m :num) (n :num) (p :num). n + m <= p + m <=> n <= p
   |- !(m :num) (n :num) (p :num). (m + p = n + p) <=> (m = n)
   |- !(m :num) (n :num) (p :num). (p + m = p + n) <=> (m = n)
   |- (x :num) + (y :num) < (w :num) + x <=> y < w
   |- (y :num) + (x :num) < x + (w :num) <=> y < w
   |- !(m :num) (n :num). (SUC m = SUC n) <=> (m = n)
   |- !(m :num) (n :num). SUC m < SUC n <=> m < n
   |- !(n :num) (m :num). SUC n <= SUC m <=> n <= m
   |- !(m :num) (i :num) (n :num). SUC n * m < SUC n * i <=> m < i
   |- !(p :num) (m :num) (n :num). (n * SUC p = m * SUC p) <=> (n = m)
   |- !(m :num) (i :num) (n :num). (SUC n * m = SUC n * i) <=> (m = i)
   |- !(n :num) (m :num). ~(SUC n <= m) <=> m <= n
   |- !(p :num) (q :num) (n :num) (m :num).
        (n * SUC q ** p = m * SUC q ** p) <=> (n = m)
   |- !(m :num) (n :num) (p :num).
        m * n <= m * p <=> (m = (0 :num)) \/ n <= p
   |- !(m :num) (n :num) (p :num).
        m * n <= p * n <=> (n = (0 :num)) \/ m <= p
   |- !(m :num) (n :num) (p :num).
        m * n < m * p <=> (0 :num) < m /\ n < p
   |- !(m :num) (n :num) (p :num).
        m * n < p * n <=> (0 :num) < n /\ m < p
   |- ((m :num) < m * (n :num) <=> (0 :num) < m /\ (1 :num) < n) /\
      (m < n * m <=> (0 :num) < m /\ (1 :num) < n)
   |- ((m :num) * (n :num) < m <=> (0 :num) < m /\ (n = (0 :num))) /\
      (m * n < n <=> (0 :num) < n /\ (m = (0 :num)))
   |- ((m :num) <= m * (n :num) <=> (m = (0 :num)) \/ (0 :num) < n) /\
      (m <= n * m <=> (m = (0 :num)) \/ (0 :num) < n)
   |- ((m :num) * (n :num) <= m <=> (m = (0 :num)) \/ n <= (1 :num)) /\
      (m * n <= n <=> (n = (0 :num)) \/ m <= (1 :num))
   |- !(m :num) (n :num). SUC n ** m <> (0 :num)
   |- !(n :num) (m :num). SUC (n + n) <> m + m
   |- !(m :num) (n :num). ~(SUC (m + n) <= m)
   |- !(n :num). ~(SUC n <= (0 :num))
   |- !(n :num). ~(n < (0 :num))
   |- !(n :num). ~(n < n)
   |- ~((x :num) > x)
   |- !(n :num).
        (MIN n (0 :num) = (0 :num)) /\ (MIN (0 :num) n = (0 :num))
   |- !(n :num). (MAX n (0 :num) = n) /\ (MAX (0 :num) n = n)
   |- !(n :num). MIN n n = n
   |- !(n :num). MAX n n = n
   |- !(n :num) (m :num) (p :num).
        (MIN m n <= p <=> m <= p \/ n <= p) /\
        (p <= MIN m n <=> p <= m /\ p <= n)
   |- !(n :num) (m :num) (p :num).
        (p <= MAX m n <=> p <= m \/ p <= n) /\
        (MAX m n <= p <=> m <= p /\ n <= p)
   |- !(n :num) (m :num) (p :num).
        (MIN m n < p <=> m < p \/ n < p) /\
        (p < MIN m n <=> p < m /\ p < n)
   |- !(n :num) (m :num) (p :num).
        (p < MAX m n <=> p < m \/ p < n) /\
        (MAX m n < p <=> m < p /\ n < p)
   |- !(m :num) (n :num). (MIN m n = MAX m n) <=> (m = n)
   |- !(m :num) (n :num). MIN m n < MAX m n <=> m <> n
   |- !(x :num) (y :num). (0 :num) < y ==> ((x MOD y = x) <=> x < y)
   |- !(n :num).
        (0 :num) < n ==> (n DIV n = (1 :num)) /\ (n MOD n = (0 :num))
   |- !(q :num). q DIV (1 :num) = q
   |- !(k :num). k MOD (1 :num) = (0 :num)
   |- !(n :num) (k :num). k < n ==> (k MOD n = k)
   |- !(n :num). (0 :num) < n ==> ((0 :num) MOD n = (0 :num))
   |- !(n :num). (0 :num) < n ==> !(k :num). k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 (x :num)) * (y :num) = NUMERAL (z :num)) <=>
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) /\
       (NUMERAL z MOD NUMERAL (BIT1 x) = (0 :num))) /\
      ((NUMERAL (BIT2 x) * y = NUMERAL z) <=>
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) /\
       (NUMERAL z MOD NUMERAL (BIT2 x) = (0 :num)))
   |- !(m :num) (n :num). (0 :num) < n ==> m MOD n < n
   |- !(n :num) (d :num). (0 :num) < n /\ (1 :num) < d ==> n DIV d < n

Simplification set: ARITH_DP
Conversions:
   MUL_CANON_CONV, keyed on pattern  ``(x :num) * (y :num)``
Decision procedures:
   ARITH_REDUCER

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER

Simplification set: list
Rewrite rules:
   |- !(h :'a) (t :'a list). HD (h::t) = h
   |- (!(v :'b) (f :'a -> 'a list -> 'b).
         (list_CASE ([] :'a list) v f :'b) = v) /\
      !(a0 :'a) (a1 :'a list) (v :'b) (f :'a -> 'a list -> 'b).
        (list_CASE (a0::a1) v f :'b) = f a0 a1
   |- !(xs :'a list) (x :'a) (y :'a) (ys :'a list).
        LUPDATE x (LENGTH xs) ((xs ++ y::ys) :'a list) =
        ((xs ++ x::ys) :'a list)
   |- !(x :'a) (n :num) (ys :'a list).
        LENGTH (LUPDATE x n ys) = LENGTH ys
   |- (!(f :'a -> 'b -> 'b) (e :'b). FOLDR f e ([] :'a list) = e) /\
      !(f :'a -> 'b -> 'b) (e :'b) (x :'a) (l :'a list).
        FOLDR f e (x::l) = f x (FOLDR f e l)
   |- (!(f :'b -> 'a -> 'b) (e :'b). FOLDL f e ([] :'a list) = e) /\
      !(f :'b -> 'a -> 'b) (e :'b) (x :'a) (l :'a list).
        FOLDL f e (x::l) = FOLDL f (f e x) l
   |- !(P :'a -> bool) (l :'a list). ~EXISTS P l <=> EVERY ($~ o P) l
   |- !(P :'a -> bool) (l :'a list). ~EVERY P l <=> EXISTS ($~ o P) l
   |- !(c :bool) (l :'a list).
        EXISTS (\(x :'a). c) l <=> l <> ([] :'a list) /\ c
   |- !(c :bool) (l :'a list).
        EVERY (\(x :'a). c) l <=> (l = ([] :'a list)) \/ c
   |- !(P :'a -> bool) (l1 :'a list) (l2 :'a list).
        EXISTS P ((l1 ++ l2) :'a list) <=> EXISTS P l1 \/ EXISTS P l2
   |- !(P :'a -> bool) (l1 :'a list) (l2 :'a list).
        EVERY P ((l1 ++ l2) :'a list) <=> EVERY P l1 /\ EVERY P l2
   |- !(pl :('a # 'b) list).
        (LENGTH (FST (UNZIP pl)) = LENGTH pl) /\
        (LENGTH (SND (UNZIP pl)) = LENGTH pl)
   |- !(l1 :'a list) (l2 :'b list).
        (LENGTH l1 = LENGTH l2) ==>
        (LENGTH (ZIP (l1,l2)) = LENGTH l1) /\
        (LENGTH (ZIP (l1,l2)) = LENGTH l2)
   |- !(l1 :'a list) (l2 :'b list).
        (LENGTH l1 = LENGTH l2) ==> (UNZIP (ZIP (l1,l2)) = (l1,l2))
   |- !(l :('a # 'b) list). ZIP (UNZIP l) = l
   |- (UNZIP ([] :('a # 'b) list) = (([] :'a list),([] :'b list))) /\
      !(x :'a # 'b) (l :('a # 'b) list).
        UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
   |- (ZIP (([] :'a list),([] :'b list)) = ([] :('a # 'b) list)) /\
      !(x1 :'a) (l1 :'a list) (x2 :'b) (l2 :'b list).
        ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
   |- !(l :'a list). set (nub l) = set l
   |- !(l :'a list) (x :'a). l <> x::l /\ x::l <> l
   |- !(a1 :'a list) (a0 :'a). ([] :'a list) <> a0::a1
   |- !(a1 :'a list) (a0 :'a). a0::a1 <> ([] :'a list)
   |- !(f :'a -> 'b) (l1 :'a list) (l2 :'a list).
        MAP f ((l1 ++ l2) :'a list) = ((MAP f l1 ++ MAP f l2) :'b list)
   |- !(l :'a list) (f :'a -> 'b). LENGTH (MAP f l) = LENGTH l
   |- !(a0 :'a) (a1 :'a list) (a0' :'a) (a1' :'a list).
        (a0::a1 = a0'::a1') <=> (a0 = a0') /\ (a1 = a1')
   |- !(l :'a list). ~NULL l ==> (HD l::TL l = l)
   |- !(l1 :'a list) (l2 :'a list) (l3 :'a list).
        ((l1 ++ ((l2 ++ l3) :'a list)) :'a list) =
        ((((l1 ++ l2) :'a list) ++ l3) :'a list)
   |- (SUM ([] :num list) = (0 :num)) /\
      !(h :num) (t :num list). SUM (h::t) = h + SUM t
   |- (NULL ([] :'a list) <=> T) /\
      !(h :'a) (t :'a list). NULL (h::t) <=> F
   |- (!(f :'a -> 'b -> 'c).
         MAP2 f ([] :'a list) ([] :'b list) = ([] :'c list)) /\
      !(f :'d -> 'e -> 'f) (h1 :'d) (t1 :'d list) (h2 :'e)
         (t2 :'e list). MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
   |- (!(l1 :'a list) (l2 :'a list) (l3 :'a list).
         (((l1 ++ l2) :'a list) = ((l1 ++ l3) :'a list)) <=>
         (l2 = l3)) /\
      !(l1 :'a list) (l2 :'a list) (l3 :'a list).
        (((l2 ++ l1) :'a list) = ((l3 ++ l1) :'a list)) <=> (l2 = l3)
   |- (!(P :'a -> bool). dropWhile P ([] :'a list) = ([] :'a list)) /\
      !(P :'a -> bool) (h :'a) (t :'a list).
        dropWhile P (h::t) = if P h then dropWhile P t else h::t
   |- (!(P :'a -> 'b -> bool) (ys :'b list).
         LIST_REL P ([] :'a list) ys <=> (ys = ([] :'b list))) /\
      (!(P :'c -> 'd -> bool) (yys :'d list) (x :'c) (xs :'c list).
         LIST_REL P (x::xs) yys <=>
         ?(y :'d) (ys :'d list).
           (yys = y::ys) /\ P x y /\ LIST_REL P xs ys) /\
      (!(P :'e -> 'f -> bool) (xs :'e list).
         LIST_REL P xs ([] :'f list) <=> (xs = ([] :'e list))) /\
      !(P :'g -> 'h -> bool) (xxs :'g list) (y :'h) (ys :'h list).
        LIST_REL P xxs (y::ys) <=>
        ?(x :'g) (xs :'g list).
          (xxs = x::xs) /\ P x y /\ LIST_REL P xs ys
   |- (!(l :'a list). ([] :'a list) <<= l <=> T) /\
      !(h :'a) (t :'a list) (l :'a list).
        h::t <<= l <=>
        case l of ([] :'a list) => F | h'::t' => (h = h') /\ t <<= t'
   |- ~LLEX (R :'a -> 'a -> bool) (l :'a list) ([] :'a list)
   |- (~LLEX (R :'a -> 'a -> bool) ([] :'a list) ([] :'a list) /\
       ~LLEX R ((h1 :'a)::(t1 :'a list)) ([] :'a list)) /\
      LLEX R ([] :'a list) ((h2 :'a)::(t2 :'a list)) /\
      (LLEX R (h1::t1) (h2::t2) <=>
       R h1 h2 \/ (h1 = h2) /\ LLEX R t1 t2)
   |- (([(f :'b -> 'a)] <*> [(x :'b)]) :'a list) = [f x]
   |- LIST_BIND [(x :'b)] (f :'b -> 'a list) = f x
   |- (LIST_BIND ([] :'b list) (f :'b -> 'a list) = ([] :'a list)) /\
      (LIST_BIND ((h :'b)::(t :'b list)) f =
       ((f h ++ LIST_BIND t f) :'a list))
   |- !(xs :'a list) (n :num) (x :'a).
        (LUPDATE x n xs = ([] :'a list)) <=> (xs = ([] :'a list))
   |- INFINITE univ((:'a list) :'a list itself)
   |- !(ls :'a list) (f :'a # 'a -> 'b).
        MAP f (ZIP (ls,ls)) = MAP (\(x :'a). f (x,x)) ls
   |- !(ls :'a list) (f :'b -> 'a # 'a -> 'b) (e :'b).
        FOLDL f e (ZIP (ls,ls)) =
        FOLDL (\(x :'b) (y :'a). f x (y,y)) e ls
   |- (GENLIST (f :num -> 'a) (0 :num) = ([] :'a list)) /\
      (GENLIST f (NUMERAL (n :num)) =
       GENLIST_AUX f (NUMERAL n) ([] :'a list))
   |- !(f :num -> 'a) (n :num) (x :num).
        x < n ==> (EL x (GENLIST f n) = f x)
   |- (!(f :num -> 'a) (l :'a list). GENLIST_AUX f (0 :num) l = l) /\
      (!(f :num -> 'a) (n :num) (l :'a list).
         GENLIST_AUX f (NUMERAL (BIT1 n)) l =
         GENLIST_AUX f (NUMERAL (BIT1 n) - (1 :num))
           (f (NUMERAL (BIT1 n) - (1 :num))::l)) /\
      !(f :num -> 'a) (n :num) (l :'a list).
        GENLIST_AUX f (NUMERAL (BIT2 n)) l =
        GENLIST_AUX f (NUMERAL (BIT1 n)) (f (NUMERAL (BIT1 n))::l)
   |- !(f :num -> 'a) (n :num). LENGTH (GENLIST f n) = n
   |- !(x :'a) (y :'a list) (a :'a) (b :'a list).
        (SNOC x y = SNOC a b) <=> (x = a) /\ (y = b)
   |- !(y :'a) (x :'a) (l :'a list).
        MEM y (SNOC x l) <=> (y = x) \/ MEM y l
   |- !(x :'a) (l :'a list). FRONT (SNOC x l) = l
   |- !(x :'a) (l :'a list). LAST (SNOC x l) = x
   |- !(x :'a) (l :'a list). LENGTH (SNOC x l) = SUC (LENGTH l)
   |- (!(x :'a). SNOC x ([] :'a list) = [x]) /\
      !(x :'a) (x' :'a) (l :'a list). SNOC x (x'::l) = x'::SNOC x l
   |- (([] :'a list) <<= (l :'a list) <=> T) /\
      ((h :'a)::(t :'a list) <<= ([] :'a list) <=> F) /\
      ((h1 :'a)::(t1 :'a list) <<= (h2 :'a)::(t2 :'a list) <=>
       (h1 = h2) /\ t1 <<= t2)
   |- SET_TO_LIST ({} :'a -> bool) = ([] :'a list)
   |- !(s :'a -> bool). FINITE s ==> ALL_DISTINCT (SET_TO_LIST s)
   |- SET_TO_LIST {(x :'a)} = [x]
   |- !(s :'a -> bool).
        FINITE s ==> !(x :'a). MEM x (SET_TO_LIST s) <=> x IN s
   |- TAKE (0 :num) (l :'a list) = ([] :'a list)
   |- !(ls :'a list). set (REVERSE ls) = set ls
   |- !(l :'a list). FINITE (set l)
   |- ((set (l :'a list) = ({} :'a -> bool)) <=> (l = ([] :'a list))) /\
      ((({} :'a -> bool) = set l) <=> (l = ([] :'a list)))
   |- !(l1 :'a list) (l2 :'a list).
        set ((l1 ++ l2) :'a list) = set l1 UNION set l2
   |- !(xs :'a list list).
        ALL_DISTINCT (FLAT (REVERSE xs)) <=> ALL_DISTINCT (FLAT xs)
   |- !(l :'a list). ALL_DISTINCT (REVERSE l) <=> ALL_DISTINCT l
   |- (ALL_DISTINCT ([] :'a list) <=> T) /\
      !(h :'a) (t :'a list).
        ALL_DISTINCT (h::t) <=> ~MEM h t /\ ALL_DISTINCT t
   |- (!(f :'a -> 'b -> 'c -> 'a) (cs :'c list) (c :'c) (bs :'b list)
          (b :'b) (a :'a).
         FOLDL2 f a (b::bs) (c::cs) = FOLDL2 f (f a b c) bs cs) /\
      (!(f :'a -> 'b -> 'c -> 'a) (cs :'c list) (a :'a).
         FOLDL2 f a ([] :'b list) cs = a) /\
      !(v7 :'b list) (v6 :'b) (f :'a -> 'b -> 'c -> 'a) (a :'a).
        FOLDL2 f a (v6::v7) ([] :'c list) = a
   |- !(n :num) (l :'a list). LENGTH (DROP n l) = LENGTH l - n
   |- !(n :num) (l :'a list). ((TAKE n l ++ DROP n l) :'a list) = l
   |- DROP (0 :num) (l :'a list) = l
   |- !(n :num) (l :'a list). n <= LENGTH l ==> (LENGTH (TAKE n l) = n)
   |- !(l :'a list). TAKE (LENGTH l) l = l
   |- (0 :num) < (n :num) ==>
      (TAKE n ((x :'a)::(xs :'a list)) = x::TAKE (n - (1 :num)) xs)
   |- (0 :num) < (n :num) ==>
      (DROP n ((x :'a)::(xs :'a list)) = DROP (n - (1 :num)) xs)
   |- !(n :num). DROP n ([] :'a list) = ([] :'a list)
   |- !(n :num). TAKE n ([] :'a list) = ([] :'a list)
   |- (REVERSE (l :'a list) = ([] :'a list)) <=> (l = ([] :'a list))
   |- !(h :'a) (l1 :'a list) (l2 :'a list).
        LAST ((l1 ++ h::l2) :'a list) = LAST (h::l2)
   |- (!(x :'a) (xs :'a list).
         (FRONT (x::xs) = ([] :'a list)) <=> (xs = ([] :'a list))) /\
      (!(x :'a) (xs :'a list).
         (([] :'a list) = FRONT (x::xs)) <=> (xs = ([] :'a list))) /\
      !(x :'a) (xs :'a list). NULL (FRONT (x::xs)) <=> NULL xs
   |- !(x :'a) (xs :'a list). LENGTH (FRONT (x::xs)) = LENGTH xs
   |- (!(x :'a). FRONT [x] = ([] :'a list)) /\
      !(x :'a) (y :'a) (z :'a list). FRONT (x::y::z) = x::FRONT (y::z)
   |- !(l :'a list) (f :'a -> 'b).
        l <> ([] :'a list) ==> (LAST (MAP f l) = f (LAST l))
   |- (!(x :'a). LAST [x] = x) /\
      !(x :'a) (y :'a) (z :'a list). LAST (x::y::z) = LAST (y::z)
   |- (REVERSE (l :'a list) = [(e :'a)]) <=> (l = [e])
   |- !(l :'a list) (x :'a). MEM x (REVERSE l) <=> MEM x l
   |- !(l :'a list). LENGTH (REVERSE l) = LENGTH l
   |- !(l1 :'a list) (l2 :'a list).
        (REVERSE l1 = REVERSE l2) <=> (l1 = l2)
   |- (REVERSE ([] :'a list) = ([] :'a list)) /\
      !(h :'a) (t :'a list).
        REVERSE (h::t) = ((REVERSE t ++ [h]) :'a list)
   |- !(l :'a list). REVERSE (REVERSE l) = l
   |- (!(x :'a). MEM x ([] :'a list) <=> F) /\
      !(x :'a) (h :'a) (t :'a list). MEM x (h::t) <=> (x = h) \/ MEM x t
   |- (LIST_REL (R :'a -> 'b -> bool) ([] :'a list) (x :'b list) <=>
       (x = ([] :'b list))) /\
      (LIST_REL R ([] :'a list) (y :'b list) <=> (y = ([] :'b list)))
   |- (LIST_REL (R :'a -> 'b -> bool) ([] :'a list) ([] :'b list) <=>
       T) /\
      (LIST_REL R ((a :'a)::(as :'a list)) ([] :'b list) <=> F) /\
      (LIST_REL R ([] :'a list) ((b :'b)::(bs :'b list)) <=> F) /\
      (LIST_REL R (a::as) (b::bs) <=> R a b /\ LIST_REL R as bs)
   |- (EL (NUMERAL (BIT1 (n :num))) ((l :'a)::(ls :'a list)) =
       EL (PRE (NUMERAL (BIT1 n))) ls) /\
      (EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls)
   |- ((EL (0 :num) :'a list -> 'a) = (HD :'a list -> 'a)) /\
      (EL (SUC (n :num)) ((l :'b)::(ls :'b list)) = EL n ls)
   |- !(e :'a) (l1 :'a list) (l2 :'a list).
        MEM e ((l1 ++ l2) :'a list) <=> MEM e l1 \/ MEM e l2
   |- (!(l1 :'a list) (l2 :'a list).
         (([] :'a list) = ((l1 ++ l2) :'a list)) <=>
         (l1 = ([] :'a list)) /\ (l2 = ([] :'a list))) /\
      !(l1 :'a list) (l2 :'a list).
        (((l1 ++ l2) :'a list) = ([] :'a list)) <=>
        (l1 = ([] :'a list)) /\ (l2 = ([] :'a list))
   |- ((0 :num) = LENGTH (l :'a list)) <=> (l = ([] :'a list))
   |- !(l :'a list). (LENGTH l = (0 :num)) <=> (l = ([] :'a list))
   |- !(l1 :'a list list) (l2 :'a list list).
        FLAT ((l1 ++ l2) :'a list list) =
        ((FLAT l1 ++ FLAT l2) :'a list)
   |- !(l :'a list) (f :'a -> 'b).
        ((MAP f l = ([] :'b list)) <=> (l = ([] :'a list))) /\
        ((([] :'b list) = MAP f l) <=> (l = ([] :'a list)))
   |- (MAP (f :'a -> 'b) (l :'a list) = [(x :'b)]) <=>
      ?(x0 :'a). (l = [x0]) /\ (x = f x0)
   |- (MAP (\(x :'a). x) (l :'a list) = l) /\ (MAP (I :'a -> 'a) l = l)
   |- (LENGTH ([] :'a list) = (0 :num)) /\
      !(h :'a) (t :'a list). LENGTH (h::t) = SUC (LENGTH t)
   |- !(l1 :'a list) (l2 :'a list).
        LENGTH ((l1 ++ l2) :'a list) = LENGTH l1 + LENGTH l2
   |- !(l :'a list). ((l ++ ([] :'a list)) :'a list) = l
   |- (!(P :'a -> bool). EXISTS P ([] :'a list) <=> F) /\
      !(P :'a -> bool) (h :'a) (t :'a list).
        EXISTS P (h::t) <=> P h \/ EXISTS P t
   |- (!(P :'a -> bool). EVERY P ([] :'a list) <=> T) /\
      !(P :'a -> bool) (h :'a) (t :'a list).
        EVERY P (h::t) <=> P h /\ EVERY P t
   |- (!(P :'a -> bool). FILTER P ([] :'a list) = ([] :'a list)) /\
      !(P :'a -> bool) (h :'a) (t :'a list).
        FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
   |- (set ([] :'a list) = ({} :'a -> bool)) /\
      (set ((h :'b)::(t :'b list)) = h INSERT set t)
   |- (!(x :'a). set ([] :'a list) x <=> F) /\
      !(h :'a) (t :'a list) (x :'a). set (h::t) x <=> (x = h) \/ set t x
   |- (!(f :'a -> 'b). MAP f ([] :'a list) = ([] :'b list)) /\
      !(f :'a -> 'b) (h :'a) (t :'a list). MAP f (h::t) = f h::MAP f t
   |- !(h :'a) (t :'a list). TL (h::t) = t
   |- (FLAT ([] :'a list list) = ([] :'a list)) /\
      !(h :'a list) (t :'a list list).
        FLAT (h::t) = ((h ++ FLAT t) :'a list)
   |- (!(l :'a list). ((([] :'a list) ++ l) :'a list) = l) /\
      !(l1 :'a list) (l2 :'a list) (h :'a).
        ((h::l1 ++ l2) :'a list) = h::((l1 ++ l2) :'a list)

Simplification set: <anonymous>
Rewrite rules:
   |- !(x :'a) (y :'a) (s :'a -> bool).
        x IN y INSERT s <=> (x = y) \/ x IN s
   |- !(x :'a). x NOTIN ({} :'a -> bool)
   |- !(s :'a -> bool) (t :'a -> bool) (x :'a).
        x IN s UNION t <=> x IN s \/ x IN t
:
   simpset
type list_tactic = goal list -> goal list * list_validation
type list_validation = thm list -> thm list
val literal_case =
   ``(literal_case :('a -> 'b) -> 'a -> 'b)``:
   term
val literal_case_CONG =
   |- !(f :'a -> 'b) (g :'a -> 'b) (M :'a) (N :'a).
     (M = N) /\ (!(x :'a). (x = N) ==> (f x = g x)) ==>
     ((literal_case f M :'b) = (literal_case g N :'b)):
   thm
val literal_case_DEF =
   |- (literal_case :('a -> 'b) -> 'a -> 'b) =
   (\(f :'a -> 'b) (x :'a). f x):
   thm
val literal_case_RAND =
   |- (P :'b -> 'c) (case (M :'a) of x => (N :'a -> 'b) x) =
   case M of x => P (N x):
   thm
val literal_case_RATOR =
   |- ((case (M :'a) of x => (N :'a -> 'b -> 'c) x) (b :'b) :'c) =
   case M of x => N x b:
   thm
val literal_case_THM =
   |- !(f :'a -> 'b) (x :'a). (literal_case f x :'b) = f x:
   thm
val literal_case_id =
   |- (case (a :'a) of a => (t :'b) | x => (u :'b)) = t:
   thm
val load_complete = fn: string -> unit
val loose_equality = fn: unit -> unit
val lrfs = fn: thm list -> tactic
val lrw = fn: thm list -> tactic
val lspine_binop = fn: ('a -> ('a * 'a) option) -> 'a -> 'a list
val map2 = fn: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
val map_every = fn: ('a -> tactic) -> 'a list -> tactic
val mapfilter = fn: ('a -> 'b) -> 'a list -> 'b list
val mapi = fn: (int -> 'a -> 'b) -> 'a list -> 'b list
val mapshape = fn: int list -> ('a list -> 'b) list -> 'a list -> 'b list
val match = fn: string list -> term -> DB.data list
val match_mp_tac = fn: thm -> tactic
val match_term = fn:
   term -> term -> (term, term) Term.subst * (hol_type, hol_type) Term.subst
val match_terml = fn:
   hol_type list ->
     term set ->
       term ->
         term -> (term, term) Term.subst * (hol_type, hol_type) Term.subst
val match_type = fn: hol_type -> hol_type -> (hol_type, hol_type) Lib.subst
val match_type_in_context = fn:
   hol_type ->
     hol_type ->
       (hol_type, hol_type) Lib.subst -> (hol_type, hol_type) Lib.subst
val match_type_restr = fn:
   hol_type list -> hol_type -> hol_type -> (hol_type, hol_type) Lib.subst
val matcher = fn: (term -> term -> 'a) -> string list -> term -> DB.data list
val matches = fn: term -> thm -> bool
val matchp = fn: (thm -> bool) -> string list -> DB.data list
val max_print_depth = ref ~1: int ref
val measureInduct_on = fn: term quotation -> tactic
val measure_cmp = fn: ('a -> int) -> 'a cmp
val mem = fn: ''a -> ''a list -> bool
val memoize = fn:
   (term -> 'a option) ->
     ('a, thm) Redblackmap.dict -> (term -> bool) -> exn -> conv -> conv
val merge_grammars = fn:
   string list -> type_grammar.grammar * term_grammar.grammar
val metis_tac = fn: thm list -> tactic
val min_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
         TY  ::=  bool | (TY, TY)fun | ind
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  bool = min$bool                                        
  ('a, 'b) fun = ('a, 'b) min$fun                        
  ind = min$ind                                          ,
    (0)    TM  ::=  "@" <..binders..> "." TM | "" <..binders..> "." TM |
                "\" <..binders..> "." TM
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(100)  TM  ::=  TM "=" TM   (non-associative)
(200)  TM  ::=  TM "==>" TM   (R-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
  = ==> @):
   type_grammar.grammar * term_grammar.grammar
val minprint = fn: term -> string
val mk_HOL_ERR = fn: string -> string -> string -> exn
val mk_HOL_ERRloc = fn: string -> string -> locn.locn -> string -> exn
val mk_IN = fn: term * term -> term
val mk_abs = fn: term * term -> term
val mk_arb = fn: hol_type -> term
val mk_axiom_thm = fn: string Nonce.t * term -> thm
val mk_binder = fn: term -> string -> term * term -> term
val mk_binop = fn: term -> term * term -> term
val mk_bool_case = fn: term * term * term -> term
val mk_comb = fn: term * term -> term
val mk_cond = fn: term * term * term -> term
val mk_conj = fn: term * term -> term
val mk_const = fn: string * hol_type -> term
val mk_disj = fn: term * term -> term
val mk_eq = fn: term * term -> term
val mk_exists = fn: term * term -> term
val mk_exists1 = fn: term * term -> term
val mk_forall = fn: term * term -> term
val mk_icomb = fn: term * term -> term
val mk_imp = fn: term * term -> term
val mk_istream = fn: ('a -> 'a) -> 'a -> ('a -> 'b) -> ('a, 'b) istream
val mk_itself = fn: hol_type -> term
val mk_let = fn: term * term -> term
val mk_literal_case = fn: term * term -> term
val mk_monop = fn: term -> term -> term
val mk_neg = fn: term -> term
val mk_oracle_thm = fn: string -> term list * term -> thm
val mk_primed_var = fn: string * hol_type -> term
val mk_quadop = fn: term -> term * term * term * term -> term
val mk_res_abstract = fn: term * term * term -> term
val mk_res_exists = fn: term * term * term -> term
val mk_res_exists_unique = fn: term * term * term -> term
val mk_res_forall = fn: term * term * term -> term
val mk_res_select = fn: term * term * term -> term
val mk_rewrites = fn: thm -> thm list
val mk_select = fn: term * term -> term
val mk_set = fn: ''a list -> ''a list
val mk_thm = fn: term list * term -> thm
val mk_thy_const = fn: {Name: string, Thy: string, Ty: hol_type} -> term
val mk_thy_type = fn:
   {Args: hol_type list, Thy: string, Tyop: string} -> hol_type
val mk_triop = fn: term -> term * term * term -> term
val mk_type = fn: string * hol_type list -> hol_type
val mk_var = fn: string * hol_type -> term
val mk_vartype = fn: string -> hol_type
val mlquote = fn: string -> string
val monitoring = ref false: bool ref
val mp_tac = fn: thm_tactic
val negation = ``$~``: term
val net_of = fn: rewrites -> conv Net.net
val new_axiom = fn: string * term -> thm
val new_binder = fn: string * hol_type -> unit
val new_binder_definition = fn: string * term -> thm
val new_constant = fn: string * hol_type -> unit
val new_definition = fn: string * term -> thm
val new_definition_hook = ref (fn, fn):
   ((term -> term list * term) * (term list * thm -> thm)) ref
val new_exporter = fn:
   string ->
     (string -> (string * thm) list -> unit) ->
       {dest: data -> (string * thm) list option,
         export: string -> unit,
         mk: string list -> data * (string * thm) list}
val new_infix = fn: string * hol_type * int -> unit
val new_infix_type = fn:
   {Arity: int,
     Assoc: associativity, Name: string, ParseName: string option, Prec: int}
     -> unit
val new_infixl_definition = fn: string * term * int -> thm
val new_infixr_definition = fn: string * term * int -> thm
val new_recursive_definition = fn:
   {def: term, name: string, rec_axiom: thm} -> thm
val new_specification = fn: string * string list * thm -> thm
val new_storage_attribute = fn: string -> unit
val new_theory = fn: string -> unit
val new_type = fn: string * int -> unit
val new_type_definition = fn: string * thm -> thm
val next = fn: ('a, 'b) istream -> ('a, 'b) istream
val norm_subst = fn:
   ((term, term) Term.subst * term set) *
   ((hol_type, hol_type) Term.subst * hol_type list) ->
     (term, term) Term.subst * (hol_type, hol_type) Term.subst
val notify_on_tyvar_guess = ref true: bool ref
val ntac = fn: int -> tactic -> tactic
val null_intersection = fn: ''a list -> ''a list -> bool
eqtype num
val old = fn: string -> string
val old_ARITH_ss =
   Simplification set: ARITH_RWTS, OLD_ARITH_DP
Decision procedures:
   ARITH_REDUCER
Rewrite rules:
   |- !(x :num).
        ((SUC x = (1 :num)) <=> (x = (0 :num))) /\
        (((1 :num) = SUC x) <=> (x = (0 :num)))
   |- !(x :num).
        ((SUC x = (2 :num)) <=> (x = (1 :num))) /\
        (((2 :num) = SUC x) <=> (x = (1 :num)))
   |- !(m :num). m + (0 :num) = m
   |- !(m :num). (0 :num) + m = m
   |- !(m :num) (n :num).
        (m + n = (0 :num)) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m + n) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num). (m + n = m) <=> (n = (0 :num))
   |- !(m :num) (n :num). (n + m = m) <=> (n = (0 :num))
   |- !(m :num) (n :num).
        (m * n = (0 :num)) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m * n) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(x :num) (y :num).
        (x * y = (1 :num)) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(x :num) (y :num).
        ((1 :num) = x * y) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(m :num). m * (0 :num) = (0 :num)
   |- !(m :num). (0 :num) * m = (0 :num)
   |- !(x :num) (y :num).
        (x * y = SUC (0 :num)) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(x :num) (y :num).
        (SUC (0 :num) = x * y) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(m :num). m * (1 :num) = m
   |- !(m :num). (1 :num) * m = m
   |- !(c :num). c - c = (0 :num)
   |- !(m :num). SUC m - (1 :num) = m
   |- !(m :num). ((0 :num) - m = (0 :num)) /\ (m - (0 :num) = m)
   |- !(a :num) (c :num). a + c - c = a
   |- !(a :num) (c :num). c + a - c = a
   |- !(m :num) (n :num). (m - n = (0 :num)) <=> m <= n
   |- !(m :num) (n :num). ((0 :num) = m - n) <=> m <= n
   |- !(n :num) (m :num). n - m <= n
   |- !(n :num) (m :num). SUC n - SUC m = n - m
   |- !(m :num) (n :num) (p :num). m - n > p <=> m > n + p
   |- !(m :num) (n :num) (p :num).
        m - n < p <=> m < n + p /\ (0 :num) < p
   |- !(m :num) (n :num) (p :num).
        m - n >= p <=> m >= n + p \/ (0 :num) >= p
   |- !(m :num) (n :num) (p :num). m - n <= p <=> m <= n + p
   |- (PRE (0 :num) = (0 :num)) /\ !(m :num). PRE (SUC m) = m
   |- !(n :num) (m :num).
        (n ** m = (0 :num)) <=> (n = (0 :num)) /\ (0 :num) < m
   |- !(n :num). ((1 :num) ** n = (1 :num)) /\ (n ** (1 :num) = n)
   |- !(n :num) (m :num).
        (n ** m = (1 :num)) <=> (n = (1 :num)) \/ (m = (0 :num))
   |- (0 :num) < (x :num) ** (y :num) <=> (0 :num) < x \/ (y = (0 :num))
   |- !(b1 :num) (b2 :num) (x :num).
        (b1 ** x = b2 ** x) <=> (x = (0 :num)) \/ (b1 = b2)
   |- !(b :num).
        (1 :num) < b ==>
        !(n :num) (m :num). (b ** n = b ** m) <=> (n = m)
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m < b ** n <=> m < n
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m <= b ** n <=> m <= n
   |- !(a :num) (b :num).
        a ** (n :num) < b ** n <=> a < b /\ (0 :num) < n
   |- !(a :num) (b :num).
        a ** (n :num) <= b ** n <=> a <= b \/ (n = (0 :num))
   |- !(n :num). n <= (0 :num) <=> (n = (0 :num))
   |- !(n :num). (0 :num) < SUC n
   |- !(m :num) (n :num). m <= m + n
   |- (0 :num) <= (x :num)
   |- SUC (x :num) > (0 :num)
   |- (x :num) >= (0 :num)
   |- (x :num) < SUC x
   |- (x :num) <= SUC x
   |- (x :num) < x + (c :num) <=> (0 :num) < c
   |- (x :num) < (c :num) + x <=> (0 :num) < c
   |- (x :num) <= x + (c :num) <=> (0 :num) <= c
   |- (x :num) <= (c :num) + x <=> (0 :num) <= c
   |- !(m :num). m <= m
   |- (x :num) >= x
   |- !(m :num) (n :num) (p :num). m + p < n + p <=> m < n
   |- !(m :num) (n :num) (p :num). p + m < p + n <=> m < n
   |- !(m :num) (n :num) (p :num). m + n <= m + p <=> n <= p
   |- !(m :num) (n :num) (p :num). n + m <= p + m <=> n <= p
   |- !(m :num) (n :num) (p :num). (m + p = n + p) <=> (m = n)
   |- !(m :num) (n :num) (p :num). (p + m = p + n) <=> (m = n)
   |- (x :num) + (y :num) < (w :num) + x <=> y < w
   |- (y :num) + (x :num) < x + (w :num) <=> y < w
   |- !(m :num) (n :num). (SUC m = SUC n) <=> (m = n)
   |- !(m :num) (n :num). SUC m < SUC n <=> m < n
   |- !(n :num) (m :num). SUC n <= SUC m <=> n <= m
   |- !(m :num) (i :num) (n :num). SUC n * m < SUC n * i <=> m < i
   |- !(p :num) (m :num) (n :num). (n * SUC p = m * SUC p) <=> (n = m)
   |- !(m :num) (i :num) (n :num). (SUC n * m = SUC n * i) <=> (m = i)
   |- !(n :num) (m :num). ~(SUC n <= m) <=> m <= n
   |- !(p :num) (q :num) (n :num) (m :num).
        (n * SUC q ** p = m * SUC q ** p) <=> (n = m)
   |- !(m :num) (n :num) (p :num).
        m * n <= m * p <=> (m = (0 :num)) \/ n <= p
   |- !(m :num) (n :num) (p :num).
        m * n <= p * n <=> (n = (0 :num)) \/ m <= p
   |- !(m :num) (n :num) (p :num).
        m * n < m * p <=> (0 :num) < m /\ n < p
   |- !(m :num) (n :num) (p :num).
        m * n < p * n <=> (0 :num) < n /\ m < p
   |- ((m :num) < m * (n :num) <=> (0 :num) < m /\ (1 :num) < n) /\
      (m < n * m <=> (0 :num) < m /\ (1 :num) < n)
   |- ((m :num) * (n :num) < m <=> (0 :num) < m /\ (n = (0 :num))) /\
      (m * n < n <=> (0 :num) < n /\ (m = (0 :num)))
   |- ((m :num) <= m * (n :num) <=> (m = (0 :num)) \/ (0 :num) < n) /\
      (m <= n * m <=> (m = (0 :num)) \/ (0 :num) < n)
   |- ((m :num) * (n :num) <= m <=> (m = (0 :num)) \/ n <= (1 :num)) /\
      (m * n <= n <=> (n = (0 :num)) \/ m <= (1 :num))
   |- !(m :num) (n :num). SUC n ** m <> (0 :num)
   |- !(n :num) (m :num). SUC (n + n) <> m + m
   |- !(m :num) (n :num). ~(SUC (m + n) <= m)
   |- !(n :num). ~(SUC n <= (0 :num))
   |- !(n :num). ~(n < (0 :num))
   |- !(n :num). ~(n < n)
   |- ~((x :num) > x)
   |- !(n :num).
        (MIN n (0 :num) = (0 :num)) /\ (MIN (0 :num) n = (0 :num))
   |- !(n :num). (MAX n (0 :num) = n) /\ (MAX (0 :num) n = n)
   |- !(n :num). MIN n n = n
   |- !(n :num). MAX n n = n
   |- !(n :num) (m :num) (p :num).
        (MIN m n <= p <=> m <= p \/ n <= p) /\
        (p <= MIN m n <=> p <= m /\ p <= n)
   |- !(n :num) (m :num) (p :num).
        (p <= MAX m n <=> p <= m \/ p <= n) /\
        (MAX m n <= p <=> m <= p /\ n <= p)
   |- !(n :num) (m :num) (p :num).
        (MIN m n < p <=> m < p \/ n < p) /\
        (p < MIN m n <=> p < m /\ p < n)
   |- !(n :num) (m :num) (p :num).
        (p < MAX m n <=> p < m \/ p < n) /\
        (MAX m n < p <=> m < p /\ n < p)
   |- !(m :num) (n :num). (MIN m n = MAX m n) <=> (m = n)
   |- !(m :num) (n :num). MIN m n < MAX m n <=> m <> n
   |- !(x :num) (y :num). (0 :num) < y ==> ((x MOD y = x) <=> x < y)
   |- !(n :num).
        (0 :num) < n ==> (n DIV n = (1 :num)) /\ (n MOD n = (0 :num))
   |- !(q :num). q DIV (1 :num) = q
   |- !(k :num). k MOD (1 :num) = (0 :num)
   |- !(n :num) (k :num). k < n ==> (k MOD n = k)
   |- !(n :num). (0 :num) < n ==> ((0 :num) MOD n = (0 :num))
   |- !(n :num). (0 :num) < n ==> !(k :num). k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 (x :num)) * (y :num) = NUMERAL (z :num)) <=>
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) /\
       (NUMERAL z MOD NUMERAL (BIT1 x) = (0 :num))) /\
      ((NUMERAL (BIT2 x) * y = NUMERAL z) <=>
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) /\
       (NUMERAL z MOD NUMERAL (BIT2 x) = (0 :num)))
   |- !(m :num) (n :num). (0 :num) < n ==> m MOD n < n
   |- !(n :num) (d :num). (0 :num) < n /\ (1 :num) < d ==> n DIV d < n
:
   ssfrag
val old_arith_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern
   ``(\(x :'a). (y :'b)) (z :'a)``
Congruence rules:
   |- ((v :'a) = (v' :'a)) ==>
      ((literal_case (f :'a -> 'b) v :'b) = (literal_case f (I v') :'b))
Rewrite rules:
   |- !(x :'a). (x = x) <=> T
   |- !(t :bool).
        ((T <=> t) <=> t) /\ ((t <=> T) <=> t) /\ ((F <=> t) <=> ~t) /\
        ((t <=> F) <=> ~t)
   |- (!(t :bool). ~~t <=> t) /\ (~T <=> F) /\ (~F <=> T)
   |- !(t :bool).
        (T /\ t <=> t) /\ (t /\ T <=> t) /\ (F /\ t <=> F) /\
        (t /\ F <=> F) /\ (t /\ t <=> t)
   |- !(t :bool).
        (T \/ t <=> T) /\ (t \/ T <=> T) /\ (F \/ t <=> t) /\
        (t \/ F <=> t) /\ (t \/ t <=> t)
   |- !(t :bool).
        (T ==> t <=> t) /\ (t ==> T <=> T) /\ (F ==> t <=> T) /\
        (t ==> t <=> T) /\ (t ==> F <=> ~t)
   |- !(t1 :'a) (t2 :'a).
        ((if T then t1 else t2) = t1) /\ ((if F then t1 else t2) = t2)
   |- !(t :bool). (!(x :'a). t) <=> t
   |- !(t :bool). (?(x :'a). t) <=> t
   |- !(b :bool) (t :'a). (if b then t else t) = t
   |- !(a :'a). ?(x :'a). x = a
   |- !(a :'a). ?(x :'a). a = x
   |- !(a :'a). ?!(x :'a). x = a
   |- !(a :'a). ?!(x :'a). a = x
   |- (!(b :bool) (e :bool). (if b then T else e) <=> b \/ e) /\
      (!(b :bool) (t :bool). (if b then t else T) <=> b ==> t) /\
      (!(b :bool) (e :bool). (if b then F else e) <=> ~b /\ e) /\
      !(b :bool) (t :bool). (if b then t else F) <=> b /\ t
   |- (literal_case (f :'a -> 'b) (I (x :'a)) :'b) = f x
   |- !(t :bool). t \/ ~t
   |- !(t :bool). ~t \/ t
   |- (!(t1 :'a) (t2 :'a). (if T then t1 else t2) = t1) /\
      !(t1 :'a) (t2 :'a). (if F then t1 else t2) = t2
   |- ~((t :bool) /\ ~t)
   |- !(x :'a). (@(y :'a). y = x) = x
   |- !(x :'a). (@(y :'a). x = y) = x
   |- (!(x :'a)::(P :'a -> bool). T) <=> T
   |- (?(x :'a)::(P :'a -> bool). F) <=> F

Simplification set: NOT
Rewrite rules:
   |- !(A :bool) (B :bool). ~(A ==> B) <=> A /\ ~B
   |- !(A :bool) (B :bool).
        (~(A /\ B) <=> ~A \/ ~B) /\ (~(A \/ B) <=> ~A /\ ~B)
   |- !(P :'a -> bool). ~(!(x :'a). P x) <=> ?(x :'a). ~P x
   |- !(P :'a -> bool). ~(?(x :'a). P x) <=> !(x :'a). ~P x
   |- (~(p :bool) <=> ~(q :bool)) <=> (p <=> q)

Simplification set: CONG
Congruence rules:
   |- !(x :bool) (x' :bool) (y :bool) (y' :bool).
        (x <=> x') ==> (x' ==> (y <=> y')) ==> (x ==> y <=> x' ==> y')
   |- !(P :bool) (Q :bool) (x :'a) (x' :'a) (y :'a) (y' :'a).
        (P <=> Q) ==>
        (Q ==> (x = x')) ==>
        (~Q ==> (y = y')) ==>
        ((if P then x else y) = if Q then x' else y')
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_FORALL P f <=> RES_FORALL Q g)
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_EXISTS P f <=> RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  ``?(x :'a). (P :bool)``
   UNWIND_FORALL_CONV, keyed on pattern  ``!(x :'a). (P :bool)``

Simplification set: PAIR
Rewrite rules:
   |- !(x :'a # 'b). (FST x,SND x) = x
   |- !(x :'a) (y :'b). FST (x,y) = x
   |- !(x :'a) (y :'b). SND (x,y) = y
   |- !(x :'a) (y :'b) (a :'a) (b :'b).
        ((x,y) = (a,b)) <=> (x = a) /\ (y = b)
   |- !(f :'a -> 'b -> 'c). CURRY (UNCURRY f) = f
   |- !(f :'a # 'b -> 'c). UNCURRY (CURRY f) = f
   |- (CURRY (f :'a # 'b -> 'c) = CURRY (g :'a # 'b -> 'c)) <=> (f = g)
   |- (UNCURRY (f :'a -> 'b -> 'c) = UNCURRY (g :'a -> 'b -> 'c)) <=>
      (f = g)
   |- !(f :'a # 'b -> 'c) (x :'a) (y :'b). CURRY f x y = f (x,y)
   |- !(f :'a -> 'b) (g :'c -> 'd) (x :'a) (y :'c).
        (f ## g) (x,y) = (f x,g y)
   |- !(f :'a -> 'b -> 'c) (x :'a) (y :'b). UNCURRY f (x,y) = f x y

Simplification set: option
Rewrite rules:
   |- !(x :'a) (y :'a). (SOME x = SOME y) <=> (x = y)
   |- !(x :'a option).
        (option_CASE x x (SOME :'a -> 'a option) :'a option) = x
   |- (OPTION_JOIN (NONE :'a option option) = (NONE :'a option)) /\
      !(x :'a option). OPTION_JOIN (SOME x) = x
   |- (!(v :'b) (f :'a -> 'b).
         (option_CASE (NONE :'a option) v f :'b) = v) /\
      !(x :'a) (v :'b) (f :'a -> 'b).
        (option_CASE (SOME x) v f :'b) = f x
   |- !(x :'a). THE (SOME x) = x
   |- !(x :'a option).
        (option_CASE x (NONE :'a option) (SOME :'a -> 'a option) :
           'a option) =
        x
   |- !(x :'a option). ~IS_SOME x <=> (x = (NONE :'a option))
   |- !(x :'a option). IS_NONE x <=> (x = (NONE :'a option))
   |- (!(x :'a). IS_SOME (SOME x) <=> T) /\
      (IS_SOME (NONE :'a option) <=> F)
   |- ((some(x :'a). x = (y :'a)) = SOME y) /\
      ((some(x :'a). y = x) = SOME y)
   |- (!(P :'a -> bool). OPTION_ALL P (NONE :'a option) <=> T) /\
      !(P :'a -> bool) (x :'a). OPTION_ALL P (SOME x) <=> P x
   |- (some(x :'a). F) = (NONE :'a option)
   |- (!(x :'a). (R :'a -> 'a -> bool) x x) ==>
      !(x :'a option). OPTREL R x x
   |- ((OPTION_MAP (f :'b -> 'a) (x :'b option) = (NONE :'a option)) <=>
       (x = (NONE :'b option))) /\
      (((NONE :'a option) = OPTION_MAP f x) <=> (x = (NONE :'b option)))
   |- (!(x :'b option).
         (((NONE :('b -> 'a) option) <*> x) :'a option) =
         (NONE :'a option)) /\
      !(f :'b -> 'a) (x :'b option).
        ((SOME f <*> x) :'a option) = OPTION_MAP f x
   |- OPTION_CHOICE (m1 :'a option) (NONE :'a option) = m1
   |- (!(m2 :'a option). OPTION_CHOICE (NONE :'a option) m2 = m2) /\
      !(x :'a) (m2 :'a option). OPTION_CHOICE (SOME x) m2 = SOME x
   |- ((OPTION_GUARD (b :bool) = SOME ()) <=> b) /\
      ((OPTION_GUARD b = (NONE :unit option)) <=> ~b)
   |- (OPTION_GUARD T = SOME ()) /\
      (OPTION_GUARD F = (NONE :unit option))
   |- ((OPTION_IGNORE_BIND (m1 :'a option) (m2 :'b option) =
        (NONE :'b option)) <=>
       (m1 = (NONE :'a option)) \/ (m2 = (NONE :'b option))) /\
      ((OPTION_IGNORE_BIND m1 m2 = SOME (y :'b)) <=>
       ?(x :'a). (m1 = SOME x) /\ (m2 = SOME y))
   |- (OPTION_IGNORE_BIND (NONE :'b option) (m :'a option) =
       (NONE :'a option)) /\ (OPTION_IGNORE_BIND (SOME (v :'c)) m = m)
   |- ((OPTION_BIND (p :'a option) (f :'a -> 'b option) =
        (NONE :'b option)) <=>
       (p = (NONE :'a option)) \/
       ?(x :'a). (p = SOME x) /\ (f x = (NONE :'b option))) /\
      ((OPTION_BIND p f = SOME (y :'b)) <=>
       ?(x :'a). (p = SOME x) /\ (f x = SOME y))
   |- (!(f :'b -> 'a option).
         OPTION_BIND (NONE :'b option) f = (NONE :'a option)) /\
      !(x :'b) (f :'b -> 'a option). OPTION_BIND (SOME x) f = f x
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
       (NONE :'c option)) <=>
      (o1 = (NONE :'a option)) \/ (o2 = (NONE :'b option))
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
       SOME (v :'c)) <=>
      ?(x1 :'a) (x2 :'b).
        (o1 = SOME x1) /\ (o2 = SOME x2) /\ (v = f x1 x2)
   |- !(f :'a -> 'b) (x :'a option) (y :'b).
        (OPTION_MAP f x = SOME y) <=>
        ?(z :'a). (x = SOME z) /\ (y = f z)
   |- (((if (P :bool) then SOME (x :'a) else (NONE :'a option)) =
        (NONE :'a option)) <=> ~P) /\
      (((if P then (NONE :'a option) else SOME x) =
        (NONE :'a option)) <=> P) /\
      (((if P then SOME x else (NONE :'a option)) = SOME (y :'a)) <=>
       P /\ (x = y)) /\
      (((if P then (NONE :'a option) else SOME x) = SOME y) <=>
       ~P /\ (x = y))
   |- (((if (P :bool) then (X :'a option) else (NONE :'a option)) =
        (NONE :'a option)) <=> P ==> IS_NONE X) /\
      (((if P then (NONE :'a option) else X) = (NONE :'a option)) <=>
       IS_SOME X ==> P) /\
      (((if P then X else (NONE :'a option)) = SOME (x :'a)) <=>
       P /\ (X = SOME x)) /\
      (((if P then (NONE :'a option) else X) = SOME x) <=>
       ~P /\ (X = SOME x))
   |- !(x :'a). (NONE :'a option) <> SOME x
   |- (OPTION_MAP2 (f :'b -> 'c -> 'a) (SOME (x :'b)) (SOME (y :'c)) =
       SOME (f x y)) /\
      (OPTION_MAP2 f (SOME x) (NONE :'c option) = (NONE :'a option)) /\
      (OPTION_MAP2 f (NONE :'b option) (SOME y) = (NONE :'a option)) /\
      (OPTION_MAP2 f (NONE :'b option) (NONE :'c option) =
       (NONE :'a option))
   |- (!(f :'a -> 'b) (x :'a). OPTION_MAP f (SOME x) = SOME (f x)) /\
      !(f :'a -> 'b). OPTION_MAP f (NONE :'a option) = (NONE :'b option)

Simplification set: REDUCE
Conversions:
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``EVEN (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``ODD (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``PRE (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``SUC (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``DIV2 (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) * (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) + (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) - (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) DIV (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) MOD (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) ** (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) < (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) <= (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) > (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) >= (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``MIN (x :num) (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``MAX (x :num) (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) = (y :num)``

Simplification set: sum
Rewrite rules:
   |- (!(y :'a) (x :'a).
         ((INL x :'a + 'b) = (INL y :'a + 'b)) <=> (x = y)) /\
      !(y :'b) (x :'b).
        ((INR x :'a + 'b) = (INR y :'a + 'b)) <=> (x = y)
   |- (!(P :'a -> bool) (Q :'b -> bool) (x :'a).
         SUM_ALL P Q (INL x :'a + 'b) <=> P x) /\
      !(P :'a -> bool) (Q :'b -> bool) (y :'b).
        SUM_ALL P Q (INR y :'a + 'b) <=> Q y
   |- (!(f :'a -> 'c) (g :'b -> 'd) (a :'a).
         ((f ++ g) (INL a :'a + 'b) :'c + 'd) = (INL (f a) :'c + 'd)) /\
      !(f :'a -> 'c) (g :'b -> 'd) (b :'b).
        ((f ++ g) (INR b :'a + 'b) :'c + 'd) = (INR (g b) :'c + 'd)
   |- !(x :'a + 'b). ~ISR x <=> ISL x
   |- !(x :'a + 'b). ~ISL x <=> ISR x
   |- (!(x :'a) (y :'b) (z :'a).
         ((if (P :bool) then (INR x :'b + 'a) else (INL y :'b + 'a)) =
          (INR z :'b + 'a)) <=> P /\ (z = x)) /\
      (!(x :'c) (y :'d) (z :'d).
         ((if P then (INR x :'d + 'c) else (INL y :'d + 'c)) =
          (INL z :'d + 'c)) <=> ~P /\ (z = y)) /\
      (!(x :'e) (y :'f) (z :'e).
         ((if P then (INL x :'e + 'f) else (INR y :'e + 'f)) =
          (INL z :'e + 'f)) <=> P /\ (z = x)) /\
      !(x :'g) (y :'h) (z :'h).
        ((if P then (INL x :'g + 'h) else (INR y :'g + 'h)) =
         (INR z :'g + 'h)) <=> ~P /\ (z = y)
   |- (!(x :'a) (f :'a -> 'c) (f1 :'b -> 'c).
         (sum_CASE (INL x :'a + 'b) f f1 :'c) = f x) /\
      !(y :'b) (f :'a -> 'c) (f1 :'b -> 'c).
        (sum_CASE (INR y :'a + 'b) f f1 :'c) = f1 y
   |- !(x :'a). OUTL (INL x :'a + 'b) = x
   |- !(x :'a + 'b). ISR x ==> ((INR (OUTR x) :'a + 'b) = x)
   |- !(x :'a + 'b). ISL x ==> ((INL (OUTL x) :'a + 'b) = x)
   |- !(x :'b). OUTR (INR x :'a + 'b) = x
   |- (!(x :'a). ISL (INL x :'a + 'b)) /\
      !(y :'b). ~ISL (INR y :'a + 'b)
   |- (!(x :'b). ISR (INR x :'a + 'b)) /\
      !(y :'a). ~ISR (INL y :'a + 'b)
   |- !(x :'a) (y :'b). (INL x :'a + 'b) <> (INR y :'a + 'b)

Simplification set: COMBIN
Rewrite rules:
   |- !(x :'a). I x = x
   |- !(f :'a -> 'b). ((I :'b -> 'b) o f = f) /\ (f o (I :'a -> 'a) = f)
   |- !(x :'a) (y :'b). K x y = x
   |- !(f :'a -> 'b -> 'c) (g :'a -> 'b) (x :'a). S f g x = f x (g x)
   |- !(f :'a -> 'b) (g :'c -> 'a) (h :'d -> 'c).
        (f o g) o h = f o g o h
   |- !(f :'a -> 'b) (g :'c -> 'a) (x :'c). (f o g) x = f (g x)
   |- !(f :'a -> 'a -> 'b) (x :'a). W f x = f x x
   |- !(f :'a -> 'b -> 'c) (x :'b) (y :'a). combin$C f x y = f y x
   |- (!(f :'a -> 'b) (v :'c). (K v :'b -> 'c) o f = (K v :'a -> 'c)) /\
      !(f :'d -> 'e) (v :'d). f o (K v :'f -> 'd) = (K (f v) :'f -> 'e)

Simplification set: ARITH_RWTS
Rewrite rules:
   |- !(x :num).
        ((SUC x = (1 :num)) <=> (x = (0 :num))) /\
        (((1 :num) = SUC x) <=> (x = (0 :num)))
   |- !(x :num).
        ((SUC x = (2 :num)) <=> (x = (1 :num))) /\
        (((2 :num) = SUC x) <=> (x = (1 :num)))
   |- !(m :num). m + (0 :num) = m
   |- !(m :num). (0 :num) + m = m
   |- !(m :num) (n :num).
        (m + n = (0 :num)) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m + n) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num). (m + n = m) <=> (n = (0 :num))
   |- !(m :num) (n :num). (n + m = m) <=> (n = (0 :num))
   |- !(m :num) (n :num).
        (m * n = (0 :num)) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m * n) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(x :num) (y :num).
        (x * y = (1 :num)) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(x :num) (y :num).
        ((1 :num) = x * y) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(m :num). m * (0 :num) = (0 :num)
   |- !(m :num). (0 :num) * m = (0 :num)
   |- !(x :num) (y :num).
        (x * y = SUC (0 :num)) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(x :num) (y :num).
        (SUC (0 :num) = x * y) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(m :num). m * (1 :num) = m
   |- !(m :num). (1 :num) * m = m
   |- !(c :num). c - c = (0 :num)
   |- !(m :num). SUC m - (1 :num) = m
   |- !(m :num). ((0 :num) - m = (0 :num)) /\ (m - (0 :num) = m)
   |- !(a :num) (c :num). a + c - c = a
   |- !(a :num) (c :num). c + a - c = a
   |- !(m :num) (n :num). (m - n = (0 :num)) <=> m <= n
   |- !(m :num) (n :num). ((0 :num) = m - n) <=> m <= n
   |- !(n :num) (m :num). n - m <= n
   |- !(n :num) (m :num). SUC n - SUC m = n - m
   |- !(m :num) (n :num) (p :num). m - n > p <=> m > n + p
   |- !(m :num) (n :num) (p :num).
        m - n < p <=> m < n + p /\ (0 :num) < p
   |- !(m :num) (n :num) (p :num).
        m - n >= p <=> m >= n + p \/ (0 :num) >= p
   |- !(m :num) (n :num) (p :num). m - n <= p <=> m <= n + p
   |- (PRE (0 :num) = (0 :num)) /\ !(m :num). PRE (SUC m) = m
   |- !(n :num) (m :num).
        (n ** m = (0 :num)) <=> (n = (0 :num)) /\ (0 :num) < m
   |- !(n :num). ((1 :num) ** n = (1 :num)) /\ (n ** (1 :num) = n)
   |- !(n :num) (m :num).
        (n ** m = (1 :num)) <=> (n = (1 :num)) \/ (m = (0 :num))
   |- (0 :num) < (x :num) ** (y :num) <=> (0 :num) < x \/ (y = (0 :num))
   |- !(b1 :num) (b2 :num) (x :num).
        (b1 ** x = b2 ** x) <=> (x = (0 :num)) \/ (b1 = b2)
   |- !(b :num).
        (1 :num) < b ==>
        !(n :num) (m :num). (b ** n = b ** m) <=> (n = m)
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m < b ** n <=> m < n
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m <= b ** n <=> m <= n
   |- !(a :num) (b :num).
        a ** (n :num) < b ** n <=> a < b /\ (0 :num) < n
   |- !(a :num) (b :num).
        a ** (n :num) <= b ** n <=> a <= b \/ (n = (0 :num))
   |- !(n :num). n <= (0 :num) <=> (n = (0 :num))
   |- !(n :num). (0 :num) < SUC n
   |- !(m :num) (n :num). m <= m + n
   |- (0 :num) <= (x :num)
   |- SUC (x :num) > (0 :num)
   |- (x :num) >= (0 :num)
   |- (x :num) < SUC x
   |- (x :num) <= SUC x
   |- (x :num) < x + (c :num) <=> (0 :num) < c
   |- (x :num) < (c :num) + x <=> (0 :num) < c
   |- (x :num) <= x + (c :num) <=> (0 :num) <= c
   |- (x :num) <= (c :num) + x <=> (0 :num) <= c
   |- !(m :num). m <= m
   |- (x :num) >= x
   |- !(m :num) (n :num) (p :num). m + p < n + p <=> m < n
   |- !(m :num) (n :num) (p :num). p + m < p + n <=> m < n
   |- !(m :num) (n :num) (p :num). m + n <= m + p <=> n <= p
   |- !(m :num) (n :num) (p :num). n + m <= p + m <=> n <= p
   |- !(m :num) (n :num) (p :num). (m + p = n + p) <=> (m = n)
   |- !(m :num) (n :num) (p :num). (p + m = p + n) <=> (m = n)
   |- (x :num) + (y :num) < (w :num) + x <=> y < w
   |- (y :num) + (x :num) < x + (w :num) <=> y < w
   |- !(m :num) (n :num). (SUC m = SUC n) <=> (m = n)
   |- !(m :num) (n :num). SUC m < SUC n <=> m < n
   |- !(n :num) (m :num). SUC n <= SUC m <=> n <= m
   |- !(m :num) (i :num) (n :num). SUC n * m < SUC n * i <=> m < i
   |- !(p :num) (m :num) (n :num). (n * SUC p = m * SUC p) <=> (n = m)
   |- !(m :num) (i :num) (n :num). (SUC n * m = SUC n * i) <=> (m = i)
   |- !(n :num) (m :num). ~(SUC n <= m) <=> m <= n
   |- !(p :num) (q :num) (n :num) (m :num).
        (n * SUC q ** p = m * SUC q ** p) <=> (n = m)
   |- !(m :num) (n :num) (p :num).
        m * n <= m * p <=> (m = (0 :num)) \/ n <= p
   |- !(m :num) (n :num) (p :num).
        m * n <= p * n <=> (n = (0 :num)) \/ m <= p
   |- !(m :num) (n :num) (p :num).
        m * n < m * p <=> (0 :num) < m /\ n < p
   |- !(m :num) (n :num) (p :num).
        m * n < p * n <=> (0 :num) < n /\ m < p
   |- ((m :num) < m * (n :num) <=> (0 :num) < m /\ (1 :num) < n) /\
      (m < n * m <=> (0 :num) < m /\ (1 :num) < n)
   |- ((m :num) * (n :num) < m <=> (0 :num) < m /\ (n = (0 :num))) /\
      (m * n < n <=> (0 :num) < n /\ (m = (0 :num)))
   |- ((m :num) <= m * (n :num) <=> (m = (0 :num)) \/ (0 :num) < n) /\
      (m <= n * m <=> (m = (0 :num)) \/ (0 :num) < n)
   |- ((m :num) * (n :num) <= m <=> (m = (0 :num)) \/ n <= (1 :num)) /\
      (m * n <= n <=> (n = (0 :num)) \/ m <= (1 :num))
   |- !(m :num) (n :num). SUC n ** m <> (0 :num)
   |- !(n :num) (m :num). SUC (n + n) <> m + m
   |- !(m :num) (n :num). ~(SUC (m + n) <= m)
   |- !(n :num). ~(SUC n <= (0 :num))
   |- !(n :num). ~(n < (0 :num))
   |- !(n :num). ~(n < n)
   |- ~((x :num) > x)
   |- !(n :num).
        (MIN n (0 :num) = (0 :num)) /\ (MIN (0 :num) n = (0 :num))
   |- !(n :num). (MAX n (0 :num) = n) /\ (MAX (0 :num) n = n)
   |- !(n :num). MIN n n = n
   |- !(n :num). MAX n n = n
   |- !(n :num) (m :num) (p :num).
        (MIN m n <= p <=> m <= p \/ n <= p) /\
        (p <= MIN m n <=> p <= m /\ p <= n)
   |- !(n :num) (m :num) (p :num).
        (p <= MAX m n <=> p <= m \/ p <= n) /\
        (MAX m n <= p <=> m <= p /\ n <= p)
   |- !(n :num) (m :num) (p :num).
        (MIN m n < p <=> m < p \/ n < p) /\
        (p < MIN m n <=> p < m /\ p < n)
   |- !(n :num) (m :num) (p :num).
        (p < MAX m n <=> p < m \/ p < n) /\
        (MAX m n < p <=> m < p /\ n < p)
   |- !(m :num) (n :num). (MIN m n = MAX m n) <=> (m = n)
   |- !(m :num) (n :num). MIN m n < MAX m n <=> m <> n
   |- !(x :num) (y :num). (0 :num) < y ==> ((x MOD y = x) <=> x < y)
   |- !(n :num).
        (0 :num) < n ==> (n DIV n = (1 :num)) /\ (n MOD n = (0 :num))
   |- !(q :num). q DIV (1 :num) = q
   |- !(k :num). k MOD (1 :num) = (0 :num)
   |- !(n :num) (k :num). k < n ==> (k MOD n = k)
   |- !(n :num). (0 :num) < n ==> ((0 :num) MOD n = (0 :num))
   |- !(n :num). (0 :num) < n ==> !(k :num). k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 (x :num)) * (y :num) = NUMERAL (z :num)) <=>
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) /\
       (NUMERAL z MOD NUMERAL (BIT1 x) = (0 :num))) /\
      ((NUMERAL (BIT2 x) * y = NUMERAL z) <=>
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) /\
       (NUMERAL z MOD NUMERAL (BIT2 x) = (0 :num)))
   |- !(m :num) (n :num). (0 :num) < n ==> m MOD n < n
   |- !(n :num) (d :num). (0 :num) < n /\ (1 :num) < d ==> n DIV d < n

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER

Simplification set: ARITH_RWTS, OLD_ARITH_DP
Decision procedures:
   ARITH_REDUCER
Rewrite rules:
   |- !(x :num).
        ((SUC x = (1 :num)) <=> (x = (0 :num))) /\
        (((1 :num) = SUC x) <=> (x = (0 :num)))
   |- !(x :num).
        ((SUC x = (2 :num)) <=> (x = (1 :num))) /\
        (((2 :num) = SUC x) <=> (x = (1 :num)))
   |- !(m :num). m + (0 :num) = m
   |- !(m :num). (0 :num) + m = m
   |- !(m :num) (n :num).
        (m + n = (0 :num)) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m + n) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num). (m + n = m) <=> (n = (0 :num))
   |- !(m :num) (n :num). (n + m = m) <=> (n = (0 :num))
   |- !(m :num) (n :num).
        (m * n = (0 :num)) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m * n) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(x :num) (y :num).
        (x * y = (1 :num)) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(x :num) (y :num).
        ((1 :num) = x * y) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(m :num). m * (0 :num) = (0 :num)
   |- !(m :num). (0 :num) * m = (0 :num)
   |- !(x :num) (y :num).
        (x * y = SUC (0 :num)) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(x :num) (y :num).
        (SUC (0 :num) = x * y) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(m :num). m * (1 :num) = m
   |- !(m :num). (1 :num) * m = m
   |- !(c :num). c - c = (0 :num)
   |- !(m :num). SUC m - (1 :num) = m
   |- !(m :num). ((0 :num) - m = (0 :num)) /\ (m - (0 :num) = m)
   |- !(a :num) (c :num). a + c - c = a
   |- !(a :num) (c :num). c + a - c = a
   |- !(m :num) (n :num). (m - n = (0 :num)) <=> m <= n
   |- !(m :num) (n :num). ((0 :num) = m - n) <=> m <= n
   |- !(n :num) (m :num). n - m <= n
   |- !(n :num) (m :num). SUC n - SUC m = n - m
   |- !(m :num) (n :num) (p :num). m - n > p <=> m > n + p
   |- !(m :num) (n :num) (p :num).
        m - n < p <=> m < n + p /\ (0 :num) < p
   |- !(m :num) (n :num) (p :num).
        m - n >= p <=> m >= n + p \/ (0 :num) >= p
   |- !(m :num) (n :num) (p :num). m - n <= p <=> m <= n + p
   |- (PRE (0 :num) = (0 :num)) /\ !(m :num). PRE (SUC m) = m
   |- !(n :num) (m :num).
        (n ** m = (0 :num)) <=> (n = (0 :num)) /\ (0 :num) < m
   |- !(n :num). ((1 :num) ** n = (1 :num)) /\ (n ** (1 :num) = n)
   |- !(n :num) (m :num).
        (n ** m = (1 :num)) <=> (n = (1 :num)) \/ (m = (0 :num))
   |- (0 :num) < (x :num) ** (y :num) <=> (0 :num) < x \/ (y = (0 :num))
   |- !(b1 :num) (b2 :num) (x :num).
        (b1 ** x = b2 ** x) <=> (x = (0 :num)) \/ (b1 = b2)
   |- !(b :num).
        (1 :num) < b ==>
        !(n :num) (m :num). (b ** n = b ** m) <=> (n = m)
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m < b ** n <=> m < n
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m <= b ** n <=> m <= n
   |- !(a :num) (b :num).
        a ** (n :num) < b ** n <=> a < b /\ (0 :num) < n
   |- !(a :num) (b :num).
        a ** (n :num) <= b ** n <=> a <= b \/ (n = (0 :num))
   |- !(n :num). n <= (0 :num) <=> (n = (0 :num))
   |- !(n :num). (0 :num) < SUC n
   |- !(m :num) (n :num). m <= m + n
   |- (0 :num) <= (x :num)
   |- SUC (x :num) > (0 :num)
   |- (x :num) >= (0 :num)
   |- (x :num) < SUC x
   |- (x :num) <= SUC x
   |- (x :num) < x + (c :num) <=> (0 :num) < c
   |- (x :num) < (c :num) + x <=> (0 :num) < c
   |- (x :num) <= x + (c :num) <=> (0 :num) <= c
   |- (x :num) <= (c :num) + x <=> (0 :num) <= c
   |- !(m :num). m <= m
   |- (x :num) >= x
   |- !(m :num) (n :num) (p :num). m + p < n + p <=> m < n
   |- !(m :num) (n :num) (p :num). p + m < p + n <=> m < n
   |- !(m :num) (n :num) (p :num). m + n <= m + p <=> n <= p
   |- !(m :num) (n :num) (p :num). n + m <= p + m <=> n <= p
   |- !(m :num) (n :num) (p :num). (m + p = n + p) <=> (m = n)
   |- !(m :num) (n :num) (p :num). (p + m = p + n) <=> (m = n)
   |- (x :num) + (y :num) < (w :num) + x <=> y < w
   |- (y :num) + (x :num) < x + (w :num) <=> y < w
   |- !(m :num) (n :num). (SUC m = SUC n) <=> (m = n)
   |- !(m :num) (n :num). SUC m < SUC n <=> m < n
   |- !(n :num) (m :num). SUC n <= SUC m <=> n <= m
   |- !(m :num) (i :num) (n :num). SUC n * m < SUC n * i <=> m < i
   |- !(p :num) (m :num) (n :num). (n * SUC p = m * SUC p) <=> (n = m)
   |- !(m :num) (i :num) (n :num). (SUC n * m = SUC n * i) <=> (m = i)
   |- !(n :num) (m :num). ~(SUC n <= m) <=> m <= n
   |- !(p :num) (q :num) (n :num) (m :num).
        (n * SUC q ** p = m * SUC q ** p) <=> (n = m)
   |- !(m :num) (n :num) (p :num).
        m * n <= m * p <=> (m = (0 :num)) \/ n <= p
   |- !(m :num) (n :num) (p :num).
        m * n <= p * n <=> (n = (0 :num)) \/ m <= p
   |- !(m :num) (n :num) (p :num).
        m * n < m * p <=> (0 :num) < m /\ n < p
   |- !(m :num) (n :num) (p :num).
        m * n < p * n <=> (0 :num) < n /\ m < p
   |- ((m :num) < m * (n :num) <=> (0 :num) < m /\ (1 :num) < n) /\
      (m < n * m <=> (0 :num) < m /\ (1 :num) < n)
   |- ((m :num) * (n :num) < m <=> (0 :num) < m /\ (n = (0 :num))) /\
      (m * n < n <=> (0 :num) < n /\ (m = (0 :num)))
   |- ((m :num) <= m * (n :num) <=> (m = (0 :num)) \/ (0 :num) < n) /\
      (m <= n * m <=> (m = (0 :num)) \/ (0 :num) < n)
   |- ((m :num) * (n :num) <= m <=> (m = (0 :num)) \/ n <= (1 :num)) /\
      (m * n <= n <=> (n = (0 :num)) \/ m <= (1 :num))
   |- !(m :num) (n :num). SUC n ** m <> (0 :num)
   |- !(n :num) (m :num). SUC (n + n) <> m + m
   |- !(m :num) (n :num). ~(SUC (m + n) <= m)
   |- !(n :num). ~(SUC n <= (0 :num))
   |- !(n :num). ~(n < (0 :num))
   |- !(n :num). ~(n < n)
   |- ~((x :num) > x)
   |- !(n :num).
        (MIN n (0 :num) = (0 :num)) /\ (MIN (0 :num) n = (0 :num))
   |- !(n :num). (MAX n (0 :num) = n) /\ (MAX (0 :num) n = n)
   |- !(n :num). MIN n n = n
   |- !(n :num). MAX n n = n
   |- !(n :num) (m :num) (p :num).
        (MIN m n <= p <=> m <= p \/ n <= p) /\
        (p <= MIN m n <=> p <= m /\ p <= n)
   |- !(n :num) (m :num) (p :num).
        (p <= MAX m n <=> p <= m \/ p <= n) /\
        (MAX m n <= p <=> m <= p /\ n <= p)
   |- !(n :num) (m :num) (p :num).
        (MIN m n < p <=> m < p \/ n < p) /\
        (p < MIN m n <=> p < m /\ p < n)
   |- !(n :num) (m :num) (p :num).
        (p < MAX m n <=> p < m \/ p < n) /\
        (MAX m n < p <=> m < p /\ n < p)
   |- !(m :num) (n :num). (MIN m n = MAX m n) <=> (m = n)
   |- !(m :num) (n :num). MIN m n < MAX m n <=> m <> n
   |- !(x :num) (y :num). (0 :num) < y ==> ((x MOD y = x) <=> x < y)
   |- !(n :num).
        (0 :num) < n ==> (n DIV n = (1 :num)) /\ (n MOD n = (0 :num))
   |- !(q :num). q DIV (1 :num) = q
   |- !(k :num). k MOD (1 :num) = (0 :num)
   |- !(n :num) (k :num). k < n ==> (k MOD n = k)
   |- !(n :num). (0 :num) < n ==> ((0 :num) MOD n = (0 :num))
   |- !(n :num). (0 :num) < n ==> !(k :num). k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 (x :num)) * (y :num) = NUMERAL (z :num)) <=>
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) /\
       (NUMERAL z MOD NUMERAL (BIT1 x) = (0 :num))) /\
      ((NUMERAL (BIT2 x) * y = NUMERAL z) <=>
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) /\
       (NUMERAL z MOD NUMERAL (BIT2 x) = (0 :num)))
   |- !(m :num) (n :num). (0 :num) < n ==> m MOD n < n
   |- !(n :num) (d :num). (0 :num) < n /\ (1 :num) < d ==> n DIV d < n

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER
:
   simpset
val once_asm_rewrite_tac = fn: thm list -> tactic
val once_rewrite_tac = fn: thm list -> tactic
val op_U = fn: ('a -> 'a -> bool) -> 'a list list -> 'a list
val op_arity = fn: {Thy: string, Tyop: string} -> int option
val op_insert = fn: ('a -> 'a -> bool) -> 'a -> 'a list -> 'a list
val op_intersect = fn: ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val op_mem = fn: ('a -> 'a -> bool) -> 'a -> 'a list -> bool
val op_mk_set = fn: ('a -> 'a -> bool) -> 'a list -> 'a list
val op_set_diff = fn: ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val op_union = fn: ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val overload_info_for = fn: string -> unit
val overload_on = fn: string * term -> unit
val overload_on_by_nametype = fn:
   string -> {Name: string, Thy: string} -> unit
val pair = fn: 'a -> 'b -> 'a * 'b
val pair_compare = fn: 'a cmp * 'b cmp -> ('a * 'b) cmp
val pair_of_list = fn: 'a list -> 'a * 'a
val pairarg_tac = fn: tactic
val parents = fn: string -> string list
val parse_from_grammars = fn:
   type_grammar.grammar * term_grammar.grammar ->
     (hol_type frag list -> hol_type) * (term frag list -> term)
val parse_in_context = fn: term list -> term frag list -> term
val part_match_exists_tac = fn: (term -> term) -> term -> tactic
val partial = fn: exn -> ('a -> 'b option) -> 'a -> 'b
val partition = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
datatype pel = pAbs | pLeft | pRight
val pluck = fn: ('a -> bool) -> 'a list -> 'a * 'a list
val polymorphic = fn: hol_type -> bool
val pop_assum = fn: thm_tactic -> tactic
val post_process_term = ref fn: (term -> term) ref
eqtype pp_element
val pp_flags = {show_numeral_types = ref false, show_types = ref true}:
   {show_numeral_types: bool ref, show_types: bool ref}
val pp_rewrites = fn: ppstream -> rewrites -> unit
val pp_term = fn: ppstream -> term -> unit
val pp_term_without_overloads = fn:
   (string * term) list -> ppstream -> term -> unit
val pp_term_without_overloads_on = fn:
   string list -> ppstream -> term -> unit
val pp_theory = fn: ppstream -> theory -> unit
val pp_theory_as_html = fn: ppstream -> string -> unit
val pp_thm = fn: ppstream -> thm -> unit
val pp_type = fn: ppstream -> hol_type -> unit
val pp_type_without_abbrevs = fn: string list -> ppstream -> hol_type -> unit
val pp_with_bquotes = fn: (ppstream -> 'a -> unit) -> ppstream -> 'a -> unit
type ppstream
val ppstring = fn: (ppstream -> 'a -> unit) -> 'a -> string
type pred = term -> bool
val prefer_form_with_tok = fn: {term_name: string, tok: string} -> unit
val prim_delete_const = fn: KernelSig.kernelname -> unit
val prim_delete_type = fn: {Thy: string, Tyop: string} -> unit
val prim_irule = fn: thm -> tactic
val prim_mk_const = fn: {Name: string, Thy: string} -> term
val prim_new_const = fn: KernelSig.kernelname -> hol_type -> term
val prim_new_type = fn: {Thy: string, Tyop: string} -> int -> unit
val prim_specification = fn: string -> string list -> thm -> thm
val prim_type_definition = fn: {Thy: string, Tyop: string} * thm -> thm
val prim_variant = fn: term list -> term -> term
val prime = fn: string -> string
val priming = ref NONE: string option ref
val print_apropos = fn: term -> unit
val print_find = fn: string -> unit
val print_from_grammars = fn:
   type_grammar.grammar * term_grammar.grammar ->
     (ppstream -> hol_type -> unit) * (ppstream -> term -> unit)
val print_match = fn: string list -> term -> unit
val print_term = fn: term -> unit
val print_term_by_grammar = fn:
   type_grammar.grammar * term_grammar.grammar -> term -> unit
val print_term_grammar = fn: unit -> unit
val print_theory = fn: string -> unit
val print_theory_as_html = fn: string -> string -> unit
val print_theory_to_file = fn: string -> string -> unit
val print_theory_to_outstream = fn: string -> TextIO.outstream -> unit
val print_thm = fn: thm -> unit
val print_thy_loads = ref false: bool ref
val print_type = fn: hol_type -> unit
val print_with_style = fn: term_pp_types.pp_style list -> string -> unit
val prove = fn: term * tactic -> thm
val prove_abs_fn_one_one = fn: thm -> thm
val prove_abs_fn_onto = fn: thm -> thm
val prove_case_elim_thm = fn: {case_def: thm, nchotomy: thm} -> thm
val prove_case_eq_thm = fn: {case_def: thm, nchotomy: thm} -> thm
val prove_case_rand_thm = fn: {case_def: thm, nchotomy: thm} -> thm
val prove_cases_thm = fn: thm -> thm list
val prove_constructors_distinct = fn: thm -> thm option list
val prove_constructors_one_one = fn: thm -> thm option list
val prove_induction_thm = fn: thm -> thm
val prove_rec_fn_exists = fn: thm -> term -> thm
val prove_rep_fn_one_one = fn: thm -> thm
val prove_rep_fn_onto = fn: thm -> thm
val prove_tac = fn: thm list -> tactic
val pure_ss = Simplification set: PURE
: simpset
val qabbrev_tac = fn: term quotation -> tactic
val qexists_tac = fn: term quotation -> tactic
val qhdtm_assum = fn: term quotation -> thm_tactic -> tactic
val qhdtm_x_assum = fn: term quotation -> thm_tactic -> tactic
val qho_match_abbrev_tac = fn: term quotation -> tactic
val qid_spec_tac = fn: term quotation -> tactic
val qmatch_abbrev_tac = fn: term quotation -> tactic
val qmatch_asmsub_abbrev_tac = fn: term quotation -> tactic
val qmatch_asmsub_rename_tac = fn: term quotation -> tactic
val qmatch_assum_abbrev_tac = fn: term quotation -> tactic
val qmatch_assum_rename_tac = fn: term quotation -> tactic
val qmatch_goalsub_abbrev_tac = fn: term quotation -> tactic
val qmatch_goalsub_rename_tac = fn: term quotation -> tactic
val qmatch_rename_tac = fn: term quotation -> tactic
val qpat_abbrev_tac = fn: term quotation -> tactic
val qpat_assum = fn: term quotation -> thm_tactic -> tactic
val qpat_x_assum = fn: term quotation -> thm_tactic -> tactic
val qspec_tac = fn: term quotation * term quotation -> tactic
val qspec_then = fn: term quotation -> thm_tactic -> thm -> tactic
val qspecl_then = fn: term quotation list -> thm_tactic -> thm -> tactic
val qsuff_tac = fn: term quotation -> tactic
val quadruple = fn: 'a -> 'b -> 'c -> 'd -> 'a * 'b * 'c * 'd
val quadruple_of_list = fn: 'a list -> 'a * 'a * 'a * 'a
val quiet_messages = fn: ('a -> 'b) -> 'a -> 'b
val quiet_warnings = fn: ('a -> 'b) -> 'a -> 'b
val qunabbrev_tac = fn: term quotation -> tactic
type 'a quotation = 'a frag list
val quote = fn: string -> string
val quote_adjoin_to_theory = fn:
   string ?.HolKernel.Theory.quotation ->
     string ?.HolKernel.Theory.quotation -> unit
val qx_choose_then = fn: term quotation -> thm_tactic -> thm_tactic
val qx_choosel_then = fn: term quotation list -> thm_tactic -> thm_tactic
val qx_gen_tac = fn: term quotation -> tactic
val qx_genl_tac = fn: term quotation list -> tactic
val rand = fn: term -> term
val rator = fn: term -> term
val raw_match = fn:
   hol_type list ->
     term set ->
       term ->
         term ->
           (term, term) Term.subst * (hol_type, hol_type) Term.subst ->
             ((term, term) Term.subst * term set) *
             ((hol_type, hol_type) Term.subst * hol_type list)
val raw_match_type = fn:
   hol_type ->
     hol_type ->
       (hol_type, hol_type) Lib.subst * hol_type list ->
         (hol_type, hol_type) Lib.subst * hol_type list
val rawterm_pp = fn: ('a -> 'b) -> 'a -> 'b
val rdistrib_tm =
   ``(f :'a -> 'a -> 'a) ((g :'a -> 'a -> 'a) (y :'a) (z :'a)) (x :'a) =
  g (f y x) (f z x)``:
   term
val read_raw = fn: term vector -> string -> term
val real_time = fn: ('a -> 'b) -> 'a -> 'b
val recInduct = fn: thm -> tactic
val register_alias_trace = fn: {alias: string, original: string} -> unit
val register_btrace = fn: string * bool ref -> unit
val register_ftrace = fn:
   string * ((unit -> int) * (int -> unit)) * int -> unit
val register_hook = fn: string * (TheoryDelta.t -> unit) -> unit
val register_trace = fn: string * int ref * int -> unit
val release = "Kananaskis": string
val remove_numeral_form = fn: char -> unit
val remove_ovl_mapping = fn: string -> {Name: string, Thy: string} -> unit
val remove_rules_for_term = fn: string -> unit
val remove_termtok = fn: {term_name: string, tok: string} -> unit
val remove_type_abbrev = fn: string -> unit
val remove_user_printer = fn:
   string -> (term * term_grammar.userprinter) option
val rename = fn: term quotation list -> tactic
val rename1 = fn: term quotation -> tactic
val rename_bvar = fn: string -> term -> term
val repeat = fn: ('a -> 'a) -> 'a -> 'a
val res_abstract_tm =
   ``(RES_ABSTRACT :('a -> bool) -> ('a -> 'b) -> 'a -> 'b)``:
   term
val res_exists1_tm =
   ``(RES_EXISTS_UNIQUE :('a -> bool) -> ('a -> bool) -> bool)``:
   term
val res_exists_tm =
   ``(RES_EXISTS :('a -> bool) -> ('a -> bool) -> bool)``:
   term
val res_forall_tm =
   ``(RES_FORALL :('a -> bool) -> ('a -> bool) -> bool)``:
   term
val res_select_tm =
   ``(RES_SELECT :('a -> bool) -> ('a -> bool) -> 'a)``:
   term
val res_tac = fn: tactic
val reset = fn: ('a, 'b) istream -> ('a, 'b) istream
val reset_trace = fn: string -> unit
val reset_traces = fn: unit -> unit
val respect_width_ref = fn:
   int ref -> (ppstream -> 'a -> unit) -> ppstream -> 'a -> unit
val restore_prover = fn: unit -> unit
val rev_assoc = fn: ''a -> ('b * ''a) list -> 'b
val rev_full_simp_tac = fn: simpset -> thm list -> tactic
val rev_itlist = fn: ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val rev_itlist2 = fn:
   ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val reveal = fn: string -> unit
val reverse = fn: tactic -> tactic
val rewrite_tac = fn: thm list -> tactic
type rewrites
val rewrites = fn: thm list -> ssfrag
val rfs = fn: thm list -> tactic
val rhs = fn: term -> term
val rpair = fn: 'a -> 'b -> 'b * 'a
val rpt = fn: tactic -> tactic
type rule = thm -> thm
val rule_assum_tac = fn: (thm -> thm) -> tactic
val rw = fn: thm list -> tactic
val rw_tac = fn: simpset -> thm list -> tactic
val same_const = fn: term -> term -> bool
val save_dep = fn: string -> thm -> thm
val save_thm = fn: string * thm -> thm
val save_thm_attrs = fn: string -> string * string list * thm -> thm
val say = fn: string -> unit
val saying = ref true: bool ref
val scrub = fn: unit -> unit
val sdest_binder = fn: string * string -> exn -> term -> term * term
val sdest_binop = fn: string * string -> exn -> term -> term * term
val sdest_monop = fn: string * string -> exn -> term -> term
val select =
   ``($@ :('a -> bool) -> 'a)``:
   term
val send_to_back_overload = fn: string -> {Name: string, Thy: string} -> unit
val separate = fn: 'a -> 'a list -> 'a list
type 'a set
val set_MLname = fn: string -> string -> unit
val set_diff = fn: ''a list -> ''a list -> ''a list
val set_eq = fn: ''a list -> ''a list -> bool
val set_fixity = fn: string -> fixity -> unit
val set_grammar_ancestry = fn: string list -> unit
val set_implicit_rewrites = fn: rewrites -> unit
val set_known_constants = fn: string list -> unit
val set_mapped_fixity = fn:
   {fixity: fixity, term_name: string, tok: string} -> unit
val set_prover = fn: (term * tactic -> thm) -> unit
val set_term_printer = fn:
   (ppstream -> term -> unit) -> ppstream -> term -> unit
val set_trace = fn: string -> int -> unit
val sg = fn: term quotation -> tactic
val show_assums = ref false: bool ref
val show_axioms = ref true: bool ref
val show_numeral_types = ref false: bool ref
val show_scrub = ref true: bool ref
val show_tags = ref false: bool ref
val show_types = ref true: bool ref
val show_types_verbosely = ref false: bool ref
val simp = fn: thm list -> tactic
val simp_tac = fn: simpset -> thm list -> tactic
type simpset
val singleton_of_list = fn: 'a list -> 'a
val snd = fn: 'a * 'b -> 'b
val sort = fn: ('a -> 'a -> bool) -> 'a list -> 'a list
val sort_vars = fn: string list -> term list -> term list
val spine_binop = fn: ('a -> ('a * 'a) option) -> 'a -> 'a list
val split = fn: ('a * 'b) list -> 'a list * 'b list
val split_after = fn: int -> 'a list -> 'a list * 'a list
val split_pair_case_tac = fn: tactic
val spose_not_then = fn: (thm -> tactic) -> tactic
val srw_ss = fn: unit -> simpset
val srw_tac = fn: ssfrag list -> thm list -> tactic
type ssfrag
val stamp = fn: string -> Time.time
val start_real_time = fn: unit -> Timer.real_timer
val start_time = fn: unit -> Timer.cpu_timer
val state = fn: ('a, 'b) istream -> 'b
val std_binder_precedence = 0: int
val std_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern
   ``(\(x :'a). (y :'b)) (z :'a)``
Congruence rules:
   |- ((v :'a) = (v' :'a)) ==>
      ((literal_case (f :'a -> 'b) v :'b) = (literal_case f (I v') :'b))
Rewrite rules:
   |- !(x :'a). (x = x) <=> T
   |- !(t :bool).
        ((T <=> t) <=> t) /\ ((t <=> T) <=> t) /\ ((F <=> t) <=> ~t) /\
        ((t <=> F) <=> ~t)
   |- (!(t :bool). ~~t <=> t) /\ (~T <=> F) /\ (~F <=> T)
   |- !(t :bool).
        (T /\ t <=> t) /\ (t /\ T <=> t) /\ (F /\ t <=> F) /\
        (t /\ F <=> F) /\ (t /\ t <=> t)
   |- !(t :bool).
        (T \/ t <=> T) /\ (t \/ T <=> T) /\ (F \/ t <=> t) /\
        (t \/ F <=> t) /\ (t \/ t <=> t)
   |- !(t :bool).
        (T ==> t <=> t) /\ (t ==> T <=> T) /\ (F ==> t <=> T) /\
        (t ==> t <=> T) /\ (t ==> F <=> ~t)
   |- !(t1 :'a) (t2 :'a).
        ((if T then t1 else t2) = t1) /\ ((if F then t1 else t2) = t2)
   |- !(t :bool). (!(x :'a). t) <=> t
   |- !(t :bool). (?(x :'a). t) <=> t
   |- !(b :bool) (t :'a). (if b then t else t) = t
   |- !(a :'a). ?(x :'a). x = a
   |- !(a :'a). ?(x :'a). a = x
   |- !(a :'a). ?!(x :'a). x = a
   |- !(a :'a). ?!(x :'a). a = x
   |- (!(b :bool) (e :bool). (if b then T else e) <=> b \/ e) /\
      (!(b :bool) (t :bool). (if b then t else T) <=> b ==> t) /\
      (!(b :bool) (e :bool). (if b then F else e) <=> ~b /\ e) /\
      !(b :bool) (t :bool). (if b then t else F) <=> b /\ t
   |- (literal_case (f :'a -> 'b) (I (x :'a)) :'b) = f x
   |- !(t :bool). t \/ ~t
   |- !(t :bool). ~t \/ t
   |- (!(t1 :'a) (t2 :'a). (if T then t1 else t2) = t1) /\
      !(t1 :'a) (t2 :'a). (if F then t1 else t2) = t2
   |- ~((t :bool) /\ ~t)
   |- !(x :'a). (@(y :'a). y = x) = x
   |- !(x :'a). (@(y :'a). x = y) = x
   |- (!(x :'a)::(P :'a -> bool). T) <=> T
   |- (?(x :'a)::(P :'a -> bool). F) <=> F

Simplification set: NOT
Rewrite rules:
   |- !(A :bool) (B :bool). ~(A ==> B) <=> A /\ ~B
   |- !(A :bool) (B :bool).
        (~(A /\ B) <=> ~A \/ ~B) /\ (~(A \/ B) <=> ~A /\ ~B)
   |- !(P :'a -> bool). ~(!(x :'a). P x) <=> ?(x :'a). ~P x
   |- !(P :'a -> bool). ~(?(x :'a). P x) <=> !(x :'a). ~P x
   |- (~(p :bool) <=> ~(q :bool)) <=> (p <=> q)

Simplification set: CONG
Congruence rules:
   |- !(x :bool) (x' :bool) (y :bool) (y' :bool).
        (x <=> x') ==> (x' ==> (y <=> y')) ==> (x ==> y <=> x' ==> y')
   |- !(P :bool) (Q :bool) (x :'a) (x' :'a) (y :'a) (y' :'a).
        (P <=> Q) ==>
        (Q ==> (x = x')) ==>
        (~Q ==> (y = y')) ==>
        ((if P then x else y) = if Q then x' else y')
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_FORALL P f <=> RES_FORALL Q g)
   |- ((P :'a -> bool) = (Q :'a -> bool)) ==>
      (!(x :'a).
         x IN Q ==> ((f :'a -> bool) x <=> (g :'a -> bool) x)) ==>
      (RES_EXISTS P f <=> RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  ``?(x :'a). (P :bool)``
   UNWIND_FORALL_CONV, keyed on pattern  ``!(x :'a). (P :bool)``

Simplification set: PAIR
Rewrite rules:
   |- !(x :'a # 'b). (FST x,SND x) = x
   |- !(x :'a) (y :'b). FST (x,y) = x
   |- !(x :'a) (y :'b). SND (x,y) = y
   |- !(x :'a) (y :'b) (a :'a) (b :'b).
        ((x,y) = (a,b)) <=> (x = a) /\ (y = b)
   |- !(f :'a -> 'b -> 'c). CURRY (UNCURRY f) = f
   |- !(f :'a # 'b -> 'c). UNCURRY (CURRY f) = f
   |- (CURRY (f :'a # 'b -> 'c) = CURRY (g :'a # 'b -> 'c)) <=> (f = g)
   |- (UNCURRY (f :'a -> 'b -> 'c) = UNCURRY (g :'a -> 'b -> 'c)) <=>
      (f = g)
   |- !(f :'a # 'b -> 'c) (x :'a) (y :'b). CURRY f x y = f (x,y)
   |- !(f :'a -> 'b) (g :'c -> 'd) (x :'a) (y :'c).
        (f ## g) (x,y) = (f x,g y)
   |- !(f :'a -> 'b -> 'c) (x :'a) (y :'b). UNCURRY f (x,y) = f x y

Simplification set: option
Rewrite rules:
   |- !(x :'a) (y :'a). (SOME x = SOME y) <=> (x = y)
   |- !(x :'a option).
        (option_CASE x x (SOME :'a -> 'a option) :'a option) = x
   |- (OPTION_JOIN (NONE :'a option option) = (NONE :'a option)) /\
      !(x :'a option). OPTION_JOIN (SOME x) = x
   |- (!(v :'b) (f :'a -> 'b).
         (option_CASE (NONE :'a option) v f :'b) = v) /\
      !(x :'a) (v :'b) (f :'a -> 'b).
        (option_CASE (SOME x) v f :'b) = f x
   |- !(x :'a). THE (SOME x) = x
   |- !(x :'a option).
        (option_CASE x (NONE :'a option) (SOME :'a -> 'a option) :
           'a option) =
        x
   |- !(x :'a option). ~IS_SOME x <=> (x = (NONE :'a option))
   |- !(x :'a option). IS_NONE x <=> (x = (NONE :'a option))
   |- (!(x :'a). IS_SOME (SOME x) <=> T) /\
      (IS_SOME (NONE :'a option) <=> F)
   |- ((some(x :'a). x = (y :'a)) = SOME y) /\
      ((some(x :'a). y = x) = SOME y)
   |- (!(P :'a -> bool). OPTION_ALL P (NONE :'a option) <=> T) /\
      !(P :'a -> bool) (x :'a). OPTION_ALL P (SOME x) <=> P x
   |- (some(x :'a). F) = (NONE :'a option)
   |- (!(x :'a). (R :'a -> 'a -> bool) x x) ==>
      !(x :'a option). OPTREL R x x
   |- ((OPTION_MAP (f :'b -> 'a) (x :'b option) = (NONE :'a option)) <=>
       (x = (NONE :'b option))) /\
      (((NONE :'a option) = OPTION_MAP f x) <=> (x = (NONE :'b option)))
   |- (!(x :'b option).
         (((NONE :('b -> 'a) option) <*> x) :'a option) =
         (NONE :'a option)) /\
      !(f :'b -> 'a) (x :'b option).
        ((SOME f <*> x) :'a option) = OPTION_MAP f x
   |- OPTION_CHOICE (m1 :'a option) (NONE :'a option) = m1
   |- (!(m2 :'a option). OPTION_CHOICE (NONE :'a option) m2 = m2) /\
      !(x :'a) (m2 :'a option). OPTION_CHOICE (SOME x) m2 = SOME x
   |- ((OPTION_GUARD (b :bool) = SOME ()) <=> b) /\
      ((OPTION_GUARD b = (NONE :unit option)) <=> ~b)
   |- (OPTION_GUARD T = SOME ()) /\
      (OPTION_GUARD F = (NONE :unit option))
   |- ((OPTION_IGNORE_BIND (m1 :'a option) (m2 :'b option) =
        (NONE :'b option)) <=>
       (m1 = (NONE :'a option)) \/ (m2 = (NONE :'b option))) /\
      ((OPTION_IGNORE_BIND m1 m2 = SOME (y :'b)) <=>
       ?(x :'a). (m1 = SOME x) /\ (m2 = SOME y))
   |- (OPTION_IGNORE_BIND (NONE :'b option) (m :'a option) =
       (NONE :'a option)) /\ (OPTION_IGNORE_BIND (SOME (v :'c)) m = m)
   |- ((OPTION_BIND (p :'a option) (f :'a -> 'b option) =
        (NONE :'b option)) <=>
       (p = (NONE :'a option)) \/
       ?(x :'a). (p = SOME x) /\ (f x = (NONE :'b option))) /\
      ((OPTION_BIND p f = SOME (y :'b)) <=>
       ?(x :'a). (p = SOME x) /\ (f x = SOME y))
   |- (!(f :'b -> 'a option).
         OPTION_BIND (NONE :'b option) f = (NONE :'a option)) /\
      !(x :'b) (f :'b -> 'a option). OPTION_BIND (SOME x) f = f x
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
       (NONE :'c option)) <=>
      (o1 = (NONE :'a option)) \/ (o2 = (NONE :'b option))
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
       SOME (v :'c)) <=>
      ?(x1 :'a) (x2 :'b).
        (o1 = SOME x1) /\ (o2 = SOME x2) /\ (v = f x1 x2)
   |- !(f :'a -> 'b) (x :'a option) (y :'b).
        (OPTION_MAP f x = SOME y) <=>
        ?(z :'a). (x = SOME z) /\ (y = f z)
   |- (((if (P :bool) then SOME (x :'a) else (NONE :'a option)) =
        (NONE :'a option)) <=> ~P) /\
      (((if P then (NONE :'a option) else SOME x) =
        (NONE :'a option)) <=> P) /\
      (((if P then SOME x else (NONE :'a option)) = SOME (y :'a)) <=>
       P /\ (x = y)) /\
      (((if P then (NONE :'a option) else SOME x) = SOME y) <=>
       ~P /\ (x = y))
   |- (((if (P :bool) then (X :'a option) else (NONE :'a option)) =
        (NONE :'a option)) <=> P ==> IS_NONE X) /\
      (((if P then (NONE :'a option) else X) = (NONE :'a option)) <=>
       IS_SOME X ==> P) /\
      (((if P then X else (NONE :'a option)) = SOME (x :'a)) <=>
       P /\ (X = SOME x)) /\
      (((if P then (NONE :'a option) else X) = SOME x) <=>
       ~P /\ (X = SOME x))
   |- !(x :'a). (NONE :'a option) <> SOME x
   |- (OPTION_MAP2 (f :'b -> 'c -> 'a) (SOME (x :'b)) (SOME (y :'c)) =
       SOME (f x y)) /\
      (OPTION_MAP2 f (SOME x) (NONE :'c option) = (NONE :'a option)) /\
      (OPTION_MAP2 f (NONE :'b option) (SOME y) = (NONE :'a option)) /\
      (OPTION_MAP2 f (NONE :'b option) (NONE :'c option) =
       (NONE :'a option))
   |- (!(f :'a -> 'b) (x :'a). OPTION_MAP f (SOME x) = SOME (f x)) /\
      !(f :'a -> 'b). OPTION_MAP f (NONE :'a option) = (NONE :'b option)

Simplification set: REDUCE
Conversions:
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``EVEN (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``ODD (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``PRE (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``SUC (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``DIV2 (x :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) * (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) + (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) - (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) DIV (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) MOD (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) ** (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) < (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) <= (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) > (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) >= (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``MIN (x :num) (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``MAX (x :num) (y :num)``
   REDUCE_CONV (arithmetic reduction), keyed on pattern
   ``(x :num) = (y :num)``

Simplification set: sum
Rewrite rules:
   |- (!(y :'a) (x :'a).
         ((INL x :'a + 'b) = (INL y :'a + 'b)) <=> (x = y)) /\
      !(y :'b) (x :'b).
        ((INR x :'a + 'b) = (INR y :'a + 'b)) <=> (x = y)
   |- (!(P :'a -> bool) (Q :'b -> bool) (x :'a).
         SUM_ALL P Q (INL x :'a + 'b) <=> P x) /\
      !(P :'a -> bool) (Q :'b -> bool) (y :'b).
        SUM_ALL P Q (INR y :'a + 'b) <=> Q y
   |- (!(f :'a -> 'c) (g :'b -> 'd) (a :'a).
         ((f ++ g) (INL a :'a + 'b) :'c + 'd) = (INL (f a) :'c + 'd)) /\
      !(f :'a -> 'c) (g :'b -> 'd) (b :'b).
        ((f ++ g) (INR b :'a + 'b) :'c + 'd) = (INR (g b) :'c + 'd)
   |- !(x :'a + 'b). ~ISR x <=> ISL x
   |- !(x :'a + 'b). ~ISL x <=> ISR x
   |- (!(x :'a) (y :'b) (z :'a).
         ((if (P :bool) then (INR x :'b + 'a) else (INL y :'b + 'a)) =
          (INR z :'b + 'a)) <=> P /\ (z = x)) /\
      (!(x :'c) (y :'d) (z :'d).
         ((if P then (INR x :'d + 'c) else (INL y :'d + 'c)) =
          (INL z :'d + 'c)) <=> ~P /\ (z = y)) /\
      (!(x :'e) (y :'f) (z :'e).
         ((if P then (INL x :'e + 'f) else (INR y :'e + 'f)) =
          (INL z :'e + 'f)) <=> P /\ (z = x)) /\
      !(x :'g) (y :'h) (z :'h).
        ((if P then (INL x :'g + 'h) else (INR y :'g + 'h)) =
         (INR z :'g + 'h)) <=> ~P /\ (z = y)
   |- (!(x :'a) (f :'a -> 'c) (f1 :'b -> 'c).
         (sum_CASE (INL x :'a + 'b) f f1 :'c) = f x) /\
      !(y :'b) (f :'a -> 'c) (f1 :'b -> 'c).
        (sum_CASE (INR y :'a + 'b) f f1 :'c) = f1 y
   |- !(x :'a). OUTL (INL x :'a + 'b) = x
   |- !(x :'a + 'b). ISR x ==> ((INR (OUTR x) :'a + 'b) = x)
   |- !(x :'a + 'b). ISL x ==> ((INL (OUTL x) :'a + 'b) = x)
   |- !(x :'b). OUTR (INR x :'a + 'b) = x
   |- (!(x :'a). ISL (INL x :'a + 'b)) /\
      !(y :'b). ~ISL (INR y :'a + 'b)
   |- (!(x :'b). ISR (INR x :'a + 'b)) /\
      !(y :'a). ~ISR (INL y :'a + 'b)
   |- !(x :'a) (y :'b). (INL x :'a + 'b) <> (INR y :'a + 'b)

Simplification set: COMBIN
Rewrite rules:
   |- !(x :'a). I x = x
   |- !(f :'a -> 'b). ((I :'b -> 'b) o f = f) /\ (f o (I :'a -> 'a) = f)
   |- !(x :'a) (y :'b). K x y = x
   |- !(f :'a -> 'b -> 'c) (g :'a -> 'b) (x :'a). S f g x = f x (g x)
   |- !(f :'a -> 'b) (g :'c -> 'a) (h :'d -> 'c).
        (f o g) o h = f o g o h
   |- !(f :'a -> 'b) (g :'c -> 'a) (x :'c). (f o g) x = f (g x)
   |- !(f :'a -> 'a -> 'b) (x :'a). W f x = f x x
   |- !(f :'a -> 'b -> 'c) (x :'b) (y :'a). combin$C f x y = f y x
   |- (!(f :'a -> 'b) (v :'c). (K v :'b -> 'c) o f = (K v :'a -> 'c)) /\
      !(f :'d -> 'e) (v :'d). f o (K v :'f -> 'd) = (K (f v) :'f -> 'e)

Simplification set: ARITH_RWTS
Rewrite rules:
   |- !(x :num).
        ((SUC x = (1 :num)) <=> (x = (0 :num))) /\
        (((1 :num) = SUC x) <=> (x = (0 :num)))
   |- !(x :num).
        ((SUC x = (2 :num)) <=> (x = (1 :num))) /\
        (((2 :num) = SUC x) <=> (x = (1 :num)))
   |- !(m :num). m + (0 :num) = m
   |- !(m :num). (0 :num) + m = m
   |- !(m :num) (n :num).
        (m + n = (0 :num)) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m + n) <=> (m = (0 :num)) /\ (n = (0 :num))
   |- !(m :num) (n :num). (m + n = m) <=> (n = (0 :num))
   |- !(m :num) (n :num). (n + m = m) <=> (n = (0 :num))
   |- !(m :num) (n :num).
        (m * n = (0 :num)) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(m :num) (n :num).
        ((0 :num) = m * n) <=> (m = (0 :num)) \/ (n = (0 :num))
   |- !(x :num) (y :num).
        (x * y = (1 :num)) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(x :num) (y :num).
        ((1 :num) = x * y) <=> (x = (1 :num)) /\ (y = (1 :num))
   |- !(m :num). m * (0 :num) = (0 :num)
   |- !(m :num). (0 :num) * m = (0 :num)
   |- !(x :num) (y :num).
        (x * y = SUC (0 :num)) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(x :num) (y :num).
        (SUC (0 :num) = x * y) <=>
        (x = SUC (0 :num)) /\ (y = SUC (0 :num))
   |- !(m :num). m * (1 :num) = m
   |- !(m :num). (1 :num) * m = m
   |- !(c :num). c - c = (0 :num)
   |- !(m :num). SUC m - (1 :num) = m
   |- !(m :num). ((0 :num) - m = (0 :num)) /\ (m - (0 :num) = m)
   |- !(a :num) (c :num). a + c - c = a
   |- !(a :num) (c :num). c + a - c = a
   |- !(m :num) (n :num). (m - n = (0 :num)) <=> m <= n
   |- !(m :num) (n :num). ((0 :num) = m - n) <=> m <= n
   |- !(n :num) (m :num). n - m <= n
   |- !(n :num) (m :num). SUC n - SUC m = n - m
   |- !(m :num) (n :num) (p :num). m - n > p <=> m > n + p
   |- !(m :num) (n :num) (p :num).
        m - n < p <=> m < n + p /\ (0 :num) < p
   |- !(m :num) (n :num) (p :num).
        m - n >= p <=> m >= n + p \/ (0 :num) >= p
   |- !(m :num) (n :num) (p :num). m - n <= p <=> m <= n + p
   |- (PRE (0 :num) = (0 :num)) /\ !(m :num). PRE (SUC m) = m
   |- !(n :num) (m :num).
        (n ** m = (0 :num)) <=> (n = (0 :num)) /\ (0 :num) < m
   |- !(n :num). ((1 :num) ** n = (1 :num)) /\ (n ** (1 :num) = n)
   |- !(n :num) (m :num).
        (n ** m = (1 :num)) <=> (n = (1 :num)) \/ (m = (0 :num))
   |- (0 :num) < (x :num) ** (y :num) <=> (0 :num) < x \/ (y = (0 :num))
   |- !(b1 :num) (b2 :num) (x :num).
        (b1 ** x = b2 ** x) <=> (x = (0 :num)) \/ (b1 = b2)
   |- !(b :num).
        (1 :num) < b ==>
        !(n :num) (m :num). (b ** n = b ** m) <=> (n = m)
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m < b ** n <=> m < n
   |- !(b :num).
        (1 :num) < b ==> !(n :num) (m :num). b ** m <= b ** n <=> m <= n
   |- !(a :num) (b :num).
        a ** (n :num) < b ** n <=> a < b /\ (0 :num) < n
   |- !(a :num) (b :num).
        a ** (n :num) <= b ** n <=> a <= b \/ (n = (0 :num))
   |- !(n :num). n <= (0 :num) <=> (n = (0 :num))
   |- !(n :num). (0 :num) < SUC n
   |- !(m :num) (n :num). m <= m + n
   |- (0 :num) <= (x :num)
   |- SUC (x :num) > (0 :num)
   |- (x :num) >= (0 :num)
   |- (x :num) < SUC x
   |- (x :num) <= SUC x
   |- (x :num) < x + (c :num) <=> (0 :num) < c
   |- (x :num) < (c :num) + x <=> (0 :num) < c
   |- (x :num) <= x + (c :num) <=> (0 :num) <= c
   |- (x :num) <= (c :num) + x <=> (0 :num) <= c
   |- !(m :num). m <= m
   |- (x :num) >= x
   |- !(m :num) (n :num) (p :num). m + p < n + p <=> m < n
   |- !(m :num) (n :num) (p :num). p + m < p + n <=> m < n
   |- !(m :num) (n :num) (p :num). m + n <= m + p <=> n <= p
   |- !(m :num) (n :num) (p :num). n + m <= p + m <=> n <= p
   |- !(m :num) (n :num) (p :num). (m + p = n + p) <=> (m = n)
   |- !(m :num) (n :num) (p :num). (p + m = p + n) <=> (m = n)
   |- (x :num) + (y :num) < (w :num) + x <=> y < w
   |- (y :num) + (x :num) < x + (w :num) <=> y < w
   |- !(m :num) (n :num). (SUC m = SUC n) <=> (m = n)
   |- !(m :num) (n :num). SUC m < SUC n <=> m < n
   |- !(n :num) (m :num). SUC n <= SUC m <=> n <= m
   |- !(m :num) (i :num) (n :num). SUC n * m < SUC n * i <=> m < i
   |- !(p :num) (m :num) (n :num). (n * SUC p = m * SUC p) <=> (n = m)
   |- !(m :num) (i :num) (n :num). (SUC n * m = SUC n * i) <=> (m = i)
   |- !(n :num) (m :num). ~(SUC n <= m) <=> m <= n
   |- !(p :num) (q :num) (n :num) (m :num).
        (n * SUC q ** p = m * SUC q ** p) <=> (n = m)
   |- !(m :num) (n :num) (p :num).
        m * n <= m * p <=> (m = (0 :num)) \/ n <= p
   |- !(m :num) (n :num) (p :num).
        m * n <= p * n <=> (n = (0 :num)) \/ m <= p
   |- !(m :num) (n :num) (p :num).
        m * n < m * p <=> (0 :num) < m /\ n < p
   |- !(m :num) (n :num) (p :num).
        m * n < p * n <=> (0 :num) < n /\ m < p
   |- ((m :num) < m * (n :num) <=> (0 :num) < m /\ (1 :num) < n) /\
      (m < n * m <=> (0 :num) < m /\ (1 :num) < n)
   |- ((m :num) * (n :num) < m <=> (0 :num) < m /\ (n = (0 :num))) /\
      (m * n < n <=> (0 :num) < n /\ (m = (0 :num)))
   |- ((m :num) <= m * (n :num) <=> (m = (0 :num)) \/ (0 :num) < n) /\
      (m <= n * m <=> (m = (0 :num)) \/ (0 :num) < n)
   |- ((m :num) * (n :num) <= m <=> (m = (0 :num)) \/ n <= (1 :num)) /\
      (m * n <= n <=> (n = (0 :num)) \/ m <= (1 :num))
   |- !(m :num) (n :num). SUC n ** m <> (0 :num)
   |- !(n :num) (m :num). SUC (n + n) <> m + m
   |- !(m :num) (n :num). ~(SUC (m + n) <= m)
   |- !(n :num). ~(SUC n <= (0 :num))
   |- !(n :num). ~(n < (0 :num))
   |- !(n :num). ~(n < n)
   |- ~((x :num) > x)
   |- !(n :num).
        (MIN n (0 :num) = (0 :num)) /\ (MIN (0 :num) n = (0 :num))
   |- !(n :num). (MAX n (0 :num) = n) /\ (MAX (0 :num) n = n)
   |- !(n :num). MIN n n = n
   |- !(n :num). MAX n n = n
   |- !(n :num) (m :num) (p :num).
        (MIN m n <= p <=> m <= p \/ n <= p) /\
        (p <= MIN m n <=> p <= m /\ p <= n)
   |- !(n :num) (m :num) (p :num).
        (p <= MAX m n <=> p <= m \/ p <= n) /\
        (MAX m n <= p <=> m <= p /\ n <= p)
   |- !(n :num) (m :num) (p :num).
        (MIN m n < p <=> m < p \/ n < p) /\
        (p < MIN m n <=> p < m /\ p < n)
   |- !(n :num) (m :num) (p :num).
        (p < MAX m n <=> p < m \/ p < n) /\
        (MAX m n < p <=> m < p /\ n < p)
   |- !(m :num) (n :num). (MIN m n = MAX m n) <=> (m = n)
   |- !(m :num) (n :num). MIN m n < MAX m n <=> m <> n
   |- !(x :num) (y :num). (0 :num) < y ==> ((x MOD y = x) <=> x < y)
   |- !(n :num).
        (0 :num) < n ==> (n DIV n = (1 :num)) /\ (n MOD n = (0 :num))
   |- !(q :num). q DIV (1 :num) = q
   |- !(k :num). k MOD (1 :num) = (0 :num)
   |- !(n :num) (k :num). k < n ==> (k MOD n = k)
   |- !(n :num). (0 :num) < n ==> ((0 :num) MOD n = (0 :num))
   |- !(n :num). (0 :num) < n ==> !(k :num). k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 (x :num)) * (y :num) = NUMERAL (z :num)) <=>
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) /\
       (NUMERAL z MOD NUMERAL (BIT1 x) = (0 :num))) /\
      ((NUMERAL (BIT2 x) * y = NUMERAL z) <=>
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) /\
       (NUMERAL z MOD NUMERAL (BIT2 x) = (0 :num)))
   |- !(m :num) (n :num). (0 :num) < n ==> m MOD n < n
   |- !(n :num) (d :num). (0 :num) < n /\ (1 :num) < d ==> n DIV d < n

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER
:
   simpset
val stdprinters = SOME (fn, fn):
   ((term -> string) * (hol_type -> string)) option
val store_attribute = fn: {attribute: string, thm_name: string} -> unit
val store_definition = fn: string * thm -> thm
val store_thm = fn: string * term * tactic -> thm
val str_all = fn: (char -> bool) -> string -> bool
val strcat = fn: string -> string -> string
val string_to_int = fn: string -> int
val strip_abs = fn: term -> term list * term
val strip_assume_tac = fn: thm_tactic
val strip_binder = fn: term option -> term -> term list * term
val strip_binop = fn: ('a -> ('a * 'a) option) -> 'a -> 'a list
val strip_comb = fn: term -> term * term list
val strip_conj = fn: term -> term list
val strip_disj = fn: term -> term list
val strip_exists = fn: term -> term list * term
val strip_forall = fn: term -> term list * term
val strip_fun = fn: hol_type -> hol_type list * hol_type
val strip_gen_left = fn: ('a -> 'b * 'a) -> 'a -> 'b list * 'a
val strip_gen_left_opt = fn: ('a -> ('b * 'a) option) -> 'a -> 'b list * 'a
val strip_gen_right = fn: ('a -> 'a * 'b) -> 'a -> 'a * 'b list
val strip_gen_right_opt = fn: ('a -> ('a * 'b) option) -> 'a -> 'a * 'b list
val strip_imp = fn: term -> term list * term
val strip_imp_only = fn: term -> term list * term
val strip_neg = fn: term -> term * int
val strip_res_exists = fn: term -> (term * term) list * term
val strip_res_forall = fn: term -> (term * term) list * term
val strip_tac = fn: tactic
val subgoal = fn: term quotation -> tactic
type ('a, 'b) subst = ('a, 'b) Lib.subst
val subst = fn: (term, term) Term.subst -> term -> term
val subst_assoc = fn: ('a -> bool) -> ('a, 'b) Lib.subst -> 'b option
val subst_occs = fn:
   int list list -> {redex: term, residue: term} list -> term -> term
val subtract = fn: ''a list -> ''a list -> ''a list
val suff_tac = fn: term -> tactic
val suffices_by = fn: term quotation * tactic -> tactic
val swap = fn: 'a * 'b -> 'b * 'a
val syntax_fns = fn:
   {dest: term -> exn -> term -> 'a, make: term -> 'b -> term, n: int} ->
     string -> string -> term * ('b -> term) * (term -> 'a) * (term -> bool)
val syntax_fns1 = fn:
   string ->
     string -> term * (term -> term) * (term -> term) * (term -> bool)
val syntax_fns2 = fn:
   string ->
     string ->
       term * (term * term -> term) * (term -> term * term) * (term -> bool)
val syntax_fns3 = fn:
   string ->
     string ->
       term * (term * term * term -> term) * (term -> term * term * term) *
       (term -> bool)
val syntax_fns4 = fn:
   string ->
     string ->
       term * (term * term * term * term -> term) *
       (term -> term * term * term * term) * (term -> bool)
val tDefine = fn: string -> term quotation -> tactic -> thm
type tactic = goal -> goal list * validation
type tag
val tag = fn: thm -> tag
val temp_TeX_notation = fn: {TeX: string * int, hol: string} -> unit
val temp_add_absyn_postprocessor = fn:
   string * term_grammar.absyn_postprocessor -> unit
val temp_add_bare_numeral_form = fn: char * string option -> unit
val temp_add_infix = fn: string * int * associativity -> unit
val temp_add_infix_type = fn:
   {Assoc: associativity, Name: string, ParseName: string option, Prec: int}
     -> unit
val temp_add_listform = fn:
   {block_info: block_info,
     cons: string,
     leftdelim: pp_element list,
     nilstr: string, rightdelim: pp_element list, separator: pp_element list}
     -> unit
val temp_add_numeral_form = fn: char * string option -> unit
val temp_add_preterm_processor = fn:
   string * int -> term_grammar.preterm_processor -> unit
val temp_add_qtype = fn: {Name: string, Thy: string} -> unit
val temp_add_record_field = fn: string * term -> unit
val temp_add_record_fupdate = fn: string * term -> unit
val temp_add_rule = fn:
   {block_style: PhraseBlockStyle * block_info,
     fixity: fixity,
     paren_style: ParenStyle, pp_elements: pp_element list, term_name: string}
     -> unit
val temp_add_type = fn: string -> unit
val temp_add_user_printer = fn:
   string * term * term_grammar.userprinter -> unit
val temp_associate_restriction = fn: string * string -> unit
val temp_binding = fn: string -> string
val temp_bring_to_front_overload = fn:
   string -> {Name: string, Thy: string} -> unit
val temp_clear_overloads_on = fn: string -> unit
val temp_disable_tyabbrev_printing = fn: string -> unit
val temp_gen_remove_ovl_mapping = fn: string -> term -> unit
val temp_give_num_priority = fn: char -> unit
val temp_inferior_overload_on = fn: string * term -> unit
val temp_loose_equality = fn: unit -> unit
val temp_overload_on = fn: string * term -> unit
val temp_overload_on_by_nametype = fn:
   string -> {Name: string, Thy: string} -> unit
val temp_prefer_form_with_tok = fn: {term_name: string, tok: string} -> unit
val temp_remove_absyn_postprocessor = fn:
   string -> term_grammar.absyn_postprocessor option
val temp_remove_numeral_form = fn: char -> unit
val temp_remove_ovl_mapping = fn:
   string -> {Name: string, Thy: string} -> unit
val temp_remove_preterm_processor = fn:
   string * int -> term_grammar.preterm_processor option
val temp_remove_rules_for_term = fn: string -> unit
val temp_remove_termtok = fn: {term_name: string, tok: string} -> unit
val temp_remove_type_abbrev = fn: string -> unit
val temp_remove_user_printer = fn:
   string -> (term * term_grammar.userprinter) option
val temp_send_to_back_overload = fn:
   string -> {Name: string, Thy: string} -> unit
val temp_set_associativity = fn: int * associativity -> unit
val temp_set_fixity = fn: string -> fixity -> unit
val temp_set_grammars = fn:
   type_grammar.grammar * term_grammar.grammar -> unit
val temp_set_mapped_fixity = fn:
   {fixity: fixity, term_name: string, tok: string} -> unit
val temp_thytype_abbrev = fn: KernelSig.kernelname * hol_type -> unit
val temp_tight_equality = fn: unit -> unit
val temp_type_abbrev = fn: string * hol_type -> unit
eqtype term
val term_diff = fn: term -> term -> (pel list * term * term) list
val term_eq = fn: term -> term -> bool
val term_grammar = fn: unit -> term_grammar.grammar
val term_pp_prefix = ref "``": string ref
val term_pp_suffix = ref "``": string ref
val term_pp_with_delimiters = fn:
   (ppstream -> term -> unit) -> ppstream -> term -> unit
val term_size = fn: term -> int
val term_to_string = fn: term -> string
val the_map = fn: unit -> (string, string * int) Binarymap.dict
val the_value =
   ``((:'a) :'a itself)``:
   term
val theorem = fn: string -> thm
val theorems = fn: string -> (string * thm) list
type theory
val theory_data = fn: {settype: string, thy: string} -> (string * thm) list
type thm
val thm_frees = fn: thm -> term list
type thm_tactic = thm -> tactic
type thm_tactical = thm_tactic -> thm_tactic
val thm_to_string = fn: thm -> string
val thms = fn: string -> (string * thm) list
val thy = fn: string -> DB.data list
type thy_addon =
   {sig_ps: (ppstream -> unit) option, struct_ps: (ppstream -> unit) option}
val thy_consts = fn: string -> term list
val thy_types = fn: string -> (string * int) list
val thytype_abbrev = fn: KernelSig.kernelname * hol_type -> unit
val tight_equality = fn: unit -> unit
val time = fn: ('a -> 'b) -> 'a -> 'b
val time_to_string = fn: Time.time -> string
val topsort = fn: ('a -> 'a -> bool) -> 'a list -> 'a list
val total = fn: ('a -> 'b) -> 'a -> 'b option
val trace = fn: string * int -> ('a -> 'b) -> 'a -> 'b
val traces = fn:
   unit ->
     {aliases: string list,
       default: int, max: int, name: string, trace_level: int} list
val triple = fn: 'a -> 'b -> 'c -> 'a * 'b * 'c
val triple_of_list = fn: 'a list -> 'a * 'a * 'a
val try = fn: ('a -> 'b) -> 'a -> 'b
val try_grammar_extension = fn: ('a -> 'b) -> 'a -> 'b
val try_theory_extension = fn: ('a -> 'b) -> 'a -> 'b
val trye = fn: ('a -> 'b) -> 'a -> 'b
val tryfind = fn: ('a -> 'b) -> 'a list -> 'b
val trypluck = fn: ('a -> 'b) -> 'a list -> 'b * 'a list
val trypluck' = fn: ('a -> 'b option) -> 'a list -> 'b option * 'a list
val ty_antiq = fn: hol_type -> term
val ty_sub = fn: (hol_type, hol_type) Lib.subst -> hol_type -> hol_type delta
val type_abbrev = fn: string * hol_type -> unit
val type_constructors = fn: thm -> string -> term list
val type_constructors_with_args = fn: thm -> string -> term list
val type_grammar = fn: unit -> type_grammar.grammar
val type_of = fn: term -> hol_type
val type_pp_prefix = ref "``": string ref
val type_pp_suffix = ref "``": string ref
val type_pp_with_delimiters = fn:
   (ppstream -> hol_type -> unit) -> ppstream -> hol_type -> unit
val type_rws = fn: hol_type -> thm list
val type_size = fn: hol_type -> int
val type_subst = fn: (hol_type, hol_type) Lib.subst -> hol_type -> hol_type
val type_to_string = fn: hol_type -> string
val type_var_in = fn: hol_type -> hol_type -> bool
val type_vars = fn: hol_type -> hol_type list
val type_vars_in_term = fn: term -> hol_type list
val type_varsl = fn: hol_type list -> hol_type list
val typedTerm = fn: term frag list -> hol_type -> term
val typed_parse_in_context = fn:
   hol_type -> term list -> term frag list -> term
val types = fn: string -> (string * int) list
val unabbrev_all_tac = fn: tactic
val uncurry = fn: ('a -> 'b -> 'c) -> 'a * 'b -> 'c
val union = fn: ''a list -> ''a list -> ''a list
val universal =
   ``($! :('a -> bool) -> bool)``:
   term
val unprefix = fn: string -> string -> string
val unprime = fn: string -> string
val unzip = fn: ('a * 'b) list -> 'a list * 'b list
val update_overload_maps = fn:
   string ->
     {Name: string, Thy: string} list * {Name: string, Thy: string} list ->
       unit
val upto = fn: int -> int -> int list
val uptodate_term = fn: term -> bool
val uptodate_thm = fn: thm -> bool
val uptodate_type = fn: hol_type -> bool
type validation = thm list -> thm
val var_compare = fn: term * term -> order
val var_occurs = fn: term -> term -> bool
val variant = fn: term list -> term -> term
val variant_of_term = fn:
   term list -> term -> term * {redex: term, residue: term} list
val vector_topsort = fn: int list vector -> int list
datatype ('a, 'b) verdict = FAIL of 'b | PASS of 'a
val verdict = fn: ('a -> 'b) -> ('a -> 'c) -> 'a -> ('b, 'c * exn) verdict
val version = 11: int
val via = fn: term * tactic -> tactic
val with_exn = fn: ('a -> 'b) -> 'a -> exn -> 'b
val with_flag = fn: 'a ref * 'a -> ('b -> 'c) -> 'b -> 'c
val words2 = fn: string -> string -> string list
val wrap_exn = fn: string -> string -> exn -> exn
val wrap_exn_loc = fn: string -> string -> locn.locn -> exn -> exn
val write_raw = fn: (term -> int) -> term -> string
val xDefine = fn: string -> term quotation -> thm
val xHol_coreln = fn: string -> term quotation -> thm * thm * thm
val xHol_reln = fn: string -> term quotation -> thm * thm * thm
val zDefine = fn: term quotation -> thm
val zip = fn: 'a list -> 'b list -> ('a * 'b) list
val |-> = fn: 'a * 'b -> {redex: 'a, residue: 'b}
val |> = fn: 'a * ('a -> 'b) -> 'b
> # val CHAR_EQ_THM =
   |- !(c1 :char) (c2 :char). (c1 = c2) <=> (ORD c1 = ORD c2):
   thm
val CHAR_INDUCT_THM =
   |- !(P :char -> bool).
     (!(n :num). n < (256 :num) ==> P (CHR n)) ==> !(c :char). P c:
   thm
val CHR_11 =
   |- !(r :num) (r' :num).
     r < (256 :num) ==>
     r' < (256 :num) ==>
     ((CHR r = CHR r') <=> (r = r')):
   thm
val CHR_ONTO =
   |- !(a :char). ?(r :num). (a = CHR r) /\ r < (256 :num):
   thm
val CHR_ORD =
   |- !(a :char). CHR (ORD a) = a:
   thm
val DEST_STRING_LEMS =
   |- !(s :string).
     ((DEST_STRING s = (NONE :(char # string) option)) <=>
      (s = ("" :string))) /\
     ((DEST_STRING s = SOME ((c :char),(t :string))) <=>
      (s = STRING c t)):
   thm
val DEST_STRING_def =
   |- (DEST_STRING ("" :string) = (NONE :(char # string) option)) /\
   !(c :char) (rst :string). DEST_STRING (STRING c rst) = SOME (c,rst):
   thm
val EXISTS_OPTION =
   |- (?(opt :'a option). (P :'a option -> bool) opt) <=>
   P (NONE :'a option) \/ ?(x :'a). P (SOME x):
   thm
val EXPLODE_11 =
   |- (EXPLODE (s1 :string) = EXPLODE (s2 :string)) <=> (s1 = s2):
   thm
val EXPLODE_DEST_STRING =
   |- !(s :string).
     EXPLODE s =
     case DEST_STRING s of
       (NONE :(char # string) option) => ("" :string)
     | SOME (c,t) => STRING c (EXPLODE t):
   thm
val EXPLODE_EQNS =
   |- (EXPLODE ("" :string) = ("" :string)) /\
   !(c :char) (s :string). EXPLODE (STRING c s) = STRING c (EXPLODE s):
   thm
val EXPLODE_EQ_NIL =
   |- ((EXPLODE (s :string) = ("" :string)) <=> (s = ("" :string))) /\
   ((("" :string) = EXPLODE s) <=> (s = ("" :string))):
   thm
val EXPLODE_EQ_THM =
   |- !(s :string) (h :char) (t :string).
     ((STRING h t = EXPLODE s) <=> (s = STRING h (IMPLODE t))) /\
     ((EXPLODE s = STRING h t) <=> (s = STRING h (IMPLODE t))):
   thm
val EXPLODE_IMPLODE =
   |- EXPLODE (IMPLODE (cs :string)) = cs:
   thm
val EXPLODE_ONTO =
   |- !(cs :string). ?(s :string). cs = EXPLODE s:
   thm
val EXPLODE_def =
   |- (EXPLODE ("" :string) = ("" :string)) /\
   !(c :char) (s :string). EXPLODE (STRING c s) = STRING c (EXPLODE s):
   thm
val EXTRACT_def =
   |- (EXTRACT ((s :string),(i :num),(NONE :num option)) =
    SUBSTRING (s,i,STRLEN s - i)) /\
   (EXTRACT (s,i,SOME (n :num)) = SUBSTRING (s,i,n)):
   thm
val EXTRACT_ind =
   |- !(P :string # num # num option -> bool).
     (!(s :string) (i :num). P (s,i,(NONE :num option))) /\
     (!(s :string) (i :num) (n :num). P (s,i,SOME n)) ==>
     !(v :string) (v1 :num) (v2 :num option). P (v,v1,v2):
   thm
val EXTRACT_primitive_def =
   |- EXTRACT =
   WFREC
     (@(R :
         string # num # num option ->
         string # num # num option -> bool). WF R)
     (\(EXTRACT :string # num # num option -> string)
         (a :string # num # num option).
        case a of
          (s,i,(NONE :num option)) => I (SUBSTRING (s,i,STRLEN s - i))
        | (s,i,SOME n) => I (SUBSTRING (s,i,n))):
   thm
val FIELDS_def =
   |- (!(P :char -> bool). FIELDS P ("" :string) = [("" :string)]) /\
   !(t :string) (h :char) (P :char -> bool).
     FIELDS P (STRING h t) =
     (let
        ((l :string),(r :string)) = SPLITP P (STRING h t)
      in
        if NULL l then ("" :string)::FIELDS P (TL r)
        else if NULL r then [l]
        else l::FIELDS P (TL r)):
   thm
val FIELDS_ind =
   |- !(P' :(char -> bool) -> string -> bool).
     (!(P :char -> bool). P' P ("" :string)) /\
     (!(P :char -> bool) (h :char) (t :string).
        (!(l :string) (r :string).
           ((l,r) = SPLITP P (STRING h t)) /\ NULL l ==> P' P (TL r)) /\
        (!(l :string) (r :string).
           ((l,r) = SPLITP P (STRING h t)) /\ ~NULL l /\ ~NULL r ==>
           P' P (TL r)) ==>
        P' P (STRING h t)) ==>
     !(v :char -> bool) (v1 :string). P' v v1:
   thm
val FORALL_OPTION =
   |- (!(opt :'a option). (P :'a option -> bool) opt) <=>
   P (NONE :'a option) /\ !(x :'a). P (SOME x):
   thm
val IF_EQUALS_OPTION =
   |- (((if (P :bool) then SOME (x :'a) else (NONE :'a option)) =
     (NONE :'a option)) <=> ~P) /\
   (((if P then (NONE :'a option) else SOME x) = (NONE :'a option)) <=>
    P) /\
   (((if P then SOME x else (NONE :'a option)) = SOME (y :'a)) <=>
    P /\ (x = y)) /\
   (((if P then (NONE :'a option) else SOME x) = SOME y) <=>
    ~P /\ (x = y)):
   thm
val IF_NONE_EQUALS_OPTION =
   |- (((if (P :bool) then (X :'a option) else (NONE :'a option)) =
     (NONE :'a option)) <=> P ==> IS_NONE X) /\
   (((if P then (NONE :'a option) else X) = (NONE :'a option)) <=>
    IS_SOME X ==> P) /\
   (((if P then X else (NONE :'a option)) = SOME (x :'a)) <=>
    P /\ (X = SOME x)) /\
   (((if P then (NONE :'a option) else X) = SOME x) <=>
    ~P /\ (X = SOME x)):
   thm
val IMPLODE_11 =
   |- (IMPLODE (cs1 :string) = IMPLODE (cs2 :string)) <=> (cs1 = cs2):
   thm
val IMPLODE_EQNS =
   |- (IMPLODE ("" :string) = ("" :string)) /\
   !(c :char) (cs :string).
     IMPLODE (STRING c cs) = STRING c (IMPLODE cs):
   thm
val IMPLODE_EQ_EMPTYSTRING =
   |- ((IMPLODE (l :string) = ("" :string)) <=> (l = ("" :string))) /\
   ((("" :string) = IMPLODE l) <=> (l = ("" :string))):
   thm
val IMPLODE_EQ_THM =
   |- !(c :char) (s :string) (l :string).
     ((STRING c s = IMPLODE l) <=> (l = STRING c (EXPLODE s))) /\
     ((IMPLODE l = STRING c s) <=> (l = STRING c (EXPLODE s))):
   thm
val IMPLODE_EXPLODE =
   |- IMPLODE (EXPLODE (s :string)) = s:
   thm
val IMPLODE_EXPLODE_I =
   |- (EXPLODE (s :string) = s) /\ (IMPLODE s = s):
   thm
val IMPLODE_ONTO =
   |- !(s :string). ?(cs :string). s = IMPLODE cs:
   thm
val IMPLODE_STRING =
   |- !(clist :string).
     IMPLODE clist =
     FOLDR (STRING :char -> string -> string) ("" :string) clist:
   thm
val IMPLODE_def =
   |- (IMPLODE ("" :string) = ("" :string)) /\
   !(c :char) (cs :string).
     IMPLODE (STRING c cs) = STRING c (IMPLODE cs):
   thm
val IS_NONE_DEF =
   |- (!(x :'a). IS_NONE (SOME x) <=> F) /\
   (IS_NONE (NONE :'a option) <=> T):
   thm
val IS_NONE_EQ_NONE =
   |- !(x :'a option). IS_NONE x <=> (x = (NONE :'a option)):
   thm
val IS_SOME_BIND =
   |- IS_SOME (OPTION_BIND (x :'a option) (g :'a -> 'b option)) ==>
   IS_SOME x:
   thm
val IS_SOME_DEF =
   |- (!(x :'a). IS_SOME (SOME x) <=> T) /\
   (IS_SOME (NONE :'a option) <=> F):
   thm
val IS_SOME_EXISTS =
   |- !(opt :'a option). IS_SOME opt <=> ?(x :'a). opt = SOME x:
   thm
val IS_SOME_MAP =
   |- IS_SOME (OPTION_MAP (f :'a -> 'b) (x :'a option)) <=> IS_SOME x:
   thm
val NONE_DEF =
   |- (NONE :'a option) = option_ABS (INR () :'a + unit):
   thm
val NOT_IS_SOME_EQ_NONE =
   |- !(x :'a option). ~IS_SOME x <=> (x = (NONE :'a option)):
   thm
val NOT_NONE_SOME =
   |- !(x :'a). (NONE :'a option) <> SOME x:
   thm
val NOT_SOME_NONE =
   |- !(x :'a). SOME x <> (NONE :'a option):
   thm
val OPTION_ALL_CONG =
   |- !(opt :'a option) (opt' :'a option) (P :'a -> bool) (P' :'a -> bool).
     (opt = opt') /\ (!(x :'a). (opt' = SOME x) ==> (P x <=> P' x)) ==>
     (OPTION_ALL P opt <=> OPTION_ALL P' opt'):
   thm
val OPTION_ALL_MONO =
   |- (!(x :'a). (P :'a -> bool) x ==> (P' :'a -> bool) x) ==>
   OPTION_ALL P (opt :'a option) ==>
   OPTION_ALL P' opt:
   thm
val OPTION_ALL_def =
   |- (!(P :'a -> bool). OPTION_ALL P (NONE :'a option) <=> T) /\
   !(P :'a -> bool) (x :'a). OPTION_ALL P (SOME x) <=> P x:
   thm
val OPTION_APPLY_MAP2 =
   |- ((OPTION_MAP (f :'a -> 'b -> 'c) (x :'a option) <*> (y :'b option))
      :'c option) =
   OPTION_MAP2 f x y:
   thm
val OPTION_APPLY_def =
   |- (!(x :'b option).
      (((NONE :('b -> 'a) option) <*> x) :'a option) =
      (NONE :'a option)) /\
   !(f :'b -> 'a) (x :'b option).
     ((SOME f <*> x) :'a option) = OPTION_MAP f x:
   thm
val OPTION_APPLY_o =
   |- ((((((SOME ($o :('b -> 'c) -> ('a -> 'b) -> 'a -> 'c) <*>
        (f :('b -> 'c) option))
          :(('a -> 'b) -> 'a -> 'c) option) <*>
      (g :('a -> 'b) option))
        :('a -> 'c) option) <*> (x :'a option))
      :'c option) =
   ((f <*> ((g <*> x) :'b option)) :'c option):
   thm
val OPTION_BIND_EQUALS_OPTION =
   |- ((OPTION_BIND (p :'a option) (f :'a -> 'b option) =
     (NONE :'b option)) <=>
    (p = (NONE :'a option)) \/
    ?(x :'a). (p = SOME x) /\ (f x = (NONE :'b option))) /\
   ((OPTION_BIND p f = SOME (y :'b)) <=>
    ?(x :'a). (p = SOME x) /\ (f x = SOME y)):
   thm
val OPTION_BIND_cong =
   |- !(o1 :'a option) (o2 :'a option) (f1 :'a -> 'b option)
      (f2 :'a -> 'b option).
     (o1 = o2) /\ (!(x :'a). (o2 = SOME x) ==> (f1 x = f2 x)) ==>
     (OPTION_BIND o1 f1 = OPTION_BIND o2 f2):
   thm
val OPTION_BIND_def =
   |- (!(f :'b -> 'a option).
      OPTION_BIND (NONE :'b option) f = (NONE :'a option)) /\
   !(x :'b) (f :'b -> 'a option). OPTION_BIND (SOME x) f = f x:
   thm
val OPTION_CHOICE_EQ_NONE =
   |- (OPTION_CHOICE (m1 :'a option) (m2 :'a option) =
    (NONE :'a option)) <=>
   (m1 = (NONE :'a option)) /\ (m2 = (NONE :'a option)):
   thm
val OPTION_CHOICE_NONE =
   |- OPTION_CHOICE (m1 :'a option) (NONE :'a option) = m1:
   thm
val OPTION_CHOICE_def =
   |- (!(m2 :'a option). OPTION_CHOICE (NONE :'a option) m2 = m2) /\
   !(x :'a) (m2 :'a option). OPTION_CHOICE (SOME x) m2 = SOME x:
   thm
val OPTION_GUARD_COND =
   |- OPTION_GUARD (b :bool) = if b then SOME () else (NONE :unit option):
   thm
val OPTION_GUARD_EQ_THM =
   |- ((OPTION_GUARD (b :bool) = SOME ()) <=> b) /\
   ((OPTION_GUARD b = (NONE :unit option)) <=> ~b):
   thm
val OPTION_GUARD_def =
   |- (OPTION_GUARD T = SOME ()) /\ (OPTION_GUARD F = (NONE :unit option)):
   thm
val OPTION_IGNORE_BIND_EQUALS_OPTION =
   |- ((OPTION_IGNORE_BIND (m1 :'a option) (m2 :'b option) =
     (NONE :'b option)) <=>
    (m1 = (NONE :'a option)) \/ (m2 = (NONE :'b option))) /\
   ((OPTION_IGNORE_BIND m1 m2 = SOME (y :'b)) <=>
    ?(x :'a). (m1 = SOME x) /\ (m2 = SOME y)):
   thm
val OPTION_IGNORE_BIND_def =
   |- !(m1 :'b option) (m2 :'a option).
     OPTION_IGNORE_BIND m1 m2 = OPTION_BIND m1 (K m2 :'b -> 'a option):
   thm
val OPTION_IGNORE_BIND_thm =
   |- (OPTION_IGNORE_BIND (NONE :'b option) (m :'a option) =
    (NONE :'a option)) /\ (OPTION_IGNORE_BIND (SOME (v :'c)) m = m):
   thm
val OPTION_JOIN_DEF =
   |- (OPTION_JOIN (NONE :'a option option) = (NONE :'a option)) /\
   !(x :'a option). OPTION_JOIN (SOME x) = x:
   thm
val OPTION_JOIN_EQ_SOME =
   |- !(x :'a option option) (y :'a).
     (OPTION_JOIN x = SOME y) <=> (x = SOME (SOME y)):
   thm
val OPTION_MAP2_DEF =
   |- !(f :'b -> 'c -> 'a) (x :'b option) (y :'c option).
     OPTION_MAP2 f x y =
     if IS_SOME x /\ IS_SOME y then SOME (f (THE x) (THE y))
     else (NONE :'a option):
   thm
val OPTION_MAP2_NONE =
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
    (NONE :'c option)) <=>
   (o1 = (NONE :'a option)) \/ (o2 = (NONE :'b option)):
   thm
val OPTION_MAP2_SOME =
   |- (OPTION_MAP2 (f :'a -> 'b -> 'c) (o1 :'a option) (o2 :'b option) =
    SOME (v :'c)) <=>
   ?(x1 :'a) (x2 :'b). (o1 = SOME x1) /\ (o2 = SOME x2) /\ (v = f x1 x2):
   thm
val OPTION_MAP2_THM =
   |- (OPTION_MAP2 (f :'b -> 'c -> 'a) (SOME (x :'b)) (SOME (y :'c)) =
    SOME (f x y)) /\
   (OPTION_MAP2 f (SOME x) (NONE :'c option) = (NONE :'a option)) /\
   (OPTION_MAP2 f (NONE :'b option) (SOME y) = (NONE :'a option)) /\
   (OPTION_MAP2 f (NONE :'b option) (NONE :'c option) =
    (NONE :'a option)):
   thm
val OPTION_MAP2_cong =
   |- !(x1 :'a option) (x2 :'a option) (y1 :'b option) (y2 :'b option)
      (f1 :'a -> 'b -> 'c) (f2 :'a -> 'b -> 'c).
     (x1 = x2) /\ (y1 = y2) /\
     (!(x :'a) (y :'b).
        (x2 = SOME x) /\ (y2 = SOME y) ==> (f1 x y = f2 x y)) ==>
     (OPTION_MAP2 f1 x1 y1 = OPTION_MAP2 f2 x2 y2):
   thm
val OPTION_MAP_CASE =
   |- OPTION_MAP (f :'a -> 'b) (x :'a option) =
   (option_CASE x (NONE :'b option) ((SOME :'b -> 'b option) o f) :
      'b option):
   thm
val OPTION_MAP_COMPOSE =
   |- OPTION_MAP (f :'c -> 'b) (OPTION_MAP (g :'a -> 'c) (x :'a option)) =
   OPTION_MAP (f o g) x:
   thm
val OPTION_MAP_CONG =
   |- !(opt1 :'a option) (opt2 :'a option) (f1 :'a -> 'b) (f2 :'a -> 'b).
     (opt1 = opt2) /\ (!(x :'a). (opt2 = SOME x) ==> (f1 x = f2 x)) ==>
     (OPTION_MAP f1 opt1 = OPTION_MAP f2 opt2):
   thm
val OPTION_MAP_DEF =
   |- (!(f :'a -> 'b) (x :'a). OPTION_MAP f (SOME x) = SOME (f x)) /\
   !(f :'a -> 'b). OPTION_MAP f (NONE :'a option) = (NONE :'b option):
   thm
val OPTION_MAP_EQ_NONE =
   |- !(f :'a -> 'b) (x :'a option).
     (OPTION_MAP f x = (NONE :'b option)) <=> (x = (NONE :'a option)):
   thm
val OPTION_MAP_EQ_NONE_both_ways =
   |- ((OPTION_MAP (f :'b -> 'a) (x :'b option) = (NONE :'a option)) <=>
    (x = (NONE :'b option))) /\
   (((NONE :'a option) = OPTION_MAP f x) <=> (x = (NONE :'b option))):
   thm
val OPTION_MAP_EQ_SOME =
   |- !(f :'a -> 'b) (x :'a option) (y :'b).
     (OPTION_MAP f x = SOME y) <=> ?(z :'a). (x = SOME z) /\ (y = f z):
   thm
val OPTION_MCOMP_ASSOC =
   |- OPTION_MCOMP (f :'d -> 'c option)
     (OPTION_MCOMP (g :'b -> 'd option) (h :'a -> 'b option)) =
   OPTION_MCOMP (OPTION_MCOMP f g) h:
   thm
val OPTION_MCOMP_ID =
   |- (OPTION_MCOMP (g :'c -> 'd option) (SOME :'c -> 'c option) = g) /\
   (OPTION_MCOMP (SOME :'b -> 'b option) (f :'a -> 'b option) = f):
   thm
val OPTION_MCOMP_def =
   |- !(g :'b -> 'a option) (f :'c -> 'b option) (m :'c).
     OPTION_MCOMP g f m = OPTION_BIND (f m) g:
   thm
val OPTREL_MONO =
   |- (!(x :'a) (y :'b).
      (P :'a -> 'b -> bool) x y ==> (Q :'a -> 'b -> bool) x y) ==>
   OPTREL P (x :'a option) (y :'b option) ==>
   OPTREL Q x y:
   thm
val OPTREL_def =
   |- !(R :'a -> 'b -> bool) (x :'a option) (y :'b option).
     OPTREL R x y <=>
     (x = (NONE :'a option)) /\ (y = (NONE :'b option)) \/
     ?(x0 :'a) (y0 :'b). (x = SOME x0) /\ (y = SOME y0) /\ R x0 y0:
   thm
val OPTREL_refl =
   |- (!(x :'a). (R :'a -> 'a -> bool) x x) ==>
   !(x :'a option). OPTREL R x x:
   thm
val ORD_11 =
   |- !(a :char) (a' :char). (ORD a = ORD a') <=> (a = a'):
   thm
val ORD_BOUND =
   |- !(c :char). ORD c < (256 :num):
   thm
val ORD_CHR =
   |- !(r :num). r < (256 :num) <=> (ORD (CHR r) = r):
   thm
val ORD_CHR_COMPUTE =
   |- !(n :num).
     ORD (CHR n) =
     if n < (256 :num) then n else FAIL ORD (> 255  :bool) (CHR n):
   thm
val ORD_CHR_RWT =
   |- !(r :num). r < (256 :num) ==> (ORD (CHR r) = r):
   thm
val ORD_ONTO =
   |- !(r :num). r < (256 :num) <=> ?(a :char). r = ORD a:
   thm
val SOME_11 =
   |- !(x :'a) (y :'a). (SOME x = SOME y) <=> (x = y):
   thm
val SOME_APPLY_PERMUTE =
   |- (((f :('a -> 'b) option) <*> SOME (x :'a)) :'b option) =
   ((SOME (\(f :'a -> 'b). f x) <*> f) :'b option):
   thm
val SOME_DEF =
   |- !(x :'a). SOME x = option_ABS (INL x :'a + unit):
   thm
val SOME_SOME_APPLY =
   |- ((SOME (f :'b -> 'a) <*> SOME (x :'b)) :'a option) = SOME (f x):
   thm
val STRCAT =
   |- STRCAT (s1 :string) (s2 :string) = STRCAT s1 s2:
   thm
val STRCAT_11 =
   |- (!(l1 :string) (l2 :string) (l3 :string).
      (STRCAT l1 l2 = STRCAT l1 l3) <=> (l2 = l3)) /\
   !(l1 :string) (l2 :string) (l3 :string).
     (STRCAT l2 l1 = STRCAT l3 l1) <=> (l2 = l3):
   thm
val STRCAT_ACYCLIC =
   |- !(s :string) (s1 :string).
     ((s = STRCAT s s1) <=> (s1 = ("" :string))) /\
     ((s = STRCAT s1 s) <=> (s1 = ("" :string))):
   thm
val STRCAT_ASSOC =
   |- !(l1 :string) (l2 :string) (l3 :string).
     STRCAT l1 (STRCAT l2 l3) = STRCAT (STRCAT l1 l2) l3:
   thm
val STRCAT_EQNS =
   |- (STRCAT ("" :string) (s :string) = s) /\
   (STRCAT s ("" :string) = s) /\
   (STRCAT (STRING (c :char) (s1 :string)) (s2 :string) =
    STRING c (STRCAT s1 s2)):
   thm
val STRCAT_EQ_EMPTY =
   |- !(l1 :string) (l2 :string).
     (STRCAT l1 l2 = ("" :string)) <=>
     (l1 = ("" :string)) /\ (l2 = ("" :string)):
   thm
val STRCAT_EXPLODE =
   |- !(s1 :string) (s2 :string).
     STRCAT s1 s2 =
     FOLDR (STRING :char -> string -> string) s2 (EXPLODE s1):
   thm
val STRCAT_def =
   |- (!(l :string). STRCAT ("" :string) l = l) /\
   !(l1 :string) (l2 :string) (h :char).
     STRCAT (STRING h l1) l2 = STRING h (STRCAT l1 l2):
   thm
val STRING_ACYCLIC =
   |- !(s :string) (c :char). STRING c s <> s /\ s <> STRING c s:
   thm
val STRLEN_CAT =
   |- !(l1 :string) (l2 :string).
     STRLEN (STRCAT l1 l2) = STRLEN l1 + STRLEN l2:
   thm
val STRLEN_DEF =
   |- (STRLEN ("" :string) = (0 :num)) /\
   !(h :char) (t :string). STRLEN (STRING h t) = SUC (STRLEN t):
   thm
val STRLEN_EQ_0 =
   |- !(l :string). (STRLEN l = (0 :num)) <=> (l = ("" :string)):
   thm
val STRLEN_EXPLODE_THM =
   |- STRLEN (s :string) = STRLEN (EXPLODE s):
   thm
val STRLEN_THM =
   |- (STRLEN ("" :string) = (0 :num)) /\
   !(h :char) (t :string). STRLEN (STRING h t) = SUC (STRLEN t):
   thm
val STR_def =
   |- !(c :char). STR c = STRING c ("" :string):
   thm
val SUBSTRING_def =
   |- !(s :string) (i :num) (n :num). SUBSTRING (s,i,n) = SEG n i s:
   thm
val SUB_def =
   |- !(s :string) (n :num). SUB (s,n) = EL n s:
   thm
val THE_DEF =
   |- !(x :'a). THE (SOME x) = x:
   thm
val TOCHAR_def =
   |- TOCHAR (STRING (c :char) ("" :string)) = c:
   thm
val TOCHAR_ind =
   |- !(P :string -> bool).
     (!(c :char). P (STRING c ("" :string))) /\ P ("" :string) /\
     (!(v6 :char) (v4 :char) (v5 :string).
        P (STRING v6 (STRING v4 v5))) ==>
     !(v :string). P v:
   thm
val TOCHAR_primitive_def =
   |- TOCHAR =
   WFREC (@(R :string -> string -> bool). WF R)
     (\(TOCHAR :string -> char) (a :string).
        case a of
          ("" :string) => (ARB :char)
        | STRING c ("" :string) => I c
        | STRING c (STRING v2 v3) => (ARB :char)):
   thm
val TOKENS_def =
   |- (!(P :char -> bool). TOKENS P ("" :string) = ([] :string list)) /\
   !(t :string) (h :char) (P :char -> bool).
     TOKENS P (STRING h t) =
     (let
        ((l :string),(r :string)) = SPLITP P (STRING h t)
      in
        if NULL l then TOKENS P (TL r) else l::TOKENS P r):
   thm
val TOKENS_ind =
   |- !(P' :(char -> bool) -> string -> bool).
     (!(P :char -> bool). P' P ("" :string)) /\
     (!(P :char -> bool) (h :char) (t :string).
        (!(l :string) (r :string).
           ((l,r) = SPLITP P (STRING h t)) /\ NULL l ==> P' P (TL r)) /\
        (!(l :string) (r :string).
           ((l,r) = SPLITP P (STRING h t)) /\ ~NULL l ==> P' P r) ==>
        P' P (STRING h t)) ==>
     !(v :char -> bool) (v1 :string). P' v v1:
   thm
val TRANSLATE_def =
   |- !(f :char -> string) (s :string). TRANSLATE f s = CONCAT (MAP f s):
   thm
val TR_EQ_rules = fn: thm -> thm -> thm
val accessors_of = fn: hol_type -> thm list
val asymMsg_11 =
   |- !(a0 :'princ pKey) (a1 :'message option) (a0' :'princ pKey)
      (a1' :'message option).
     (Ea a0 a1 = Ea a0' a1') <=> (a0 = a0') /\ (a1 = a1'):
   thm
val asymMsg_Axiom =
   |- !(f :'princ pKey -> 'message option -> 'a).
     ?(fn :('message, 'princ) asymMsg -> 'a).
       !(a0 :'princ pKey) (a1 :'message option). fn (Ea a0 a1) = f a0 a1:
   thm
val asymMsg_TY_DEF =
   |- ?(rep :
      ('message, 'princ) asymMsg ->
      ('princ pKey # 'message option) recspace).
     TYPE_DEFINITION
       (\(a0' :('princ pKey # 'message option) recspace).
          !('asymMsg'  :
             ('princ pKey # 'message option) recspace -> bool).
            (!(a0' :('princ pKey # 'message option) recspace).
               (?(a0 :'princ pKey) (a1 :'message option).
                  a0' =
                  (\(a0 :'princ pKey) (a1 :'message option).
                     ind_type$CONSTR (0 :num) (a0,a1)
                       (\(n :num).
                          (ind_type$BOTTOM :('princ pKey #
                                             'message option)
                                            recspace))) a0 a1) ==>
               'asymMsg' a0') ==>
            'asymMsg' a0') rep:
   thm
val asymMsg_case_cong =
   |- !(M :('message, 'princ) asymMsg) (M' :('message, 'princ) asymMsg)
      (f :'princ pKey -> 'message option -> 'a).
     (M = M') /\
     (!(a0 :'princ pKey) (a1 :'message option).
        (M' = Ea a0 a1) ==>
        (f a0 a1 =
         (f' :'princ pKey -> 'message option -> 'a) a0 a1)) ==>
     ((asymMsg_CASE M f :'a) = (asymMsg_CASE M' f' :'a)):
   thm
val asymMsg_case_def =
   |- !(a0 :'princ pKey) (a1 :'message option)
      (f :'princ pKey -> 'message option -> 'a).
     (asymMsg_CASE (Ea a0 a1) f :'a) = f a0 a1:
   thm
val asymMsg_induction =
   |- !(P :('message, 'princ) asymMsg -> bool).
     (!(p :'princ pKey) ($o :'message option). P (Ea p $o)) ==>
     !(a :('message, 'princ) asymMsg). P a:
   thm
val asymMsg_nchotomy =
   |- !(aa :('message, 'princ) asymMsg).
     ?(p :'princ pKey) ($o :'message option). aa = Ea p $o:
   thm
val asymMsg_one_one =
   |- !(a0 :'princ pKey) (a1 :'message option) (a0' :'princ pKey)
      (a1' :'message option).
     (Ea a0 a1 = Ea a0' a1') <=> (a0 = a0') /\ (a1 = a1'):
   thm
val asymMsg_size_def =
   |- !(f :'message -> num) (f1 :'princ -> num) (a0 :'princ pKey)
      (a1 :'message option).
     asymMsg_size f f1 (Ea a0 a1) =
     (1 :num) + (pKey_size f1 a0 + option_size f a1):
   thm
val axiom_of = fn: hol_type -> thm
val axiom_of0 = fn: hol_type -> shared_thm
val case_cong_of = fn: hol_type -> thm
val case_const_of = fn: hol_type -> term
val case_def_of = fn: hol_type -> thm
val char_BIJ =
   |- (!(a :char). CHR (ORD a) = a) /\
   !(r :num). (\(n :num). n < (256 :num)) r <=> (ORD (CHR r) = r):
   thm
val char_TY_DEF =
   |- ?(rep :char -> num). TYPE_DEFINITION (\(n :num). n < (256 :num)) rep:
   thm
val char_ge_def =
   |- !(a :char) (b :char). a >= b <=> ORD a >= ORD b:
   thm
val char_gt_def =
   |- !(a :char) (b :char). a > b <=> ORD a > ORD b:
   thm
val char_le_def =
   |- !(a :char) (b :char). a <= b <=> ORD a <= ORD b:
   thm
val char_lt_def =
   |- !(a :char) (b :char). a < b <=> ORD a < ORD b:
   thm
val char_nchotomy =
   |- !(c :char). ?(n :num). c = CHR n:
   thm
val char_size_def =
   |- !(c :char). char_size c = (0 :num):
   thm
val cipher_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY)asymMsg | bool | TY digest | (TY, TY)fun |
                  ind | TY itself | TY list | num | one | TY option |
                  TY pKey | (TY, TY)prod | TY recspace | TY set |
                  (TY, TY)sum | symKey | TY symMsg | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b) asymMsg = ('a, 'b) cipher$asymMsg             
  bool = min$bool                                        
  'a digest = 'a cipher$digest                           
  ('a, 'b) fun = ('a, 'b) min$fun                        
  ind = min$ind                                          
  'a itself = 'a bool$itself                             
  'a list = 'a list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = 'a option$option                           
  'a pKey = 'a cipher$pKey                               
  ('a, 'b) prod = ('a, 'b) pair$prod                     
  'a recspace = 'a ind_type$recspace                     
  'a set = ('a, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = ('a, 'b) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = 'a cipher$symMsg                           
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "" TM  [<=/=>] | TM "<=/=>" TM | TM "" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "" TM  [NOTIN] | TM "NOTIN" TM |
                TM "" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "" TM  [SUBSET] | TM "SUBSET" TM | TM "" TM  [>=] |
                TM ">=" TM | TM "" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "" TM  [-] | TM "-" TM | TM "+" TM |
                TM "" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(600)  TM  ::=  TM "" TM  [CROSS] | TM "CROSS" TM |
                TM "" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "" TM  [*,] | TM "*," TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "" TM  [O] | TM "O" TM | TM "" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "" | TM "" | TM ""  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM ""  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD
  DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP
  EXT_POINT Ea Es F FACT FAIL FCOMM FILTER FIND FINITE FIRSTN FLAT FOLDL
  FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET GENLIST GENLIST_AUX GSPEC
  GUESS_EXISTS GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL
  GUESS_FORALL_GAP GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN
  INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON
  INFINITE INJ INL INR INSERT INTER INVOL ISL ISR IS_EL IS_NONE
  IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN
  IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET Id IfCases K LAST LASTN
  LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND
  LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi
  LIST_TO_SET LLEX LRC LUPDATE LinearOrder MAP MAP2 MAPi MAPi_ACC MAX
  MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID NIL NONE NOTIN NRC NULL
  NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND O ODD OLEAST ONE_ONE ONTO
  OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE OPTION_GUARD
  OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2 OPTION_MCOMP
  OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Order PAD_LEFT PAD_RIGHT
  PERMUTES PI PMATCH PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED
  PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW
  PMATCH_ROW_COND PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ
  PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0
  PMATCH_ROW_magic_1 PMATCH_ROW_magic_2 PMATCH_ROW_magic_3
  PMATCH_ROW_magic_4 PMATCH_magic_1 POW PRE PREFIX PREIMAGE PRIM_REC
  PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder RC RCOMPL
  RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ
  RELPOW REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST
  RESTRICT RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL
  RES_SELECT REV REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT
  RSUBSET RTC RUNION RUNIV S SC SCANL SCANR SEG SET_TO_LIST SIGMA
  SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING
  SINGL SN SND SNOC SOME SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP StrongLinearOrder StrongOrder T TAKE TC THE TL TL_T
  TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
  UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder WeakOrder
  ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number antisymmetric approx
  asymMsg_CASE asymMsg_size bool_size case chooser count countable
  deciphP deciphS delN dest_rec diag diamond digest_CASE digest_size
  dropWhile enumerate equiv_on equivalence findi findq fupdLast hash
  iBIT_cases internal_mult inv inv_image invtri invtri0 irreflexive
  isPREFIX itself_case lift2 listRel list_CASE list_size literal_case
  measure mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen nlistrec
  nmap nnil npair nsnd nub num_CASE num_to_pair o one one_CASE one_size
  option_ABS option_CASE option_REP option_size pKey_CASE pKey_size
  pair_CASE pair_size pair_to_num pairwise partition privK pubK
  rcdiamond reflexive schroeder_close set sign signVerify some
  splitAtPki stmarker sum_CASE sum_size sym symKey_CASE symKey_size
  symMsg_CASE symMsg_size symmetric the_fun the_value total transitive
  tri trichotomous tri unint univ wellfounded ~         
Overloading:
                     -> 
    (\(x :'a). list$CONS x (list$NIL :'a list))
    (\(h :'a) (l :'a list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (\(x :'a itself). univ((:'a) :'a itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (\(x :'a list) (y :'a list). list$isPREFIX x y)
  <=/=>              ->  (\(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (\(x :'a) (y :'a). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (\(s :'a -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (\(x :'a) (l :'a list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (\(x :'a list) (y :'a list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (\(x :'a) (l :'a list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              -> 
    (\(x :'a) (y :'a -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (\(f :'a -> 'a) (s :'a -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (\(x :'a). list$CONS x (list$NIL :'a list))
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    digest_CASE asymMsg_CASE pKey_CASE symMsg_CASE symKey_CASE list_CASE
    option_CASE sum_CASE num_CASE pair_CASE itself_case literal_case
    COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri              ->  invtri
  univ               ->  (\(x :'a itself). univ((:'a) :'a itself))
                    ->  (\(x :num). arithmetic$EXP x (2n :num))
                    ->  (\(x :num). arithmetic$EXP x (3n :num))
                    ->  PROD_IMAGE
                    ->  EMPTY
                   ->  EMPTY_REL
                    ->  SUM_IMAGE
                    ->  (\(x :'a) (y :'a). bool$~ (min$= x y))
                    ->  (\(x :'a itself). univ((:'a) :'a itself))
                   ->  RUNIV
User printing functions:
  if (gd :bool) then (tr :'a) else (fl :'a)       ->  bool.COND
  LET (f :'a -> 'b) (x :'a)       ->  bool.LET
  univ((:'a) :'a itself)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val constructors_of = fn: hol_type -> term list
type conv = Abbrev.conv
val datatype_asymMsg =
   |- DATATYPE
     ((asymMsg :
        ('princ pKey -> 'message option -> ('message, 'princ) asymMsg)
        -> bool)
        (Ea :'princ pKey ->
             'message option -> ('message, 'princ) asymMsg)):
   thm
val datatype_digest =
   |- DATATYPE
     ((digest :('message option -> 'message digest) -> bool)
        (hash :'message option -> 'message digest)):
   thm
val datatype_option =
   |- DATATYPE
     ((option :'a option -> ('a -> 'a option) -> 'b) (NONE :'a option)
        (SOME :'a -> 'a option)):
   thm
val datatype_pKey =
   |- DATATYPE
     ((pKey :('princ -> 'princ pKey) -> ('princ -> 'princ pKey) -> bool)
        (pubK :'princ -> 'princ pKey) (privK :'princ -> 'princ pKey)):
   thm
val datatype_symKey =
   |- DATATYPE ((symKey :(num -> symKey) -> bool) sym):
   thm
val datatype_symMsg =
   |- DATATYPE
     ((symMsg :(symKey -> 'message option -> 'message symMsg) -> bool)
        (Es :symKey -> 'message option -> 'message symMsg)):
   thm
val deciphP_clauses =
   |- (!(P :'a) (text :'b).
      (deciphP (pubK P) (Ea (privK P) (SOME text)) = SOME text) /\
      (deciphP (privK P) (Ea (pubK P) (SOME text)) = SOME text)) /\
   (!(k :'a pKey) (P :'a) (text :'b).
      (deciphP k (Ea (privK P) (SOME text)) = SOME text) <=>
      (k = pubK P)) /\
   (!(k :'a pKey) (P :'a) (text :'b).
      (deciphP k (Ea (pubK P) (SOME text)) = SOME text) <=>
      (k = privK P)) /\
   (!(x :'message) (k2 :'b pKey) (k1 :'b pKey) (P2 :'b) (P1 :'b).
      (deciphP (pubK P1) (Ea (pubK P2) (SOME x)) =
       (NONE :'message option)) /\
      (deciphP k1 (Ea k2 (NONE :'message option)) =
       (NONE :'message option))) /\
   !(x :'message) (P2 :'b) (P1 :'b).
     deciphP (privK P1) (Ea (privK P2) (SOME x)) =
     (NONE :'message option):
   thm
val deciphP_def =
   |- (deciphP (key :'princ pKey)
      (Ea (privK (P :'princ)) (SOME (x :'message))) =
    if key = pubK P then SOME x else (NONE :'message option)) /\
   (deciphP key (Ea (pubK P) (SOME x)) =
    if key = privK P then SOME x else (NONE :'message option)) /\
   (deciphP (k1 :'princ pKey)
      (Ea (k2 :'princ pKey) (NONE :'message option)) =
    (NONE :'message option)):
   thm
val deciphP_ind =
   |- !(P' :'princ pKey -> ('message, 'princ) asymMsg -> bool).
     (!(key :'princ pKey) (P :'princ) (x :'message).
        P' key (Ea (privK P) (SOME x))) /\
     (!(key :'princ pKey) (P :'princ) (x :'message).
        P' key (Ea (pubK P) (SOME x))) /\
     (!(k1 :'princ pKey) (k2 :'princ pKey).
        P' k1 (Ea k2 (NONE :'message option))) ==>
     !(v :'princ pKey) (v1 :('message, 'princ) asymMsg). P' v v1:
   thm
val deciphP_one_one =
   |- (!(P1 :'a) (P2 :'a) (text1 :'b) (text2 :'b).
      (deciphP (pubK P1) (Ea (privK P2) (SOME text2)) = SOME text1) <=>
      (P1 = P2) /\ (text1 = text2)) /\
   (!(P1 :'a) (P2 :'a) (text1 :'b) (text2 :'b).
      (deciphP (privK P1) (Ea (pubK P2) (SOME text2)) = SOME text1) <=>
      (P1 = P2) /\ (text1 = text2)) /\
   (!(p :'b pKey) (c :'a option) (P :'b) (msg :'a).
      (deciphP (pubK P) (Ea p c) = SOME msg) <=>
      (p = privK P) /\ (c = SOME msg)) /\
   (!(enMsg :('a, 'b) asymMsg) (P :'b) (msg :'a).
      (deciphP (pubK P) enMsg = SOME msg) <=>
      (enMsg = Ea (privK P) (SOME msg))) /\
   (!(p :'b pKey) (c :'a option) (P :'b) (msg :'a).
      (deciphP (privK P) (Ea p c) = SOME msg) <=>
      (p = pubK P) /\ (c = SOME msg)) /\
   !(enMsg :('a, 'b) asymMsg) (P :'b) (msg :'a).
     (deciphP (privK P) enMsg = SOME msg) <=>
     (enMsg = Ea (pubK P) (SOME msg)):
   thm
val deciphS_clauses =
   |- (!(k :symKey) (text :'a).
      deciphS k (Es k (SOME text)) = SOME text) /\
   (!(k1 :symKey) (k2 :symKey) (text :'a).
      (deciphS k1 (Es k2 (SOME text)) = SOME text) <=> (k1 = k2)) /\
   (!(k1 :symKey) (k2 :symKey) (text :'a).
      (deciphS k1 (Es k2 (SOME text)) = (NONE :'a option)) <=>
      k1 <> k2) /\
   !(k1 :symKey) (k2 :symKey).
     deciphS k1 (Es k2 (NONE :'a option)) = (NONE :'a option):
   thm
val deciphS_def =
   |- (deciphS (k1 :symKey) (Es (k2 :symKey) (SOME (x :'message))) =
    if k1 = k2 then SOME x else (NONE :'message option)) /\
   (deciphS k1 (Es k2 (NONE :'message option)) =
    (NONE :'message option)):
   thm
val deciphS_ind =
   |- !(P :symKey -> 'message symMsg -> bool).
     (!(k1 :symKey) (k2 :symKey) (x :'message).
        P k1 (Es k2 (SOME x))) /\
     (!(k1 :symKey) (k2 :symKey).
        P k1 (Es k2 (NONE :'message option))) ==>
     !(v :symKey) (v1 :'message symMsg). P v v1:
   thm
val deciphS_one_one =
   |- (!(k1 :symKey) (k2 :symKey) (text1 :'a) (text2 :'a).
      (deciphS k1 (Es k2 (SOME text2)) = SOME text1) <=>
      (k1 = k2) /\ (text1 = text2)) /\
   !(enMsg :'message symMsg) (text :'message) (key :symKey).
     (deciphS key enMsg = SOME text) <=> (enMsg = Es key (SOME text)):
   thm
val dest_case = fn: term -> term * term * (term * term) list
val dest_record = fn: term -> hol_type * (string * term) list
val dest_record_type = fn: hol_type -> (string * hol_type) list
val destructors_of = fn: hol_type -> thm list
val digest_11 =
   |- !(a :'message option) (a' :'message option).
     (hash a = hash a') <=> (a = a'):
   thm
val digest_Axiom =
   |- !(f :'message option -> 'a).
     ?(fn :'message digest -> 'a).
       !(a :'message option). fn (hash a) = f a:
   thm
val digest_TY_DEF =
   |- ?(rep :'message digest -> 'message option recspace).
     TYPE_DEFINITION
       (\(a0 :'message option recspace).
          !('digest'  :'message option recspace -> bool).
            (!(a0 :'message option recspace).
               (?(a :'message option).
                  a0 =
                  (\(a :'message option).
                     ind_type$CONSTR (0 :num) a
                       (\(n :num).
                          (ind_type$BOTTOM :'message option recspace)))
                    a) ==>
               'digest' a0) ==>
            'digest' a0) rep:
   thm
val digest_case_cong =
   |- !(M :'message digest) (M' :'message digest)
      (f :'message option -> 'a).
     (M = M') /\
     (!(a :'message option).
        (M' = hash a) ==> (f a = (f' :'message option -> 'a) a)) ==>
     ((digest_CASE M f :'a) = (digest_CASE M' f' :'a)):
   thm
val digest_case_def =
   |- !(a :'message option) (f :'message option -> 'a).
     (digest_CASE (hash a) f :'a) = f a:
   thm
val digest_induction =
   |- !(P :'message digest -> bool).
     (!($o :'message option). P (hash $o)) ==>
     !(d :'message digest). P d:
   thm
val digest_nchotomy =
   |- !(dd :'message digest). ?($o :'message option). dd = hash $o:
   thm
val digest_one_one =
   |- !(a :'message option) (a' :'message option).
     (hash a = hash a') <=> (a = a'):
   thm
val digest_size_def =
   |- !(f :'message -> num) (a :'message option).
     digest_size f (hash a) = (1 :num) + option_size f a:
   thm
val distinct_clauses = fn: hol_type -> thm
val distinct_of = fn: hol_type -> thm
val elts = fn: unit -> tyinfo list
val encode_of = fn: hol_type -> term * thm
val encode_of0 = fn: hol_type -> (term * shared_thm) option
val fetch = fn: hol_type -> tyinfo option
val fields_of = fn: hol_type -> (string * hol_type) list
val flip_TR_rules = fn: thm -> term
val flip_imp = fn: term -> term
eqtype hol_type
val induction_of = fn: hol_type -> thm
val induction_of0 = fn: hol_type -> shared_thm
val isAlphaNum_def =
   |- !(c :char). isAlphaNum c <=> isAlpha c \/ isDigit c:
   thm
val isAlpha_def =
   |- !(c :char). isAlpha c <=> isLower c \/ isUpper c:
   thm
val isAscii_def =
   |- !(c :char). isAscii c <=> ORD c <= (127 :num):
   thm
val isCntrl_def =
   |- !(c :char). isCntrl c <=> ORD c < (32 :num) \/ (127 :num) <= ORD c:
   thm
val isDigit_def =
   |- !(c :char). isDigit c <=> (48 :num) <= ORD c /\ ORD c <= (57 :num):
   thm
val isGraph_def =
   |- !(c :char). isGraph c <=> isPrint c /\ ~isSpace c:
   thm
val isHexDigit_def =
   |- !(c :char).
     isHexDigit c <=>
     (48 :num) <= ORD c /\ ORD c <= (57 :num) \/
     (97 :num) <= ORD c /\ ORD c <= (102 :num) \/
     (65 :num) <= ORD c /\ ORD c <= (70 :num):
   thm
val isLower_def =
   |- !(c :char). isLower c <=> (97 :num) <= ORD c /\ ORD c <= (122 :num):
   thm
val isPREFIX_DEF =
   |- !(s1 :string) (s2 :string).
     s1 <<= s2 <=>
     case (DEST_STRING s1,DEST_STRING s2) of
       ((NONE :(char # string) option),v1) => T
     | (SOME v2,(NONE :(char # string) option)) => F
     | (SOME (c1,t1),SOME (c2,t2)) => (c1 = c2) /\ t1 <<= t2:
   thm
val isPREFIX_IND =
   |- !(P :string -> string -> bool).
     (!(s1 :string) (s2 :string).
        (!(c :char) (t1 :string) (t2 :string).
           (DEST_STRING s1 = SOME (c,t1)) /\
           (DEST_STRING s2 = SOME (c,t2)) ==>
           P t1 t2) ==>
        P s1 s2) ==>
     !(v :string) (v1 :string). P v v1:
   thm
val isPREFIX_STRCAT =
   |- !(s1 :string) (s2 :string).
     s1 <<= s2 <=> ?(s3 :string). s2 = STRCAT s1 s3:
   thm
val isPrint_def =
   |- !(c :char). isPrint c <=> (32 :num) <= ORD c /\ ORD c < (127 :num):
   thm
val isPunct_def =
   |- !(c :char). isPunct c <=> isGraph c /\ ~isAlphaNum c:
   thm
val isSpace_def =
   |- !(c :char).
     isSpace c <=>
     (ORD c = (32 :num)) \/ (9 :num) <= ORD c /\ ORD c <= (13 :num):
   thm
val isUpper_def =
   |- !(c :char). isUpper c <=> (65 :num) <= ORD c /\ ORD c <= (90 :num):
   thm
val is_case = fn: term -> bool
val is_constructor = fn: term -> bool
val is_record = fn: term -> bool
val is_record_type = fn: hol_type -> bool
val mk_case = fn: term * (term * term) list -> term
val mk_pattern_fn = fn: (term * term) list -> term
val mk_record = fn: hol_type * (string * term) list -> term
val nchotomy_of = fn: hol_type -> thm
val one_one_of = fn: hol_type -> thm
val option_Axiom =
   |- !(e :'b) (f :'a -> 'b).
     ?(fn :'a option -> 'b).
       (fn (NONE :'a option) = e) /\ !(x :'a). fn (SOME x) = f x:
   thm
val option_CASES =
   |- !(opt :'a option).
     (?(x :'a). opt = SOME x) \/ (opt = (NONE :'a option)):
   thm
val option_CLAUSES =
   |- (!(x :'a) (y :'a). (SOME x = SOME y) <=> (x = y)) /\
   (!(x :'a). THE (SOME x) = x) /\
   (!(x :'a). (NONE :'a option) <> SOME x) /\
   (!(x :'a). SOME x <> (NONE :'a option)) /\
   (!(x :'a). IS_SOME (SOME x) <=> T) /\
   (IS_SOME (NONE :'a option) <=> F) /\
   (!(x :'a option). IS_NONE x <=> (x = (NONE :'a option))) /\
   (!(x :'a option). ~IS_SOME x <=> (x = (NONE :'a option))) /\
   (!(x :'a option). IS_SOME x ==> (SOME (THE x) = x)) /\
   (!(x :'a option).
      (option_CASE x (NONE :'a option) (SOME :'a -> 'a option) :
         'a option) =
      x) /\
   (!(x :'a option).
      (option_CASE x x (SOME :'a -> 'a option) :'a option) = x) /\
   (!(x :'a option).
      IS_NONE x ==> ((option_CASE x (e :'b) (f :'a -> 'b) :'b) = e)) /\
   (!(x :'a option).
      IS_SOME x ==> ((option_CASE x e f :'b) = f (THE x))) /\
   (!(x :'a option).
      IS_SOME x ==>
      ((option_CASE x (e :'a option) (SOME :'a -> 'a option) :
          'a option) =
       x)) /\
   (!(v :'b) (f :'a -> 'b).
      (option_CASE (NONE :'a option) v f :'b) = v) /\
   (!(x :'a) (v :'b) (f :'a -> 'b).
      (option_CASE (SOME x) v f :'b) = f x) /\
   (!(f :'a -> 'b) (x :'a). OPTION_MAP f (SOME x) = SOME (f x)) /\
   (!(f :'a -> 'b).
      OPTION_MAP f (NONE :'a option) = (NONE :'b option)) /\
   (OPTION_JOIN (NONE :'a option option) = (NONE :'a option)) /\
   !(x :'a option). OPTION_JOIN (SOME x) = x:
   thm
val option_Induct =
   |- !(P :'a option -> bool).
     (!(a :'a). P (SOME a)) /\ P (NONE :'a option) ==>
     !(x :'a option). P x:
   thm
val option_REP_ABS_DEF =
   |- (!(a :'a option). option_ABS (option_REP a) = a) /\
   !(r :'a + unit).
     (\(x :'a + unit). T) r <=> (option_REP (option_ABS r) = r):
   thm
val option_TY_DEF =
   |- ?(rep :'a option -> 'a + unit).
     TYPE_DEFINITION (\(x :'a + unit). T) rep:
   thm
val option_case_ID =
   |- !(x :'a option).
     (option_CASE x (NONE :'a option) (SOME :'a -> 'a option) :
        'a option) =
     x:
   thm
val option_case_SOME_ID =
   |- !(x :'a option).
     (option_CASE x x (SOME :'a -> 'a option) :'a option) = x:
   thm
val option_case_compute =
   |- (option_CASE (x :'a option) (e :'b) (f :'a -> 'b) :'b) =
   if IS_SOME x then f (THE x) else e:
   thm
val option_case_cong =
   |- !(M :'a option) (M' :'a option) (v :'b) (f :'a -> 'b).
     (M = M') /\ ((M' = (NONE :'a option)) ==> (v = (v' :'b))) /\
     (!(x :'a). (M' = SOME x) ==> (f x = (f' :'a -> 'b) x)) ==>
     ((option_CASE M v f :'b) = (option_CASE M' v' f' :'b)):
   thm
val option_case_def =
   |- (!(v :'b) (f :'a -> 'b).
      (option_CASE (NONE :'a option) v f :'b) = v) /\
   !(x :'a) (v :'b) (f :'a -> 'b). (option_CASE (SOME x) v f :'b) = f x:
   thm
val option_distinct =
   |- !(x :'a). (NONE :'a option) <> SOME x:
   thm
val option_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
         TY  ::=  bool | (TY, TY)fun | ind | TY itself | one |
                  TY option | (TY, TY)sum | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  bool = min$bool                                        
  ('a, 'b) fun = ('a, 'b) min$fun                        
  ind = min$ind                                          
  'a itself = 'a bool$itself                             
  one = one$one                                           (not printed)
  'a option = 'a option$option                           
  ('a, 'b) sum = ('a, 'b) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "some" <..binders..> "." TM |
                "!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "" TM  [<=/=>] | TM "<=/=>" TM | TM "" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "" TM  [NOTIN] | TM "NOTIN" TM | TM "" TM  [IN] |
                TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "" TM | TM "<>" TM   (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(500)  TM  ::=  TM "<*>" TM  [APPLICATIVE_FAPPLY]   (L-associative)
(800)  TM  ::=  TM "" TM  [o] | TM "o" TM   (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
   _ fakeconst4.case,S10.case magic,7.default ! () ++ /\ :- :> <=/=> <=>
  <> = =+ ==> ? ?! @ ABS_sum AC APPLICATIVE_FAPPLY ARB ASSOC Abbrev
  BOUNDED COMM COND Cong DATATYPE EXT_POINT F FAIL FCOMM I IN INL INR
  ISL ISR IS_NONE IS_SOME IS_SUM_REP IfCases K LEFT_ID LET MONOID NONE
  NOTIN ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE
  OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2
  OPTION_MCOMP OPTREL OUTL OUTR REP_sum RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT RIGHT_ID S SOME SUM_ALL T THE
  TYPE_DEFINITION UNIV_POINT UPDATE W \/ case itself_case lift2
  literal_case o one one_CASE option_ABS option_CASE option_REP some
  stmarker sum_CASE the_value unint ~ 
Overloading:
  ()                 ->  one
  <=/=>              ->  (\(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (\(x :'a) (y :'a). bool$~ (min$= x y))
  =+                 ->  UPDATE
  APPLICATIVE_FAPPLY ->  OPTION_APPLY
  NOTIN              -> 
    (\(x :'a) (y :'a -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  case               -> 
    option_CASE sum_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
                    ->  (\(x :'a) (y :'a). bool$~ (min$= x y))
User printing functions:
  if (gd :bool) then (tr :'a) else (fl :'a)       ->  bool.COND
  LET (f :'a -> 'b) (x :'a)       ->  bool.LET):
   type_grammar.grammar * term_grammar.grammar
val option_induction =
   |- !(P :'a option -> bool).
     P (NONE :'a option) /\ (!(a :'a). P (SOME a)) ==>
     !(x :'a option). P x:
   thm
val option_nchotomy =
   |- !(opt :'a option).
     (opt = (NONE :'a option)) \/ ?(x :'a). opt = SOME x:
   thm
val option_one_one =
   |- !(x :'a) (y :'a). (SOME x = SOME y) <=> (x = y):
   thm
val pKey_11 =
   |- (!(a :'princ) (a' :'princ). (pubK a = pubK a') <=> (a = a')) /\
   !(a :'princ) (a' :'princ). (privK a = privK a') <=> (a = a'):
   thm
val pKey_Axiom =
   |- !(f0 :'princ -> 'a) (f1 :'princ -> 'a).
     ?(fn :'princ pKey -> 'a).
       (!(a :'princ). fn (pubK a) = f0 a) /\
       !(a :'princ). fn (privK a) = f1 a:
   thm
val pKey_TY_DEF =
   |- ?(rep :'princ pKey -> 'princ recspace).
     TYPE_DEFINITION
       (\(a0 :'princ recspace).
          !('pKey'  :'princ recspace -> bool).
            (!(a0 :'princ recspace).
               (?(a :'princ).
                  a0 =
                  (\(a :'princ).
                     ind_type$CONSTR (0 :num) a
                       (\(n :num). (ind_type$BOTTOM :'princ recspace)))
                    a) \/
               (?(a :'princ).
                  a0 =
                  (\(a :'princ).
                     ind_type$CONSTR (SUC (0 :num)) a
                       (\(n :num). (ind_type$BOTTOM :'princ recspace)))
                    a) ==>
               'pKey' a0) ==>
            'pKey' a0) rep:
   thm
val pKey_case_cong =
   |- !(M :'princ pKey) (M' :'princ pKey) (f :'princ -> 'a)
      (f1 :'princ -> 'a).
     (M = M') /\
     (!(a :'princ). (M' = pubK a) ==> (f a = (f' :'princ -> 'a) a)) /\
     (!(a :'princ).
        (M' = privK a) ==> (f1 a = (f1' :'princ -> 'a) a)) ==>
     ((pKey_CASE M f f1 :'a) = (pKey_CASE M' f' f1' :'a)):
   thm
val pKey_case_def =
   |- (!(a :'princ) (f :'princ -> 'a) (f1 :'princ -> 'a).
      (pKey_CASE (pubK a) f f1 :'a) = f a) /\
   !(a :'princ) (f :'princ -> 'a) (f1 :'princ -> 'a).
     (pKey_CASE (privK a) f f1 :'a) = f1 a:
   thm
val pKey_distinct =
   |- !(a' :'princ) (a :'princ). pubK a <> privK a':
   thm
val pKey_distinct_clauses =
   |- (!(a' :'princ) (a :'princ). pubK a <> privK a') /\
   !(a' :'princ) (a :'princ). privK a' <> pubK a:
   thm
val pKey_induction =
   |- !(P :'princ pKey -> bool).
     (!(p :'princ). P (pubK p)) /\ (!(p :'princ). P (privK p)) ==>
     !(p :'princ pKey). P p:
   thm
val pKey_nchotomy =
   |- !(pp :'princ pKey).
     (?(p :'princ). pp = pubK p) \/ ?(p :'princ). pp = privK p:
   thm
val pKey_one_one =
   |- (!(a :'princ) (a' :'princ). (pubK a = pubK a') <=> (a = a')) /\
   !(a :'princ) (a' :'princ). (privK a = privK a') <=> (a = a'):
   thm
val pKey_size_def =
   |- (!(f :'princ -> num) (a :'princ).
      pKey_size f (pubK a) = (1 :num) + f a) /\
   !(f :'princ -> num) (a :'princ).
     pKey_size f (privK a) = (1 :num) + f a:
   thm
val ranged_char_nchotomy =
   |- !(c :char). ?(n :num). (c = CHR n) /\ n < (256 :num):
   thm
val read = fn: {Thy: string, Tyop: string} -> tyinfo option
val recognizers_of = fn: hol_type -> thm list
val register_update_fn = fn: (tyinfo list -> tyinfo list) -> unit
type shared_thm
val signVerifyOK =
   |- !(P :'princ) (msg :'message).
     signVerify (pubK P) (sign (privK P) (hash (SOME msg))) (SOME msg):
   thm
val signVerify_def =
   |- !(pubKey :'princ pKey) (signature :('message digest, 'princ) asymMsg)
      (msgContents :'message option).
     signVerify pubKey signature msgContents <=>
     (SOME (hash msgContents) = deciphP pubKey signature):
   thm
val signVerify_one_one =
   |- (!(P :'a) (m1 :'b) (m2 :'b).
      signVerify (pubK P) (Ea (privK P) (SOME (hash (SOME m1))))
        (SOME m2) <=> (m1 = m2)) /\
   (!(signature :('message digest, 'princ) asymMsg) (P :'princ)
       (text :'message).
      signVerify (pubK P) signature (SOME text) <=>
      (signature = sign (privK P) (hash (SOME text)))) /\
   !(text2 :'b) (text1 :'b) (P2 :'a) (P1 :'a).
     signVerify (pubK P1) (sign (privK P2) (hash (SOME text2)))
       (SOME text1) <=> (P1 = P2) /\ (text1 = text2):
   thm
val sign_def =
   |- !(pubKey :'princ pKey) (dgst :'message digest).
     sign pubKey dgst = Ea pubKey (SOME dgst):
   thm
val sign_one_one =
   |- !(pubKey1 :'a pKey) (pubKey2 :'a pKey) (m1 :'b option)
      (m2 :'b option).
     (sign pubKey1 (hash m1) = sign pubKey2 (hash m2)) <=>
     (pubKey1 = pubKey2) /\ (m1 = m2):
   thm
val simpls_of = fn: hol_type -> simpfrag.simpfrag
val size_of = fn: hol_type -> term * thm
val size_of0 = fn: hol_type -> (term * shared_thm) option
val some_EQ =
   |- ((some(x :'a). x = (y :'a)) = SOME y) /\
   ((some(x :'a). y = x) = SOME y):
   thm
val some_F =
   |- (some(x :'a). F) = (NONE :'a option):
   thm
val some_def =
   |- !(P :'a -> bool).
     $some P =
     if ?(x :'a). P x then SOME (@(x :'a). P x) else (NONE :'a option):
   thm
val some_elim =
   |- (Q :'a option -> bool) ($some (P :'a -> bool)) ==>
   (?(x :'a). P x /\ Q (SOME x)) \/
   (!(x :'a). ~P x) /\ Q (NONE :'a option):
   thm
val some_intro =
   |- (!(x :'a). (P :'a -> bool) x ==> (Q :'a option -> bool) (SOME x)) /\
   ((!(x :'a). ~P x) ==> Q (NONE :'a option)) ==>
   Q ($some P):
   thm
val string_ge_def =
   |- !(s1 :string) (s2 :string). s1 >= s2 <=> s2 <= s1:
   thm
val string_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  bool | char | (TY, TY)fun | ind | TY itself |
                  TY list | num | one | TY option | (TY, TY)prod |
                  TY recspace | TY set | string | (TY, TY)sum | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  bool = min$bool                                        
  char = string$char                                     
  ('a, 'b) fun = ('a, 'b) min$fun                        
  ind = min$ind                                          
  'a itself = 'a bool$itself                             
  'a list = 'a list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = 'a option$option                           
  ('a, 'b) prod = ('a, 'b) pair$prod                     
  'a recspace = 'a ind_type$recspace                     
  'a set = ('a, min$bool) min$fun                         (not printed)
  string = string$char list$list                         
  ('a, 'b) sum = ('a, 'b) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "" TM  [<=/=>] | TM "<=/=>" TM | TM "" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "" TM  [NOTIN] | TM "NOTIN" TM |
                TM "" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "" TM  [SUBSET] | TM "SUBSET" TM | TM "" TM  [>=] |
                TM ">=" TM | TM "" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "" TM  [-] | TM "-" TM | TM "+" TM |
                TM "" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(600)  TM  ::=  TM "" TM  [CROSS] | TM "CROSS" TM |
                TM "" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "" TM  [*,] | TM "*," TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "" TM  [O] | TM "O" TM | TM "" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "" | TM "" | TM ""  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM ""  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY ARB ASSOC Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2
  BOUNDED BUTFIRSTN BUTLAST BUTLASTN CARD CHOICE CHR COMM COMPL CONCAT
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Cong DATATYPE
  DELETE DEST_STRING DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL
  EMPTY EMPTYSTRING EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP
  EXPLODE EXTRACT EXT_POINT F FACT FAIL FCOMM FIELDS FILTER FIND FINITE
  FIRSTN FLAT FOLDL FOLDL2 FOLDR FRONT FST FUNPOW FUNSET GENLIST
  GENLIST_AUX GSPEC HD HOARE_SPEC I IDEM IMAGE IMPLODE IN INDEX_FIND
  INDEX_OF INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL
  INR INSERT INTER INVOL ISL ISR IS_EL IS_NONE IS_NUM_REP IS_PREFIX
  IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET Id IfCases K LAST LASTN
  LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND
  LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_TO_SET LLEX
  LRC LUPDATE LinearOrder MAP MAP2 MAX MAX_SET MEM MIN MIN_SET MOD MODEQ
  MONOID NIL NONE NOTIN NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND
  O ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND
  OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP
  OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP ORD OR_EL OUTL OUTR OWHILE
  Order PAD_LEFT PAD_RIGHT PERMUTES PI POW PRE PREFIX PREIMAGE PRIM_REC
  PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder RC RCOMPL
  RDOM RDOM_DELETE RELPOW REL_RESTRICT REMPTY REPLICATE REP_num REP_prod
  REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE
  RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER RINV RPROD RRANGE
  RRESTRICT RSUBSET RTC RUNION RUNIV S SC SCANL SCANR SEG SET_TO_LIST
  SIGMA SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME SOME_EL SPLITL
  SPLITP SPLITP_AUX SPLITR STR STRCAT STRING STRLEN STRORD SUB SUBSET
  SUBSTRING SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET
  SURJ SWAP StrongLinearOrder StrongOrder T TAKE TC THE TL TL_T TOCHAR
  TOKENS TRANSLATE TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP
  UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder
  WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number
  antisymmetric approx bool_size case char_ge char_gt char_le char_lt
  char_size chooser count countable dest_rec diag diamond dropWhile
  enumerate equiv_on equivalence findq iBIT_cases internal_mult inv
  inv_image invtri invtri0 irreflexive isAlpha isAlphaNum isAscii
  isCntrl isDigit isGraph isHexDigit isLower isPREFIX isPrint isPunct
  isSpace isUpper itself_case lift2 listRel list_CASE list_size
  literal_case measure mk_rec napp nat_elim__magic ncons nf nfoldl nfst
  nlen nlistrec nmap nnil npair nsnd nub num_CASE num_to_pair o one
  one_CASE one_size option_ABS option_CASE option_REP option_size
  pair_CASE pair_size pair_to_num pairwise partition rcdiamond reflexive
  schroeder_close set some splitAtPki stmarker string_ge string_gt
  string_le string_lt sum_CASE sum_size symmetric the_fun the_value
  toLower toUpper total transitive tri trichotomous tri unint univ
  wellfounded ~         
Overloading:
                     -> 
    (\(x :'a). list$CONS x (list$NIL :'a list))
    (\(h :'a) (l :'a list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (\(x :'a itself). univ((:'a) :'a itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <                  ->  < char_lt string_lt
  <<=                ->  (\(x :'a list) (y :'a list). list$isPREFIX x y)
  <=                 ->  <= char_le string_le
  <=/=>              ->  (\(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (\(x :'a) (y :'a). bool$~ (min$= x y))
  =+                 ->  UPDATE
  >                  ->  > char_gt string_gt
  >=                 ->  >= char_ge string_ge
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  CONCAT             ->  FLAT
  EMPTYSTRING        ->  NIL
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (\(s :'a -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (\(x :'a) (l :'a list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (\(x :'a list) (y :'a list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (\(x :'a) (l :'a list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              -> 
    (\(x :'a) (y :'a -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (\(f :'a -> 'a) (s :'a -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (\(x :'a). list$CONS x (list$NIL :'a list))
  SOME_EL            ->  EXISTS
  STRCAT             ->  APPEND
  STRING             ->  CONS
  STRLEN             ->  LENGTH
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri              ->  invtri
  univ               ->  (\(x :'a itself). univ((:'a) :'a itself))
                    ->  (\(x :num). arithmetic$EXP x (2n :num))
                    ->  (\(x :num). arithmetic$EXP x (3n :num))
                    ->  PROD_IMAGE
                    ->  EMPTY
                   ->  EMPTY_REL
                    ->  SUM_IMAGE
                    ->  (\(x :'a) (y :'a). bool$~ (min$= x y))
                    ->  (\(x :'a itself). univ((:'a) :'a itself))
                   ->  RUNIV
User printing functions:
  if (gd :bool) then (tr :'a) else (fl :'a)       ->  bool.COND
  LET (f :'a -> 'b) (x :'a)       ->  bool.LET
  univ((:'a) :'a itself)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val string_gt_def =
   |- !(s1 :string) (s2 :string). s1 > s2 <=> s2 < s1:
   thm
val string_le_def =
   |- !(s1 :string) (s2 :string). s1 <= s2 <=> (s1 = s2) \/ s1 < s2:
   thm
val string_lt_antisym =
   |- !(s :string) (t :string). ~(s < t /\ t < s):
   thm
val string_lt_cases =
   |- !(s :string) (t :string). (s = t) \/ s < t \/ t < s:
   thm
val string_lt_def =
   |- (!(s :string). s < ("" :string) <=> F) /\
   (!(s :string) (c :char). ("" :string) < STRING c s <=> T) /\
   !(s2 :string) (s1 :string) (c2 :char) (c1 :char).
     STRING c1 s1 < STRING c2 s2 <=> c1 < c2 \/ (c1 = c2) /\ s1 < s2:
   thm
val string_lt_ind =
   |- !(P :string -> string -> bool).
     (!(s :string). P s ("" :string)) /\
     (!(c :char) (s :string). P ("" :string) (STRING c s)) /\
     (!(c1 :char) (s1 :string) (c2 :char) (s2 :string).
        P s1 s2 ==> P (STRING c1 s1) (STRING c2 s2)) ==>
     !(v :string) (v1 :string). P v v1:
   thm
val string_lt_nonrefl =
   |- !(s :string). ~(s < s):
   thm
val string_lt_trans =
   |- !(s1 :string) (s2 :string) (s3 :string).
     s1 < s2 /\ s2 < s3 ==> s1 < s3:
   thm
val strip_case = fn: term -> term * (term * term) list
val symKey_11 =
   |- !(a :num) (a' :num). (sym a = sym a') <=> (a = a'):
   thm
val symKey_Axiom =
   |- !(f :num -> 'a). ?(fn :symKey -> 'a). !(a :num). fn (sym a) = f a:
   thm
val symKey_TY_DEF =
   |- ?(rep :symKey -> num recspace).
     TYPE_DEFINITION
       (\(a0 :num recspace).
          !('symKey'  :num recspace -> bool).
            (!(a0 :num recspace).
               (?(a :num).
                  a0 =
                  (\(a :num).
                     ind_type$CONSTR (0 :num) a
                       (\(n :num). (ind_type$BOTTOM :num recspace)))
                    a) ==>
               'symKey' a0) ==>
            'symKey' a0) rep:
   thm
val symKey_case_cong =
   |- !(M :symKey) (M' :symKey) (f :num -> 'a).
     (M = M') /\
     (!(a :num). (M' = sym a) ==> (f a = (f' :num -> 'a) a)) ==>
     ((symKey_CASE M f :'a) = (symKey_CASE M' f' :'a)):
   thm
val symKey_case_def =
   |- !(a :num) (f :num -> 'a). (symKey_CASE (sym a) f :'a) = f a:
   thm
val symKey_induction =
   |- !(P :symKey -> bool). (!(n :num). P (sym n)) ==> !(s :symKey). P s:
   thm
val symKey_nchotomy =
   |- !(ss :symKey). ?(n :num). ss = sym n:
   thm
val symKey_one_one =
   |- !(a :num) (a' :num). (sym a = sym a') <=> (a = a'):
   thm
val symKey_size_def =
   |- !(a :num). symKey_size (sym a) = (1 :num) + a:
   thm
val symMsg_11 =
   |- !(a0 :symKey) (a1 :'message option) (a0' :symKey)
      (a1' :'message option).
     (Es a0 a1 = Es a0' a1') <=> (a0 = a0') /\ (a1 = a1'):
   thm
val symMsg_Axiom =
   |- !(f :symKey -> 'message option -> 'a).
     ?(fn :'message symMsg -> 'a).
       !(a0 :symKey) (a1 :'message option). fn (Es a0 a1) = f a0 a1:
   thm
val symMsg_TY_DEF =
   |- ?(rep :'message symMsg -> (symKey # 'message option) recspace).
     TYPE_DEFINITION
       (\(a0' :(symKey # 'message option) recspace).
          !('symMsg'  :(symKey # 'message option) recspace -> bool).
            (!(a0' :(symKey # 'message option) recspace).
               (?(a0 :symKey) (a1 :'message option).
                  a0' =
                  (\(a0 :symKey) (a1 :'message option).
                     ind_type$CONSTR (0 :num) (a0,a1)
                       (\(n :num).
                          (ind_type$BOTTOM :(symKey # 'message option)
                                            recspace))) a0 a1) ==>
               'symMsg' a0') ==>
            'symMsg' a0') rep:
   thm
val symMsg_case_cong =
   |- !(M :'message symMsg) (M' :'message symMsg)
      (f :symKey -> 'message option -> 'a).
     (M = M') /\
     (!(a0 :symKey) (a1 :'message option).
        (M' = Es a0 a1) ==>
        (f a0 a1 = (f' :symKey -> 'message option -> 'a) a0 a1)) ==>
     ((symMsg_CASE M f :'a) = (symMsg_CASE M' f' :'a)):
   thm
val symMsg_case_def =
   |- !(a0 :symKey) (a1 :'message option)
      (f :symKey -> 'message option -> 'a).
     (symMsg_CASE (Es a0 a1) f :'a) = f a0 a1:
   thm
val symMsg_induction =
   |- !(P :'message symMsg -> bool).
     (!(s :symKey) ($o :'message option). P (Es s $o)) ==>
     !(s :'message symMsg). P s:
   thm
val symMsg_nchotomy =
   |- !(ss :'message symMsg).
     ?(s :symKey) ($o :'message option). ss = Es s $o:
   thm
val symMsg_one_one =
   |- !(a0 :symKey) (a1 :'message option) (a0' :symKey)
      (a1' :'message option).
     (Es a0 a1 = Es a0' a1') <=> (a0 = a0') /\ (a1 = a1'):
   thm
val symMsg_size_def =
   |- !(f :'message -> num) (a0 :symKey) (a1 :'message option).
     symMsg_size f (Es a0 a1) =
     (1 :num) + (symKey_size a0 + option_size f a1):
   thm
type tactic = Abbrev.tactic
eqtype term
val theTypeBase = fn: unit -> typeBase
type thm
type thm_tactic = Abbrev.thm_tactic
val toLower_def =
   |- !(c :char).
     toLower c = if isUpper c then CHR (ORD c + (32 :num)) else c:
   thm
val toUpper_def =
   |- !(c :char).
     toUpper c = if isLower c then CHR (ORD c - (32 :num)) else c:
   thm
type tyinfo
type typeBase
val updates_of = fn: hol_type -> thm list
val write = fn: tyinfo list -> tyinfo list
> 
> 
> val exercise15_6_1a_thm = 
TAC_PROOF(([],``!key enMsg message.(deciphS key enMsg = SOME message) <=>
(enMsg = Es key (SOME message))``),
PROVE_TAC[deciphS_one_one]
);
val _ = save_thm("exercise15_6_1a_thm", exercise15_6_1a_thm);

# # # # <<HOL message: inventing new type variable names: 'a>>
Meson search level: ..........
val exercise15_6_1a_thm =
   |- !(key :symKey) (enMsg :'a symMsg) (message :'a).
     (deciphS key enMsg = SOME message) <=>
     (enMsg = Es key (SOME message)):
   thm
> > > 
> 
> val exercise15_6_1b_thm =
TAC_PROOF(([],``!keyAlice k text.(deciphS keyAlice (Es k (SOME text)) = SOME "This is from Alice")<=> ((k = keyAlice) /\ (text = "This is from Alice"))``),
PROVE_TAC[deciphS_one_one]
);
val _ = save_thm("exercise15_6_1b_thm", exercise15_6_1b_thm);

# # # Meson search level: ......................
val exercise15_6_1b_thm =
   |- !(keyAlice :symKey) (k :symKey) (text :string).
     (deciphS keyAlice (Es k (SOME text)) =
      SOME "This is from Alice") <=>
     (k = keyAlice) /\ (text = "This is from Alice"):
   thm
> > > 
> 
> 
> 
> 
> val exercise15_6_2a_thm =
TAC_PROOF(([],``!P message.(deciphP (pubK P) enMsg = SOME message) <=>
(enMsg = Ea (privK P) (SOME message))``),
PROVE_TAC[deciphP_one_one]
);
val _ = save_thm("exercise15_6_2a_thm", exercise15_6_2a_thm);

# # # # <<HOL message: inventing new type variable names: 'a, 'b>>
Meson search level: ..........
val exercise15_6_2a_thm =
   |- !(P :'a) (message :'b).
     (deciphP (pubK P) (enMsg :('b, 'a) asymMsg) = SOME message) <=>
     (enMsg = Ea (privK P) (SOME message)):
   thm
> > > 
> 
> 
> 
> 
> 
val exercise15_6_2b_thm =
TAC_PROOF(([],``!key text.(deciphP (pubK Alice) (Ea key (SOME text)) = SOME "This is from Alice")<=> (key = privK Alice) /\ (text = "This is from Alice")``),
PROVE_TAC[deciphP_one_one]
);
val _ = save_thm("exercise15_6_2b_thm", exercise15_6_2b_thm);

> # # # <<HOL message: inventing new type variable names: 'a>>
Meson search level: ......................
val exercise15_6_2b_thm =
   |- !(key :'a pKey) (text :string).
     (deciphP (pubK (Alice :'a)) (Ea key (SOME text)) =
      SOME "This is from Alice") <=>
     (key = privK Alice) /\ (text = "This is from Alice"):
   thm
> > > 
> 
> 
> 
> 
val exercise15_6_3_thm =
TAC_PROOF(([],``!signature.signVerify (pubK Alice) signature (SOME "This is from Alice")<=> (signature = sign (privK Alice) (hash (SOME "This is from Alice")))``),
PROVE_TAC[signVerify_one_one]
);
val _ = save_thm("exercise15_6_3_thm", exercise15_6_3_thm);

> # # # <<HOL message: inventing new type variable names: 'a>>
Meson search level: ..........
val exercise15_6_3_thm =
   |- !(signature :(string digest, 'a) asymMsg).
     signVerify (pubK (Alice :'a)) signature
       (SOME "This is from Alice") <=>
     (signature = sign (privK Alice) (hash (SOME "This is from Alice"))):
   thm
> > > 
> 
> 
Process HOL finished
