/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:88: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:125: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:162: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:250: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f1_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1245: warning: Matches are not exhaustive. Found near fn [th1, th2] => ACL_CONJ th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1276: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ1 disj2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1304: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ2 disj1 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1336: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1337: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1340: warning: Matches are not exhaustive. Found near fn [th] => ACL_MP th2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1374: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1408: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1440: warning: Matches are not exhaustive. Found near fn [th1, th2] => CONTROLS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1473: warning: Matches are not exhaustive. Found near fn [th1, th2] => DC th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1506: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMI_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1541: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMS_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1575: warning: Matches are not exhaustive. Found near fn [th1, th2] => HS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1601: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1602: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1604: warning: Pattern is not exhaustive.
Found near val (_, [proptype, ...]) = dest_type formType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1643: warning: Matches are not exhaustive.
Found near fn [th1, th2, th3] => IL_DOMI th2 th1 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1679: warning: Matches are not exhaustive.
Found near fn [th1, th2] => MONO_SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1709: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1710: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1745: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1776: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1810: warning: Matches are not exhaustive. Found near fn [th1, th2, th3] => REPS th1 th2 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1842: warning: Matches are not exhaustive. Found near fn [th1, th2] => REP_SAYS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1869: warning: Matches are not exhaustive. Found near fn [th] => SAYS princ th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1901: warning: Matches are not exhaustive. Found near fn [th1, th2] => SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1934: warning: Matches are not exhaustive.
Found near fn [th1, th2] => TRANS_SPEAKS_FOR th1 th2
<<HOL message: Created theory "SM0">>
Saved theorem _____ "num2privcmd_privcmd2num"
Saved theorem _____ "privcmd2num_num2privcmd"
Saved theorem _____ "num2privcmd_11"
Saved theorem _____ "privcmd2num_11"
Saved theorem _____ "num2privcmd_ONTO"
Saved theorem _____ "privcmd2num_ONTO"
Saved theorem _____ "num2privcmd_thm"
Saved theorem _____ "privcmd2num_thm"
Saved theorem _____ "privcmd_EQ_privcmd"
Saved theorem _____ "privcmd_case_def"
Saved theorem _____ "datatype_privcmd"
Saved theorem _____ "privcmd_distinct"
Saved theorem _____ "privcmd_case_cong"
Saved theorem _____ "privcmd_nchotomy"
Saved theorem _____ "privcmd_Axiom"
Saved theorem _____ "privcmd_induction"
<<HOL message: Defined type: "privcmd">>
Saved theorem _____ "privcmd_distinct_clauses"
Saved theorem _____ "num2npriv_npriv2num"
Saved theorem _____ "npriv2num_num2npriv"
Saved theorem _____ "num2npriv_11"
Saved theorem _____ "npriv2num_11"
Saved theorem _____ "num2npriv_ONTO"
Saved theorem _____ "npriv2num_ONTO"
Saved theorem _____ "num2npriv_thm"
Saved theorem _____ "npriv2num_thm"
Saved theorem _____ "npriv_EQ_npriv"
Saved theorem _____ "npriv_case_def"
Saved theorem _____ "datatype_npriv"
Saved theorem _____ "npriv_case_cong"
Saved theorem _____ "npriv_nchotomy"
Saved theorem _____ "npriv_Axiom"
Saved theorem _____ "npriv_induction"
<<HOL message: Defined type: "npriv">>
Saved theorem _____ "datatype_command"
Saved theorem _____ "command_11"
Saved theorem _____ "command_distinct"
Saved theorem _____ "command_case_cong"
Saved theorem _____ "command_nchotomy"
Saved theorem _____ "command_Axiom"
Saved theorem _____ "command_induction"
<<HOL message: Defined type: "command">>
Saved theorem _____ "command_distinct_clauses"
Saved theorem _____ "command_one_one"
Saved theorem _____ "num2state_state2num"
Saved theorem _____ "state2num_num2state"
Saved theorem _____ "num2state_11"
Saved theorem _____ "state2num_11"
Saved theorem _____ "num2state_ONTO"
Saved theorem _____ "state2num_ONTO"
Saved theorem _____ "num2state_thm"
Saved theorem _____ "state2num_thm"
Saved theorem _____ "state_EQ_state"
Saved theorem _____ "state_case_def"
Saved theorem _____ "datatype_state"
Saved theorem _____ "state_distinct"
Saved theorem _____ "state_case_cong"
Saved theorem _____ "state_nchotomy"
Saved theorem _____ "state_Axiom"
Saved theorem _____ "state_induction"
<<HOL message: Defined type: "state">>
Saved theorem _____ "state_distinct_clauses"
Saved theorem _____ "num2output_output2num"
Saved theorem _____ "output2num_num2output"
Saved theorem _____ "num2output_11"
Saved theorem _____ "output2num_11"
Saved theorem _____ "num2output_ONTO"
Saved theorem _____ "output2num_ONTO"
Saved theorem _____ "num2output_thm"
Saved theorem _____ "output2num_thm"
Saved theorem _____ "output_EQ_output"
Saved theorem _____ "output_case_def"
Saved theorem _____ "datatype_output"
Saved theorem _____ "output_distinct"
Saved theorem _____ "output_case_cong"
Saved theorem _____ "output_nchotomy"
Saved theorem _____ "output_Axiom"
Saved theorem _____ "output_induction"
<<HOL message: Defined type: "output">>
Saved theorem _____ "output_distinct_clauses"
<<HOL warning: GrammarDeltas.revise_data: 
  Grammar-deltas:
    overload_on("SM0ns_tupled")
  invalidated by DelConstant(SM0$SM0ns_tupled)>>
Saved definition __ "SM0ns_def"
Saved induction ___ "SM0ns_ind"
<<HOL warning: GrammarDeltas.revise_data: 
  Grammar-deltas:
    overload_on("SM0out_tupled")
  invalidated by DelConstant(SM0$SM0out_tupled)>>
Saved definition __ "SM0out_def"
Saved induction ___ "SM0out_ind"
Saved theorem _____ "num2staff_staff2num"
Saved theorem _____ "staff2num_num2staff"
Saved theorem _____ "num2staff_11"
Saved theorem _____ "staff2num_11"
Saved theorem _____ "num2staff_ONTO"
Saved theorem _____ "staff2num_ONTO"
Saved theorem _____ "num2staff_thm"
Saved theorem _____ "staff2num_thm"
Saved theorem _____ "staff_EQ_staff"
Saved theorem _____ "staff_case_def"
Saved theorem _____ "datatype_staff"
Saved theorem _____ "staff_distinct"
Saved theorem _____ "staff_case_cong"
Saved theorem _____ "staff_nchotomy"
Saved theorem _____ "staff_Axiom"
Saved theorem _____ "staff_induction"
<<HOL message: Defined type: "staff">>
Saved theorem _____ "staff_distinct_clauses"
<<HOL message: mk_functional: 
  pattern completion has added 39 clauses to the original specification.>>
Saved definition __ "inputOK_def"
Saved induction ___ "inputOK_ind"
Saved definition __ "SM0StateInterp_def"
Saved definition __ "certs_def"
Saved theorem _____ "Carol_rejected_lemma"
Saved theorem _____ "Carol_discard_lemma"
Saved theorem _____ "Alice_privcmd_lemma"
Saved theorem _____ "Alice_exec_privcmd_justified_thm"
Saved theorem _____ "Alice_privcmd_verified_thm"
Saved theorem _____ "Alice_justified_privcmd_exec_thm"
Exporting theory "SM0" ... done.
Theory "SM0" took 2.5s to build
Theory: SM0

Parents:
    ssm1

Type constants:
    command 0
    npriv 0
    output 0
    privcmd 0
    staff 0
    state 0

Term constants:
    ACTIVE           :state
    Alice            :staff
    Bob              :staff
    Carol            :staff
    NP               :npriv -> command
    PR               :privcmd -> command
    SM0StateInterp   :state -> (command inst, staff, δ, ε) Form
    SM0ns            :state -> command trType -> state
    SM0out           :state -> command trType -> output
    STBY             :state
    certs            :command ->
                      npriv ->
                      privcmd -> (command inst, staff, δ, ε) Form list
    command_CASE     :command -> (npriv -> α) -> (privcmd -> α) -> α
    command_size     :command -> num
    inputOK          :(command inst, staff, δ, ε) Form -> bool
    launch           :privcmd
    npriv2num        :npriv -> num
    npriv_CASE       :npriv -> α -> α
    npriv_size       :npriv -> num
    num2npriv        :num -> npriv
    num2output       :num -> output
    num2privcmd      :num -> privcmd
    num2staff        :num -> staff
    num2state        :num -> state
    off              :output
    on               :output
    output2num       :output -> num
    output_CASE      :output -> α -> α -> α
    output_size      :output -> num
    privcmd2num      :privcmd -> num
    privcmd_CASE     :privcmd -> α -> α -> α
    privcmd_size     :privcmd -> num
    reset            :privcmd
    staff2num        :staff -> num
    staff_CASE       :staff -> α -> α -> α -> α
    staff_size       :staff -> num
    state2num        :state -> num
    state_CASE       :state -> α -> α -> α
    state_size       :state -> num
    status           :npriv

Definitions:
    @tempACTIVE_def
      |- ACTIVE = num2state 1
    @tempAlice_def
      |- Alice = num2staff 0
    @tempBob_def
      |- Bob = num2staff 1
    @tempCarol_def
      |- Carol = num2staff 2
    @tempSTBY_def
      |- STBY = num2state 0
    @templaunch_def
      |- launch = num2privcmd 0
    @tempoff_def
      |- off = num2output 1
    @tempon_def
      |- on = num2output 0
    @tempreset_def
      |- reset = num2privcmd 1
    @tempstatus_def
      |- status = num2npriv 0
    SM0StateInterp_def
      |- ∀state. SM0StateInterp state = TT
    certs_def
      |- ∀cmd npriv privcmd.
           certs cmd npriv privcmd =
           [Name Alice controls prop (SOME (NP npriv));
            Name Alice controls prop (SOME (PR privcmd));
            Name Bob controls prop (SOME (NP npriv));
            Name Bob says prop (SOME (PR privcmd)) impf prop NONE]
    command_TY_DEF
      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'command' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR 0 (a,ARB)
                             (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC 0) (ARB,a)
                             (λn. ind_type$BOTTOM)) a) ⇒
                     'command' a0) ⇒
                  'command' a0) rep
    command_case_def
      |- (∀a f f1. command_CASE (NP a) f f1 = f a) ∧
         ∀a f f1. command_CASE (PR a) f f1 = f1 a
    command_size_def
      |- (∀a. command_size (NP a) = 1 + npriv_size a) ∧
         ∀a. command_size (PR a) = 1 + privcmd_size a
    inputOK_primitive_def
      |- inputOK =
         WFREC (@R. WF R)
           (λinputOK a.
              case a of
                TT => I F
              | FF => I F
              | prop v33 => I F
              | notf v34 => I F
              | v35 andf v36 => I F
              | v37 orf v38 => I F
              | v39 impf v40 => I F
              | v41 eqf v42 => I F
              | v43 says TT => I F
              | v43 says FF => I F
              | Name Alice says prop (SOME cmd) => I T
              | Name Bob says prop (SOME cmd) => I T
              | Name Carol says prop (SOME cmd) => I F
              | Name v137 says prop NONE => I F
              | v138 meet v139 says prop v99 => I F
              | v140 quoting v141 says prop v99 => I F
              | v43 says notf v100 => I F
              | v43 says (v101 andf v102) => I F
              | v43 says (v103 orf v104) => I F
              | v43 says (v105 impf v106) => I F
              | v43 says (v107 eqf v108) => I F
              | v43 says v109 says v110 => I F
              | v43 says v111 speaks_for v112 => I F
              | v43 says v113 controls v114 => I F
              | v43 says reps v115 v116 v117 => I F
              | v43 says v118 domi v119 => I F
              | v43 says v120 eqi v121 => I F
              | v43 says v122 doms v123 => I F
              | v43 says v124 eqs v125 => I F
              | v43 says v126 eqn v127 => I F
              | v43 says v128 lte v129 => I F
              | v43 says v130 lt v131 => I F
              | v45 speaks_for v46 => I F
              | v47 controls v48 => I F
              | reps v49 v50 v51 => I F
              | v52 domi v53 => I F
              | v54 eqi v55 => I F
              | v56 doms v57 => I F
              | v58 eqs v59 => I F
              | v60 eqn v61 => I F
              | v62 lte v63 => I F
              | v64 lt v65 => I F)
    npriv_BIJ
      |- (∀a. num2npriv (npriv2num a) = a) ∧
         ∀r. (λn. n < 1) r ⇔ (npriv2num (num2npriv r) = r)
    npriv_CASE
      |- ∀x v0. (case x of status => v0) = (λm. v0) (npriv2num x)
    npriv_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 1) rep
    npriv_size_def
      |- ∀x. npriv_size x = 0
    output_BIJ
      |- (∀a. num2output (output2num a) = a) ∧
         ∀r. (λn. n < 2) r ⇔ (output2num (num2output r) = r)
    output_CASE
      |- ∀x v0 v1.
           (case x of on => v0 | off => v1) =
           (λm. if m = 0 then v0 else v1) (output2num x)
    output_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 2) rep
    output_size_def
      |- ∀x. output_size x = 0
    privcmd_BIJ
      |- (∀a. num2privcmd (privcmd2num a) = a) ∧
         ∀r. (λn. n < 2) r ⇔ (privcmd2num (num2privcmd r) = r)
    privcmd_CASE
      |- ∀x v0 v1.
           (case x of launch => v0 | reset => v1) =
           (λm. if m = 0 then v0 else v1) (privcmd2num x)
    privcmd_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 2) rep
    privcmd_size_def
      |- ∀x. privcmd_size x = 0
    staff_BIJ
      |- (∀a. num2staff (staff2num a) = a) ∧
         ∀r. (λn. n < 3) r ⇔ (staff2num (num2staff r) = r)
    staff_CASE
      |- ∀x v0 v1 v2.
           (case x of Alice => v0 | Bob => v1 | Carol => v2) =
           (λm. if m < 1 then v0 else if m = 1 then v1 else v2)
             (staff2num x)
    staff_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 3) rep
    staff_size_def
      |- ∀x. staff_size x = 0
    state_BIJ
      |- (∀a. num2state (state2num a) = a) ∧
         ∀r. (λn. n < 2) r ⇔ (state2num (num2state r) = r)
    state_CASE
      |- ∀x v0 v1.
           (case x of STBY => v0 | ACTIVE => v1) =
           (λm. if m = 0 then v0 else v1) (state2num x)
    state_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 2) rep
    state_size_def
      |- ∀x. state_size x = 0

Theorems:
    Alice_exec_privcmd_justified_thm
      |- ∀NS Out M Oi Os.
           TR (M,Oi,Os) (exec (PR privcmd))
             (CFG inputOK SM0StateInterp (certs cmd npriv privcmd)
                (Name Alice says prop (SOME (PR privcmd))::ins) s outs)
             (CFG inputOK SM0StateInterp (certs cmd npriv privcmd) ins
                (NS s (exec (PR privcmd)))
                (Out s (exec (PR privcmd))::outs)) ⇔
           inputOK (Name Alice says prop (SOME (PR privcmd))) ∧
           CFGInterpret (M,Oi,Os)
             (CFG inputOK SM0StateInterp (certs cmd npriv privcmd)
                (Name Alice says prop (SOME (PR privcmd))::ins) s
                outs) ∧ (M,Oi,Os) sat prop (SOME (PR privcmd))
    Alice_justified_privcmd_exec_thm
      |- ∀NS Out M Oi Os cmd npriv privcmd ins s outs.
           inputOK (Name Alice says prop (SOME (PR privcmd))) ∧
           CFGInterpret (M,Oi,Os)
             (CFG inputOK SM0StateInterp (certs cmd npriv privcmd)
                (Name Alice says prop (SOME (PR privcmd))::ins) s
                outs) ⇒
           TR (M,Oi,Os) (exec (PR privcmd))
             (CFG inputOK SM0StateInterp (certs cmd npriv privcmd)
                (Name Alice says prop (SOME (PR privcmd))::ins) s outs)
             (CFG inputOK SM0StateInterp (certs cmd npriv privcmd) ins
                (NS s (exec (PR privcmd)))
                (Out s (exec (PR privcmd))::outs))
    Alice_privcmd_lemma
      |- CFGInterpret (M,Oi,Os)
           (CFG inputOK SM0StateInterp (certs cmd npriv privcmd)
              (Name Alice says prop (SOME (PR privcmd))::ins) s outs) ⇒
         (M,Oi,Os) sat prop (SOME (PR privcmd))
    Alice_privcmd_verified_thm
      |- ∀NS Out M Oi Os.
           TR (M,Oi,Os) (exec (PR privcmd))
             (CFG inputOK SM0StateInterp (certs cmd npriv privcmd)
                (Name Alice says prop (SOME (PR privcmd))::ins) s outs)
             (CFG inputOK SM0StateInterp (certs cmd npriv privcmd) ins
                (NS s (exec (PR privcmd)))
                (Out s (exec (PR privcmd))::outs)) ⇒
           (M,Oi,Os) sat prop (SOME (PR privcmd))
    Carol_discard_lemma
      |- TR (M,Oi,Os) discard
           (CFG inputOK SM0StateInterp (certs cmd npriv privcmd)
              (Name Carol says prop (SOME cmd)::ins) s outs)
           (CFG inputOK SM0StateInterp (certs cmd npriv privcmd) ins
              (SM0ns s discard) (SM0out s discard::outs))
    Carol_rejected_lemma
      |- ¬inputOK (Name Carol says prop (SOME cmd))
    SM0ns_def
      |- (SM0ns STBY (exec (PR reset)) = STBY) ∧
         (SM0ns STBY (exec (PR launch)) = ACTIVE) ∧
         (SM0ns STBY (exec (NP status)) = STBY) ∧
         (SM0ns ACTIVE (exec (PR reset)) = STBY) ∧
         (SM0ns ACTIVE (exec (PR launch)) = ACTIVE) ∧
         (SM0ns ACTIVE (exec (NP status)) = ACTIVE) ∧
         (SM0ns STBY (trap (PR reset)) = STBY) ∧
         (SM0ns STBY (trap (PR launch)) = STBY) ∧
         (SM0ns STBY (trap (NP status)) = STBY) ∧
         (SM0ns ACTIVE (trap (PR reset)) = ACTIVE) ∧
         (SM0ns ACTIVE (trap (PR launch)) = ACTIVE) ∧
         (SM0ns ACTIVE (trap (NP status)) = ACTIVE) ∧
         (SM0ns STBY discard = STBY) ∧ (SM0ns ACTIVE discard = ACTIVE)
    SM0ns_ind
      |- ∀P.
           P STBY (exec (PR reset)) ∧ P STBY (exec (PR launch)) ∧
           P STBY (exec (NP status)) ∧ P ACTIVE (exec (PR reset)) ∧
           P ACTIVE (exec (PR launch)) ∧ P ACTIVE (exec (NP status)) ∧
           P STBY (trap (PR reset)) ∧ P STBY (trap (PR launch)) ∧
           P STBY (trap (NP status)) ∧ P ACTIVE (trap (PR reset)) ∧
           P ACTIVE (trap (PR launch)) ∧ P ACTIVE (trap (NP status)) ∧
           P STBY discard ∧ P ACTIVE discard ⇒
           ∀v v1. P v v1
    SM0out_def
      |- (SM0out STBY (exec (PR reset)) = off) ∧
         (SM0out STBY (exec (PR launch)) = on) ∧
         (SM0out STBY (exec (NP status)) = off) ∧
         (SM0out ACTIVE (exec (PR reset)) = off) ∧
         (SM0out ACTIVE (exec (PR launch)) = on) ∧
         (SM0out ACTIVE (exec (NP status)) = on) ∧
         (SM0out STBY (trap (PR reset)) = off) ∧
         (SM0out STBY (trap (PR launch)) = off) ∧
         (SM0out STBY (trap (NP status)) = off) ∧
         (SM0out ACTIVE (trap (PR reset)) = on) ∧
         (SM0out ACTIVE (trap (PR launch)) = on) ∧
         (SM0out ACTIVE (trap (NP status)) = on) ∧
         (SM0out STBY discard = off) ∧ (SM0out ACTIVE discard = on)
    SM0out_ind
      |- ∀P.
           P STBY (exec (PR reset)) ∧ P STBY (exec (PR launch)) ∧
           P STBY (exec (NP status)) ∧ P ACTIVE (exec (PR reset)) ∧
           P ACTIVE (exec (PR launch)) ∧ P ACTIVE (exec (NP status)) ∧
           P STBY (trap (PR reset)) ∧ P STBY (trap (PR launch)) ∧
           P STBY (trap (NP status)) ∧ P ACTIVE (trap (PR reset)) ∧
           P ACTIVE (trap (PR launch)) ∧ P ACTIVE (trap (NP status)) ∧
           P STBY discard ∧ P ACTIVE discard ⇒
           ∀v v1. P v v1
    command_11
      |- (∀a a'. (NP a = NP a') ⇔ (a = a')) ∧
         ∀a a'. (PR a = PR a') ⇔ (a = a')
    command_Axiom
      |- ∀f0 f1. ∃fn. (∀a. fn (NP a) = f0 a) ∧ ∀a. fn (PR a) = f1 a
    command_case_cong
      |- ∀M M' f f1.
           (M = M') ∧ (∀a. (M' = NP a) ⇒ (f a = f' a)) ∧
           (∀a. (M' = PR a) ⇒ (f1 a = f1' a)) ⇒
           (command_CASE M f f1 = command_CASE M' f' f1')
    command_distinct
      |- ∀a' a. NP a ≠ PR a'
    command_distinct_clauses
      |- ∀a' a. NP a ≠ PR a'
    command_induction
      |- ∀P. (∀n. P (NP n)) ∧ (∀p. P (PR p)) ⇒ ∀c. P c
    command_nchotomy
      |- ∀cc. (∃n. cc = NP n) ∨ ∃p. cc = PR p
    command_one_one
      |- (∀a a'. (NP a = NP a') ⇔ (a = a')) ∧
         ∀a a'. (PR a = PR a') ⇔ (a = a')
    datatype_command
      |- DATATYPE (command NP PR)
    datatype_npriv
      |- DATATYPE (npriv status)
    datatype_output
      |- DATATYPE (output on off)
    datatype_privcmd
      |- DATATYPE (privcmd launch reset)
    datatype_staff
      |- DATATYPE (staff Alice Bob Carol)
    datatype_state
      |- DATATYPE (state STBY ACTIVE)
    inputOK_def
      |- (inputOK (Name Alice says prop (SOME cmd)) ⇔ T) ∧
         (inputOK (Name Bob says prop (SOME cmd)) ⇔ T) ∧
         (inputOK TT ⇔ F) ∧ (inputOK FF ⇔ F) ∧ (inputOK (prop v) ⇔ F) ∧
         (inputOK (notf v1) ⇔ F) ∧ (inputOK (v2 andf v3) ⇔ F) ∧
         (inputOK (v4 orf v5) ⇔ F) ∧ (inputOK (v6 impf v7) ⇔ F) ∧
         (inputOK (v8 eqf v9) ⇔ F) ∧ (inputOK (v10 says TT) ⇔ F) ∧
         (inputOK (v10 says FF) ⇔ F) ∧
         (inputOK (Name Carol says prop (SOME v142)) ⇔ F) ∧
         (inputOK (Name v132 says prop NONE) ⇔ F) ∧
         (inputOK (v133 meet v134 says prop v66) ⇔ F) ∧
         (inputOK (v135 quoting v136 says prop v66) ⇔ F) ∧
         (inputOK (v10 says notf v67) ⇔ F) ∧
         (inputOK (v10 says (v68 andf v69)) ⇔ F) ∧
         (inputOK (v10 says (v70 orf v71)) ⇔ F) ∧
         (inputOK (v10 says (v72 impf v73)) ⇔ F) ∧
         (inputOK (v10 says (v74 eqf v75)) ⇔ F) ∧
         (inputOK (v10 says v76 says v77) ⇔ F) ∧
         (inputOK (v10 says v78 speaks_for v79) ⇔ F) ∧
         (inputOK (v10 says v80 controls v81) ⇔ F) ∧
         (inputOK (v10 says reps v82 v83 v84) ⇔ F) ∧
         (inputOK (v10 says v85 domi v86) ⇔ F) ∧
         (inputOK (v10 says v87 eqi v88) ⇔ F) ∧
         (inputOK (v10 says v89 doms v90) ⇔ F) ∧
         (inputOK (v10 says v91 eqs v92) ⇔ F) ∧
         (inputOK (v10 says v93 eqn v94) ⇔ F) ∧
         (inputOK (v10 says v95 lte v96) ⇔ F) ∧
         (inputOK (v10 says v97 lt v98) ⇔ F) ∧
         (inputOK (v12 speaks_for v13) ⇔ F) ∧
         (inputOK (v14 controls v15) ⇔ F) ∧
         (inputOK (reps v16 v17 v18) ⇔ F) ∧
         (inputOK (v19 domi v20) ⇔ F) ∧ (inputOK (v21 eqi v22) ⇔ F) ∧
         (inputOK (v23 doms v24) ⇔ F) ∧ (inputOK (v25 eqs v26) ⇔ F) ∧
         (inputOK (v27 eqn v28) ⇔ F) ∧ (inputOK (v29 lte v30) ⇔ F) ∧
         (inputOK (v31 lt v32) ⇔ F)
    inputOK_ind
      |- ∀P.
           (∀cmd. P (Name Alice says prop (SOME cmd))) ∧
           (∀cmd. P (Name Bob says prop (SOME cmd))) ∧ P TT ∧ P FF ∧
           (∀v. P (prop v)) ∧ (∀v1. P (notf v1)) ∧
           (∀v2 v3. P (v2 andf v3)) ∧ (∀v4 v5. P (v4 orf v5)) ∧
           (∀v6 v7. P (v6 impf v7)) ∧ (∀v8 v9. P (v8 eqf v9)) ∧
           (∀v10. P (v10 says TT)) ∧ (∀v10. P (v10 says FF)) ∧
           (∀v142. P (Name Carol says prop (SOME v142))) ∧
           (∀v132. P (Name v132 says prop NONE)) ∧
           (∀v133 v134 v66. P (v133 meet v134 says prop v66)) ∧
           (∀v135 v136 v66. P (v135 quoting v136 says prop v66)) ∧
           (∀v10 v67. P (v10 says notf v67)) ∧
           (∀v10 v68 v69. P (v10 says (v68 andf v69))) ∧
           (∀v10 v70 v71. P (v10 says (v70 orf v71))) ∧
           (∀v10 v72 v73. P (v10 says (v72 impf v73))) ∧
           (∀v10 v74 v75. P (v10 says (v74 eqf v75))) ∧
           (∀v10 v76 v77. P (v10 says v76 says v77)) ∧
           (∀v10 v78 v79. P (v10 says v78 speaks_for v79)) ∧
           (∀v10 v80 v81. P (v10 says v80 controls v81)) ∧
           (∀v10 v82 v83 v84. P (v10 says reps v82 v83 v84)) ∧
           (∀v10 v85 v86. P (v10 says v85 domi v86)) ∧
           (∀v10 v87 v88. P (v10 says v87 eqi v88)) ∧
           (∀v10 v89 v90. P (v10 says v89 doms v90)) ∧
           (∀v10 v91 v92. P (v10 says v91 eqs v92)) ∧
           (∀v10 v93 v94. P (v10 says v93 eqn v94)) ∧
           (∀v10 v95 v96. P (v10 says v95 lte v96)) ∧
           (∀v10 v97 v98. P (v10 says v97 lt v98)) ∧
           (∀v12 v13. P (v12 speaks_for v13)) ∧
           (∀v14 v15. P (v14 controls v15)) ∧
           (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
           (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
           (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
           (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
           (∀v31 v32. P (v31 lt v32)) ⇒
           ∀v. P v
    npriv2num_11
      |- ∀a a'. (npriv2num a = npriv2num a') ⇔ (a = a')
    npriv2num_ONTO
      |- ∀r. r < 1 ⇔ ∃a. r = npriv2num a
    npriv2num_num2npriv
      |- ∀r. r < 1 ⇔ (npriv2num (num2npriv r) = r)
    npriv2num_thm
      |- npriv2num status = 0
    npriv_Axiom
      |- ∀x0. ∃f. f status = x0
    npriv_EQ_npriv
      |- ∀a a'. (a = a') ⇔ (npriv2num a = npriv2num a')
    npriv_case_cong
      |- ∀M M' v0.
           (M = M') ∧ ((M' = status) ⇒ (v0 = v0')) ⇒
           ((case M of status => v0) = case M' of status => v0')
    npriv_case_def
      |- ∀v0. (case status of status => v0) = v0
    npriv_induction
      |- ∀P. P status ⇒ ∀a. P a
    npriv_nchotomy
      |- ∀a. a = status
    num2npriv_11
      |- ∀r r'.
           r < 1 ⇒ r' < 1 ⇒ ((num2npriv r = num2npriv r') ⇔ (r = r'))
    num2npriv_ONTO
      |- ∀a. ∃r. (a = num2npriv r) ∧ r < 1
    num2npriv_npriv2num
      |- ∀a. num2npriv (npriv2num a) = a
    num2npriv_thm
      |- num2npriv 0 = status
    num2output_11
      |- ∀r r'.
           r < 2 ⇒ r' < 2 ⇒ ((num2output r = num2output r') ⇔ (r = r'))
    num2output_ONTO
      |- ∀a. ∃r. (a = num2output r) ∧ r < 2
    num2output_output2num
      |- ∀a. num2output (output2num a) = a
    num2output_thm
      |- (num2output 0 = on) ∧ (num2output 1 = off)
    num2privcmd_11
      |- ∀r r'.
           r < 2 ⇒
           r' < 2 ⇒
           ((num2privcmd r = num2privcmd r') ⇔ (r = r'))
    num2privcmd_ONTO
      |- ∀a. ∃r. (a = num2privcmd r) ∧ r < 2
    num2privcmd_privcmd2num
      |- ∀a. num2privcmd (privcmd2num a) = a
    num2privcmd_thm
      |- (num2privcmd 0 = launch) ∧ (num2privcmd 1 = reset)
    num2staff_11
      |- ∀r r'.
           r < 3 ⇒ r' < 3 ⇒ ((num2staff r = num2staff r') ⇔ (r = r'))
    num2staff_ONTO
      |- ∀a. ∃r. (a = num2staff r) ∧ r < 3
    num2staff_staff2num
      |- ∀a. num2staff (staff2num a) = a
    num2staff_thm
      |- (num2staff 0 = Alice) ∧ (num2staff 1 = Bob) ∧
         (num2staff 2 = Carol)
    num2state_11
      |- ∀r r'.
           r < 2 ⇒ r' < 2 ⇒ ((num2state r = num2state r') ⇔ (r = r'))
    num2state_ONTO
      |- ∀a. ∃r. (a = num2state r) ∧ r < 2
    num2state_state2num
      |- ∀a. num2state (state2num a) = a
    num2state_thm
      |- (num2state 0 = STBY) ∧ (num2state 1 = ACTIVE)
    output2num_11
      |- ∀a a'. (output2num a = output2num a') ⇔ (a = a')
    output2num_ONTO
      |- ∀r. r < 2 ⇔ ∃a. r = output2num a
    output2num_num2output
      |- ∀r. r < 2 ⇔ (output2num (num2output r) = r)
    output2num_thm
      |- (output2num on = 0) ∧ (output2num off = 1)
    output_Axiom
      |- ∀x0 x1. ∃f. (f on = x0) ∧ (f off = x1)
    output_EQ_output
      |- ∀a a'. (a = a') ⇔ (output2num a = output2num a')
    output_case_cong
      |- ∀M M' v0 v1.
           (M = M') ∧ ((M' = on) ⇒ (v0 = v0')) ∧
           ((M' = off) ⇒ (v1 = v1')) ⇒
           ((case M of on => v0 | off => v1) =
            case M' of on => v0' | off => v1')
    output_case_def
      |- (∀v0 v1. (case on of on => v0 | off => v1) = v0) ∧
         ∀v0 v1. (case off of on => v0 | off => v1) = v1
    output_distinct
      |- on ≠ off
    output_distinct_clauses
      |- on ≠ off
    output_induction
      |- ∀P. P off ∧ P on ⇒ ∀a. P a
    output_nchotomy
      |- ∀a. (a = on) ∨ (a = off)
    privcmd2num_11
      |- ∀a a'. (privcmd2num a = privcmd2num a') ⇔ (a = a')
    privcmd2num_ONTO
      |- ∀r. r < 2 ⇔ ∃a. r = privcmd2num a
    privcmd2num_num2privcmd
      |- ∀r. r < 2 ⇔ (privcmd2num (num2privcmd r) = r)
    privcmd2num_thm
      |- (privcmd2num launch = 0) ∧ (privcmd2num reset = 1)
    privcmd_Axiom
      |- ∀x0 x1. ∃f. (f launch = x0) ∧ (f reset = x1)
    privcmd_EQ_privcmd
      |- ∀a a'. (a = a') ⇔ (privcmd2num a = privcmd2num a')
    privcmd_case_cong
      |- ∀M M' v0 v1.
           (M = M') ∧ ((M' = launch) ⇒ (v0 = v0')) ∧
           ((M' = reset) ⇒ (v1 = v1')) ⇒
           ((case M of launch => v0 | reset => v1) =
            case M' of launch => v0' | reset => v1')
    privcmd_case_def
      |- (∀v0 v1. (case launch of launch => v0 | reset => v1) = v0) ∧
         ∀v0 v1. (case reset of launch => v0 | reset => v1) = v1
    privcmd_distinct
      |- launch ≠ reset
    privcmd_distinct_clauses
      |- launch ≠ reset
    privcmd_induction
      |- ∀P. P launch ∧ P reset ⇒ ∀a. P a
    privcmd_nchotomy
      |- ∀a. (a = launch) ∨ (a = reset)
    staff2num_11
      |- ∀a a'. (staff2num a = staff2num a') ⇔ (a = a')
    staff2num_ONTO
      |- ∀r. r < 3 ⇔ ∃a. r = staff2num a
    staff2num_num2staff
      |- ∀r. r < 3 ⇔ (staff2num (num2staff r) = r)
    staff2num_thm
      |- (staff2num Alice = 0) ∧ (staff2num Bob = 1) ∧
         (staff2num Carol = 2)
    staff_Axiom
      |- ∀x0 x1 x2. ∃f. (f Alice = x0) ∧ (f Bob = x1) ∧ (f Carol = x2)
    staff_EQ_staff
      |- ∀a a'. (a = a') ⇔ (staff2num a = staff2num a')
    staff_case_cong
      |- ∀M M' v0 v1 v2.
           (M = M') ∧ ((M' = Alice) ⇒ (v0 = v0')) ∧
           ((M' = Bob) ⇒ (v1 = v1')) ∧ ((M' = Carol) ⇒ (v2 = v2')) ⇒
           ((case M of Alice => v0 | Bob => v1 | Carol => v2) =
            case M' of Alice => v0' | Bob => v1' | Carol => v2')
    staff_case_def
      |- (∀v0 v1 v2.
            (case Alice of Alice => v0 | Bob => v1 | Carol => v2) =
            v0) ∧
         (∀v0 v1 v2.
            (case Bob of Alice => v0 | Bob => v1 | Carol => v2) = v1) ∧
         ∀v0 v1 v2.
           (case Carol of Alice => v0 | Bob => v1 | Carol => v2) = v2
    staff_distinct
      |- Alice ≠ Bob ∧ Alice ≠ Carol ∧ Bob ≠ Carol
    staff_distinct_clauses
      |- Alice ≠ Bob ∧ Alice ≠ Carol ∧ Bob ≠ Carol
    staff_induction
      |- ∀P. P Alice ∧ P Bob ∧ P Carol ⇒ ∀a. P a
    staff_nchotomy
      |- ∀a. (a = Alice) ∨ (a = Bob) ∨ (a = Carol)
    state2num_11
      |- ∀a a'. (state2num a = state2num a') ⇔ (a = a')
    state2num_ONTO
      |- ∀r. r < 2 ⇔ ∃a. r = state2num a
    state2num_num2state
      |- ∀r. r < 2 ⇔ (state2num (num2state r) = r)
    state2num_thm
      |- (state2num STBY = 0) ∧ (state2num ACTIVE = 1)
    state_Axiom
      |- ∀x0 x1. ∃f. (f STBY = x0) ∧ (f ACTIVE = x1)
    state_EQ_state
      |- ∀a a'. (a = a') ⇔ (state2num a = state2num a')
    state_case_cong
      |- ∀M M' v0 v1.
           (M = M') ∧ ((M' = STBY) ⇒ (v0 = v0')) ∧
           ((M' = ACTIVE) ⇒ (v1 = v1')) ⇒
           ((case M of STBY => v0 | ACTIVE => v1) =
            case M' of STBY => v0' | ACTIVE => v1')
    state_case_def
      |- (∀v0 v1. (case STBY of STBY => v0 | ACTIVE => v1) = v0) ∧
         ∀v0 v1. (case ACTIVE of STBY => v0 | ACTIVE => v1) = v1
    state_distinct
      |- STBY ≠ ACTIVE
    state_distinct_clauses
      |- STBY ≠ ACTIVE
    state_induction
      |- ∀P. P ACTIVE ∧ P STBY ⇒ ∀a. P a
    state_nchotomy
      |- ∀a. (a = STBY) ∨ (a = ACTIVE)
Completed load of SM0Script
