
---------------------------------------------------------------------
       HOL-4 [Kananaskis 11 (stdknl, built Sat Aug 19 09:30:06 2017)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
[extending loadPath with Holmakefile INCLUDES variable]
> > > > > > > > Loading ssm1Theory
> Loading ssm2Theory
> > Loading SM0r3Theory
> > > > > > > > > Loading acl_infRules
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:88: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:125: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:162: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:250: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f1_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1245: warning: Matches are not exhaustive. Found near fn [th1, th2] => ACL_CONJ th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1276: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ1 disj2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1304: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ2 disj1 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1336: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1337: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1340: warning: Matches are not exhaustive. Found near fn [th] => ACL_MP th2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1374: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1408: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1440: warning: Matches are not exhaustive. Found near fn [th1, th2] => CONTROLS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1473: warning: Matches are not exhaustive. Found near fn [th1, th2] => DC th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1506: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMI_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1541: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMS_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1575: warning: Matches are not exhaustive. Found near fn [th1, th2] => HS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1601: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1602: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1604: warning: Pattern is not exhaustive.
Found near val (_, [proptype, ...]) = dest_type formType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1643: warning: Matches are not exhaustive.
Found near fn [th1, th2, th3] => IL_DOMI th2 th1 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1679: warning: Matches are not exhaustive.
Found near fn [th1, th2] => MONO_SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1709: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1710: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1745: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1776: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1810: warning: Matches are not exhaustive. Found near fn [th1, th2, th3] => REPS th1 th2 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1842: warning: Matches are not exhaustive. Found near fn [th1, th2] => REP_SAYS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1869: warning: Matches are not exhaustive. Found near fn [th] => SAYS princ th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1901: warning: Matches are not exhaustive. Found near fn [th1, th2] => SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1934: warning: Matches are not exhaustive.
Found near fn [th1, th2] => TRANS_SPEAKS_FOR th1 th2
> > val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val && = fn: simpset * thm list -> simpset
val ++ = fn: simpset * ssfrag -> simpset
val -- = fn: term frag list -> 'a -> term
val --> = fn: hol_type * hol_type -> hol_type
val == = fn: hol_type frag list -> 'a -> hol_type
val >- = fn: tactic * tactic -> tactic
val >> = fn: ('a, 'b) gentactic * tactic -> ('a, 'b) gentactic
val >>> = fn: ('a, 'b) gentactic * list_tactic -> ('a, 'b) gentactic
val >| = fn: ('a, 'b) gentactic * tactic list -> ('a, 'b) gentactic
val ?> = fn: ('a, 'b) verdict * ('a -> ('c, 'b) verdict) -> ('c, 'b) verdict
val ABS = fn: term -> thm -> thm
val ABS_CONV = fn: conv -> conv
val ABS_REP_THM =
   |- ∀P.
     (∃rep. TYPE_DEFINITION P rep) ⇒
     ∃rep abs. (∀a. abs (rep a) = a) ∧ ∀r. P r ⇔ (rep (abs r) = r):
   thm
val ABS_SIMP =
   |- ∀t1 t2. (λx. t1) t2 = t1:
   thm
val ABS_TAC = fn: tactic
val AC = fn: thm -> thm -> thm
val ACCEPT_TAC = fn: thm_tactic
val AC_CONV = fn: thm * thm -> conv
val ADD_ASSUM = fn: term -> thm -> thm
val ADD_SGS_TAC = fn: term list -> tactic -> tactic
val ALLGOALS = fn: tactic -> list_tactic
val ALL_CONV = fn: conv
val ALL_LT = fn: list_tactic
val ALL_TAC = fn: tactic
val ALL_THEN = fn: thm_tactical
val ALPHA = fn: term -> term -> thm
val ALPHA_CONV = fn: term -> term -> thm
val AND1_THM =
   |- ∀t1 t2. t1 ∧ t2 ⇒ t1:
   thm
val AND2_THM =
   |- ∀t1 t2. t1 ∧ t2 ⇒ t2:
   thm
val AND_CLAUSES =
   |- ∀t.
     (T ∧ t ⇔ t) ∧ (t ∧ T ⇔ t) ∧ (F ∧ t ⇔ F) ∧ (t ∧ F ⇔ F) ∧ (t ∧ t ⇔ t):
   thm
val AND_CONG =
   |- ∀P P' Q Q'. (Q ⇒ (P ⇔ P')) ∧ (P' ⇒ (Q ⇔ Q')) ⇒ (P ∧ Q ⇔ P' ∧ Q'):
   thm
val AND_DEF =
   |- $/\ = (λt1 t2. ∀t. (t1 ⇒ t2 ⇒ t) ⇒ t):
   thm
val AND_EXISTS_CONV = fn: conv
val AND_FORALL_CONV = fn: conv
val AND_IMP_INTRO =
   |- ∀t1 t2 t3. t1 ⇒ t2 ⇒ t3 ⇔ t1 ∧ t2 ⇒ t3:
   thm
val AND_IMP_INTRO_CONV = fn: conv
val AND_INTRO_THM =
   |- ∀t1 t2. t1 ⇒ t2 ⇒ t1 ∧ t2:
   thm
val ANTE_CONJ_CONV = fn: conv
val ANTE_RES_THEN = fn: thm_tactical
val AP_TERM = fn: term -> thm -> thm
val AP_TERM_TAC = fn: tactic
val AP_THM = fn: thm -> term -> thm
val AP_THM_TAC = fn: tactic
val ARITH_ss =
   Simplification set: ARITH_RWTS, ARITH_DP
Conversions:
   MUL_CANON_CONV, keyed on pattern  “x * y”
Decision procedures:
   ARITH_REDUCER
Rewrite rules:
   |- ∀x. ((SUC x = 1) ⇔ (x = 0)) ∧ ((1 = SUC x) ⇔ (x = 0))
   |- ∀x. ((SUC x = 2) ⇔ (x = 1)) ∧ ((2 = SUC x) ⇔ (x = 1))
   |- ∀m. m + 0 = m
   |- ∀m. 0 + m = m
   |- ∀m n. (m + n = 0) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (0 = m + n) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (m + n = m) ⇔ (n = 0)
   |- ∀m n. (n + m = m) ⇔ (n = 0)
   |- ∀m n. (m * n = 0) ⇔ (m = 0) ∨ (n = 0)
   |- ∀m n. (0 = m * n) ⇔ (m = 0) ∨ (n = 0)
   |- ∀x y. (x * y = 1) ⇔ (x = 1) ∧ (y = 1)
   |- ∀x y. (1 = x * y) ⇔ (x = 1) ∧ (y = 1)
   |- ∀m. m * 0 = 0
   |- ∀m. 0 * m = 0
   |- ∀x y. (x * y = SUC 0) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀x y. (SUC 0 = x * y) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀m. m * 1 = m
   |- ∀m. 1 * m = m
   |- ∀c. c − c = 0
   |- ∀m. SUC m − 1 = m
   |- ∀m. (0 − m = 0) ∧ (m − 0 = m)
   |- ∀a c. a + c − c = a
   |- ∀a c. c + a − c = a
   |- ∀m n. (m − n = 0) ⇔ m ≤ n
   |- ∀m n. (0 = m − n) ⇔ m ≤ n
   |- ∀n m. n − m ≤ n
   |- ∀n m. SUC n − SUC m = n − m
   |- ∀m n p. m − n > p ⇔ m > n + p
   |- ∀m n p. m − n < p ⇔ m < n + p ∧ 0 < p
   |- ∀m n p. m − n ≥ p ⇔ m ≥ n + p ∨ 0 ≥ p
   |- ∀m n p. m − n ≤ p ⇔ m ≤ n + p
   |- (PRE 0 = 0) ∧ ∀m. PRE (SUC m) = m
   |- ∀n m. (n ** m = 0) ⇔ (n = 0) ∧ 0 < m
   |- ∀n. (1 ** n = 1) ∧ (n ** 1 = n)
   |- ∀n m. (n ** m = 1) ⇔ (n = 1) ∨ (m = 0)
   |- 0 < x ** y ⇔ 0 < x ∨ (y = 0)
   |- ∀b1 b2 x. (b1 ** x = b2 ** x) ⇔ (x = 0) ∨ (b1 = b2)
   |- ∀b. 1 < b ⇒ ∀n m. (b ** n = b ** m) ⇔ (n = m)
   |- ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n
   |- ∀b. 1 < b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n
   |- ∀a b. a ** n < b ** n ⇔ a < b ∧ 0 < n
   |- ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ (n = 0)
   |- ∀n. n ≤ 0 ⇔ (n = 0)
   |- ∀n. 0 < SUC n
   |- ∀m n. m ≤ m + n
   |- 0 ≤ x
   |- SUC x > 0
   |- x ≥ 0
   |- x < SUC x
   |- x ≤ SUC x
   |- x < x + c ⇔ 0 < c
   |- x < c + x ⇔ 0 < c
   |- x ≤ x + c ⇔ 0 ≤ c
   |- x ≤ c + x ⇔ 0 ≤ c
   |- ∀m. m ≤ m
   |- x ≥ x
   |- ∀m n p. m + p < n + p ⇔ m < n
   |- ∀m n p. p + m < p + n ⇔ m < n
   |- ∀m n p. m + n ≤ m + p ⇔ n ≤ p
   |- ∀m n p. n + m ≤ p + m ⇔ n ≤ p
   |- ∀m n p. (m + p = n + p) ⇔ (m = n)
   |- ∀m n p. (p + m = p + n) ⇔ (m = n)
   |- x + y < w + x ⇔ y < w
   |- y + x < x + w ⇔ y < w
   |- ∀m n. (SUC m = SUC n) ⇔ (m = n)
   |- ∀m n. SUC m < SUC n ⇔ m < n
   |- ∀n m. SUC n ≤ SUC m ⇔ n ≤ m
   |- ∀m i n. SUC n * m < SUC n * i ⇔ m < i
   |- ∀p m n. (n * SUC p = m * SUC p) ⇔ (n = m)
   |- ∀m i n. (SUC n * m = SUC n * i) ⇔ (m = i)
   |- ∀n m. ¬(SUC n ≤ m) ⇔ m ≤ n
   |- ∀p q n m. (n * SUC q ** p = m * SUC q ** p) ⇔ (n = m)
   |- ∀m n p. m * n ≤ m * p ⇔ (m = 0) ∨ n ≤ p
   |- ∀m n p. m * n ≤ p * n ⇔ (n = 0) ∨ m ≤ p
   |- ∀m n p. m * n < m * p ⇔ 0 < m ∧ n < p
   |- ∀m n p. m * n < p * n ⇔ 0 < n ∧ m < p
   |- (m < m * n ⇔ 0 < m ∧ 1 < n) ∧ (m < n * m ⇔ 0 < m ∧ 1 < n)
   |- (m * n < m ⇔ 0 < m ∧ (n = 0)) ∧ (m * n < n ⇔ 0 < n ∧ (m = 0))
   |- (m ≤ m * n ⇔ (m = 0) ∨ 0 < n) ∧ (m ≤ n * m ⇔ (m = 0) ∨ 0 < n)
   |- (m * n ≤ m ⇔ (m = 0) ∨ n ≤ 1) ∧ (m * n ≤ n ⇔ (n = 0) ∨ m ≤ 1)
   |- ∀m n. SUC n ** m ≠ 0
   |- ∀n m. SUC (n + n) ≠ m + m
   |- ∀m n. ¬(SUC (m + n) ≤ m)
   |- ∀n. ¬(SUC n ≤ 0)
   |- ∀n. ¬(n < 0)
   |- ∀n. ¬(n < n)
   |- ¬(x > x)
   |- ∀n. (MIN n 0 = 0) ∧ (MIN 0 n = 0)
   |- ∀n. (MAX n 0 = n) ∧ (MAX 0 n = n)
   |- ∀n. MIN n n = n
   |- ∀n. MAX n n = n
   |- ∀n m p.
        (MIN m n ≤ p ⇔ m ≤ p ∨ n ≤ p) ∧ (p ≤ MIN m n ⇔ p ≤ m ∧ p ≤ n)
   |- ∀n m p.
        (p ≤ MAX m n ⇔ p ≤ m ∨ p ≤ n) ∧ (MAX m n ≤ p ⇔ m ≤ p ∧ n ≤ p)
   |- ∀n m p.
        (MIN m n < p ⇔ m < p ∨ n < p) ∧ (p < MIN m n ⇔ p < m ∧ p < n)
   |- ∀n m p.
        (p < MAX m n ⇔ p < m ∨ p < n) ∧ (MAX m n < p ⇔ m < p ∧ n < p)
   |- ∀m n. (MIN m n = MAX m n) ⇔ (m = n)
   |- ∀m n. MIN m n < MAX m n ⇔ m ≠ n
   |- ∀x y. 0 < y ⇒ ((x MOD y = x) ⇔ x < y)
   |- ∀n. 0 < n ⇒ (n DIV n = 1) ∧ (n MOD n = 0)
   |- ∀q. q DIV 1 = q
   |- ∀k. k MOD 1 = 0
   |- ∀n k. k < n ⇒ (k MOD n = k)
   |- ∀n. 0 < n ⇒ (0 MOD n = 0)
   |- ∀n. 0 < n ⇒ ∀k. k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT1 x) = 0)) ∧
      ((NUMERAL (BIT2 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT2 x) = 0))
   |- ∀m n. 0 < n ⇒ m MOD n < n
   |- ∀n d. 0 < n ∧ 1 < d ⇒ n DIV d < n
:
   ssfrag
val ASM_CASES_TAC = fn: term -> tactic
val ASM_QI_TAC = fn: tactic
val ASM_REWRITE_RULE = fn: thm list -> thm -> thm
val ASM_REWRITE_TAC = fn: thm list -> tactic
val ASM_SIMP_TAC = fn: simpset -> thm list -> tactic
val ASSUME = fn: term -> thm
val ASSUME_CONJS = fn: term -> thm
val ASSUME_TAC = fn: thm_tactic
val ASSUM_LIST = fn: (thm list -> tactic) -> tactic
val Abbr = fn: term quotation -> thm
val Absyn = fn: term frag list -> Absyn_dtype.absyn
val Always = Always: ParenStyle
val AroundEachPhrase = AroundEachPhrase: PhraseBlockStyle
val AroundSameName = AroundSameName: PhraseBlockStyle
val AroundSamePrec = AroundSamePrec: PhraseBlockStyle
val BETA_CONV = fn: term -> thm
val BETA_RULE = fn: thm -> thm
val BETA_TAC = fn: tactic
val BETA_THM =
   |- ∀f y. (λx. f x) y = f y:
   thm
val BETA_VAR = fn: term -> term -> term -> thm
val BINDER_CONV = fn: conv -> conv
val BINOP_CONV = fn: conv -> conv
val BINOP_TAC = fn: tactic
val BODY_CONJUNCTS = fn: thm -> thm list
val BOOL_CASES_AX =
   |- ∀t. (t ⇔ T) ∨ (t ⇔ F):
   thm
val BOOL_CASES_TAC = fn: term -> tactic
val BOOL_EQ_DISTINCT =
   |- (T ⇎ F) ∧ (F ⇎ T):
   thm
val BOOL_FUN_CASES_THM =
   |- ∀f. (f = (λb. T)) ∨ (f = (λb. F)) ∨ (f = (λb. b)) ∨ (f = (λb. ¬b)):
   thm
val BOOL_FUN_INDUCT =
   |- ∀P. P (λb. T) ∧ P (λb. F) ∧ P (λb. b) ∧ P (λb. ¬b) ⇒ ∀f. P f:
   thm
val BOTH_EXISTS_AND_THM =
   |- ∀P Q. (∃x. P ∧ Q) ⇔ (∃x. P) ∧ ∃x. Q:
   thm
val BOTH_EXISTS_IMP_CONV = fn: conv
val BOTH_EXISTS_IMP_THM =
   |- ∀P Q. (∃x. P ⇒ Q) ⇔ (∀x. P) ⇒ ∃x. Q:
   thm
val BOTH_FORALL_IMP_THM =
   |- ∀P Q. (∀x. P ⇒ Q) ⇔ (∃x. P) ⇒ ∀x. Q:
   thm
val BOTH_FORALL_OR_THM =
   |- ∀P Q. (∀x. P ∨ Q) ⇔ (∀x. P) ∨ ∀x. Q:
   thm
val BOUNDED_DEF =
   |- BOUNDED = (λv. T):
   thm
val BOUNDED_THM =
   |- ∀v. BOUNDED v ⇔ T:
   thm
val BeginFinalBlock = fn: block_info -> pp_element
val Beta = fn: thm -> thm
val BreakSpace = fn: int * int -> pp_element
val C = fn: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
val CASES_THENL = fn: thm_tactic list -> thm_tactic
val CASE_TAC = fn: tactic
val CCONTR = fn: term -> thm -> thm
val CCONTR_TAC = fn: tactic
val CHANGED_CONV = fn: conv -> conv
val CHANGED_TAC = fn: tactic -> tactic
val CHECK_ASSUME_TAC = fn: thm_tactic
val CHOOSE = fn: term * thm -> thm -> thm
val CHOOSE_TAC = fn: thm_tactic
val CHOOSE_THEN = fn: thm_tactical
val COMB2_CONV = fn: conv * conv -> conv
val COMB_CONV = fn: conv -> conv
val COND_ABS =
   |- ∀b f g. (λx. if b then f x else g x) = if b then f else g:
   thm
val COND_BOOL_CLAUSES =
   |- (∀b e. (if b then T else e) ⇔ b ∨ e) ∧
   (∀b t. (if b then t else T) ⇔ b ⇒ t) ∧
   (∀b e. (if b then F else e) ⇔ ¬b ∧ e) ∧
   ∀b t. (if b then t else F) ⇔ b ∧ t:
   thm
val COND_CASES_TAC = fn: tactic
val COND_CLAUSES =
   |- ∀t1 t2. ((if T then t1 else t2) = t1) ∧ ((if F then t1 else t2) = t2):
   thm
val COND_CONG =
   |- ∀P Q x x' y y'.
     (P ⇔ Q) ∧ (Q ⇒ (x = x')) ∧ (¬Q ⇒ (y = y')) ⇒
     ((if P then x else y) = if Q then x' else y'):
   thm
val COND_CONV = fn: conv
val COND_DEF =
   |- COND = (λt t1 t2. @x. ((t ⇔ T) ⇒ (x = t1)) ∧ ((t ⇔ F) ⇒ (x = t2))):
   thm
val COND_EXPAND =
   |- ∀b t1 t2. (if b then t1 else t2) ⇔ (¬b ∨ t1) ∧ (b ∨ t2):
   thm
val COND_EXPAND_IMP =
   |- ∀b t1 t2. (if b then t1 else t2) ⇔ (b ⇒ t1) ∧ (¬b ⇒ t2):
   thm
val COND_EXPAND_OR =
   |- ∀b t1 t2. (if b then t1 else t2) ⇔ b ∧ t1 ∨ ¬b ∧ t2:
   thm
val COND_ID =
   |- ∀b t. (if b then t else t) = t:
   thm
val COND_RAND =
   |- ∀f b x y. f (if b then x else y) = if b then f x else f y:
   thm
val COND_RATOR =
   |- ∀b f g x. (if b then f else g) x = if b then f x else g x:
   thm
val CONJ = fn: thm -> thm -> thm
val CONJUNCT1 = fn: thm -> thm
val CONJUNCT2 = fn: thm -> thm
val CONJUNCTS = fn: thm -> thm list
val CONJUNCTS_AC = fn: term * term -> thm
val CONJUNCTS_THEN = fn: thm_tactical
val CONJUNCTS_THEN2 = fn: thm_tactic -> thm_tactical
val CONJ_ASM1_TAC = fn: tactic
val CONJ_ASM2_TAC = fn: tactic
val CONJ_ASSOC =
   |- ∀t1 t2 t3. t1 ∧ t2 ∧ t3 ⇔ (t1 ∧ t2) ∧ t3:
   thm
val CONJ_COMM =
   |- ∀t1 t2. t1 ∧ t2 ⇔ t2 ∧ t1:
   thm
val CONJ_DISCH = fn: term -> thm -> thm
val CONJ_DISCHL = fn: term list -> thm -> thm
val CONJ_LIST = fn: int -> thm -> thm list
val CONJ_PAIR = fn: thm -> thm * thm
val CONJ_SYM =
   |- ∀t1 t2. t1 ∧ t2 ⇔ t2 ∧ t1:
   thm
val CONJ_TAC = fn: tactic
val CONTR = fn: term -> thm -> thm
val CONTRAPOS = fn: thm -> thm
val CONTRAPOS_CONV = fn: conv
val CONTR_TAC = fn: thm_tactic
val CONV_RULE = fn: conv -> thm -> thm
val CONV_TAC = fn: conv -> tactic
val CT = fn:
   unit ->
     (string,
     (string, DB.data list) Redblackmap.dict *
     (string, DB.data list) Redblackmap.dict) Redblackmap.dict
val Cases = fn: tactic
val Cases_on = fn: term quotation -> tactic
val Cong = fn: thm -> thm
val DATATYPE_BOOL =
   |- DATATYPE (bool T F) ⇔ T:
   thm
val DATATYPE_TAG_DEF =
   |- DATATYPE = (λx. T):
   thm
val DATATYPE_TAG_THM =
   |- ∀x. DATATYPE x ⇔ T:
   thm
val DECIDE = fn: term -> thm
val DECIDE_TAC = fn: tactic
val DEEP_INTRO_TAC = fn: thm -> tactic
val DEEP_INTROk_TAC = fn: thm -> tactic -> tactic
val DEPTH_CONV = fn: conv -> conv
val DEST_BOUNDED = fn: thm -> thm * int
val DE_MORGAN_THM =
   |- ∀A B. (¬(A ∧ B) ⇔ ¬A ∨ ¬B) ∧ (¬(A ∨ B) ⇔ ¬A ∧ ¬B):
   thm
val DISCARD_TAC = fn: thm -> tactic
val DISCH = fn: term -> thm -> thm
val DISCH_ALL = fn: thm -> thm
val DISCH_TAC = fn: tactic
val DISCH_THEN = fn: thm_tactic -> tactic
val DISJ1 = fn: thm -> term -> thm
val DISJ1_TAC = fn: tactic
val DISJ2 = fn: term -> thm -> thm
val DISJ2_TAC = fn: tactic
val DISJUNCTS_AC = fn: term * term -> thm
val DISJ_ASSOC =
   |- ∀A B C. A ∨ B ∨ C ⇔ (A ∨ B) ∨ C:
   thm
val DISJ_CASES = fn: thm -> thm -> thm -> thm
val DISJ_CASESL = fn: thm -> thm list -> thm
val DISJ_CASES_TAC = fn: thm_tactic
val DISJ_CASES_THEN = fn: thm_tactical
val DISJ_CASES_THEN2 = fn: thm_tactic -> thm_tactical
val DISJ_CASES_THENL = fn: thm_tactic list -> thm_tactic
val DISJ_CASES_UNION = fn: thm -> thm -> thm -> thm
val DISJ_COMM =
   |- ∀A B. A ∨ B ⇔ B ∨ A:
   thm
val DISJ_IMP = fn: thm -> thm
val DISJ_IMP_THM =
   |- ∀P Q R. P ∨ Q ⇒ R ⇔ (P ⇒ R) ∧ (Q ⇒ R):
   thm
val DISJ_SYM =
   |- ∀A B. A ∨ B ⇔ B ∨ A:
   thm
val Datatype = fn: hol_type quotation -> unit
val Define = fn: term quotation -> thm
structure Definition:
  sig
    val gen_new_specification: string * thm -> thm
    val new_definition: string * term -> thm
    val new_definition_hook:
       ((term -> term list * term) * (term list * thm -> thm)) ref
    val new_specification: string * string list * thm -> thm
    val new_type_definition: string * thm -> thm
  end
val EQF_ELIM = fn: thm -> thm
val EQF_INTRO = fn: thm -> thm
val EQT_ELIM = fn: thm -> thm
val EQT_INTRO = fn: thm -> thm
val EQ_CLAUSES =
   |- ∀t. ((T ⇔ t) ⇔ t) ∧ ((t ⇔ T) ⇔ t) ∧ ((F ⇔ t) ⇔ ¬t) ∧ ((t ⇔ F) ⇔ ¬t):
   thm
val EQ_EXPAND =
   |- ∀t1 t2. (t1 ⇔ t2) ⇔ t1 ∧ t2 ∨ ¬t1 ∧ ¬t2:
   thm
val EQ_EXT =
   |- ∀f g. (∀x. f x = g x) ⇒ (f = g):
   thm
val EQ_IMP_RULE = fn: thm -> thm * thm
val EQ_IMP_THM =
   |- ∀t1 t2. (t1 ⇔ t2) ⇔ (t1 ⇒ t2) ∧ (t2 ⇒ t1):
   thm
val EQ_MP = fn: thm -> thm -> thm
val EQ_REFL =
   |- ∀x. x = x:
   thm
val EQ_SYM =
   |- ∀x y. (x = y) ⇒ (y = x):
   thm
val EQ_SYM_EQ =
   |- ∀x y. (x = y) ⇔ (y = x):
   thm
val EQ_TAC = fn: tactic
val EQ_TRANS =
   |- ∀x y z. (x = y) ∧ (y = z) ⇒ (x = z):
   thm
val ERR = fn: string -> string -> exn
val ERR_outstream = ref fn: (string -> unit) ref
val ERR_to_string = ref fn: (error_record -> string) ref
val ETA_AX =
   |- ∀t. (λx. t x) = t:
   thm
val ETA_CONV = fn: term -> thm
val ETA_THM =
   |- ∀M. (λx. M x) = M:
   thm
val EVAL = fn: term -> thm
val EVAL_RULE = fn: thm -> thm
val EVAL_TAC = fn: tactic
val EVERY = fn: tactic list -> tactic
val EVERY_ASSUM = fn: thm_tactic -> tactic
val EVERY_CONJ_CONV = fn: conv -> conv
val EVERY_CONV = fn: conv list -> conv
val EVERY_DISJ_CONV = fn: conv -> conv
val EVERY_LT = fn: list_tactic list -> list_tactic
val EVERY_TCL = fn: thm_tactical list -> thm_tactical
val EXCLUDED_MIDDLE =
   |- ∀t. t ∨ ¬t:
   thm
val EXISTENCE = fn: thm -> thm
val EXISTS = fn: term * term -> thm -> thm
val EXISTS_AND_CONV = fn: conv
val EXISTS_AND_REORDER_CONV = fn: conv
val EXISTS_DEF =
   |- $? = (λP. P ($@ P)):
   thm
val EXISTS_EQ = fn: term -> thm -> thm
val EXISTS_EQUATION = fn: term -> thm -> thm
val EXISTS_IMP = fn: term -> thm -> thm
val EXISTS_IMP_CONV = fn: conv
val EXISTS_LEFT = fn: term list -> thm -> thm
val EXISTS_LEFT1 = fn: term -> thm -> thm
val EXISTS_NOT_CONV = fn: conv
val EXISTS_OR_CONV = fn: conv
val EXISTS_OR_THM =
   |- ∀P Q. (∃x. P x ∨ Q x) ⇔ (∃x. P x) ∨ ∃x. Q x:
   thm
val EXISTS_REFL =
   |- ∀a. ∃x. x = a:
   thm
val EXISTS_SIMP =
   |- ∀t. (∃x. t) ⇔ t:
   thm
val EXISTS_SIMP_CONV = fn: conv
val EXISTS_TAC = fn: term -> tactic
val EXISTS_THM =
   |- $? f ⇔ ∃x. f x:
   thm
val EXISTS_UNIQUE_ALT =
   |- ∀P. (∃!x. P x) ⇔ ∃x. ∀y. P y ⇔ (x = y):
   thm
val EXISTS_UNIQUE_CONV = fn: conv
val EXISTS_UNIQUE_DEF =
   |- $?! = (λP. $? P ∧ ∀x y. P x ∧ P y ⇒ (x = y)):
   thm
val EXISTS_UNIQUE_REFL =
   |- ∀a. ∃!x. x = a:
   thm
val EXISTS_UNIQUE_THM =
   |- (∃!x. P x) ⇔ (∃x. P x) ∧ ∀x y. P x ∧ P y ⇒ (x = y):
   thm
val EXT = fn: thm -> thm
val EndInitialBlock = fn: block_info -> pp_element
val F = “F”: term
val FAIL_LT = fn: string -> list_tactic
val FAIL_TAC = fn: string -> tactic
val FALSITY =
   |- ∀t. F ⇒ t:
   thm
val FILTER_ASM_REWRITE_RULE = fn: pred -> thm list -> thm -> thm
val FILTER_ASM_REWRITE_TAC = fn: pred -> thm list -> tactic
val FILTER_DISCH_TAC = fn: term -> tactic
val FILTER_DISCH_THEN = fn: thm_tactic -> term -> tactic
val FILTER_GEN_TAC = fn: term -> tactic
val FILTER_ONCE_ASM_REWRITE_RULE = fn: pred -> thm list -> thm -> thm
val FILTER_ONCE_ASM_REWRITE_TAC = fn: pred -> thm list -> tactic
val FILTER_PURE_ASM_REWRITE_RULE = fn: pred -> thm list -> thm -> thm
val FILTER_PURE_ASM_REWRITE_TAC = fn: pred -> thm list -> tactic
val FILTER_PURE_ONCE_ASM_REWRITE_RULE = fn: pred -> thm list -> thm -> thm
val FILTER_PURE_ONCE_ASM_REWRITE_TAC = fn: pred -> thm list -> tactic
val FILTER_STRIP_TAC = fn: term -> tactic
val FILTER_STRIP_THEN = fn: thm_tactic -> term -> tactic
val FIRST = fn: tactic list -> tactic
val FIRST_ASSUM = fn: thm_tactic -> tactic
val FIRST_CONV = fn: conv list -> conv
val FIRST_PROVE = fn: tactic list -> tactic
val FIRST_TCL = fn: thm_tactical list -> thm_tactical
val FIRST_X_ASSUM = fn: thm_tactic -> tactic
val FORALL_AND_CONV = fn: conv
val FORALL_AND_THM =
   |- ∀P Q. (∀x. P x ∧ Q x) ⇔ (∀x. P x) ∧ ∀x. Q x:
   thm
val FORALL_BOOL =
   |- (∀b. P b) ⇔ P T ∧ P F:
   thm
val FORALL_DEF =
   |- $! = (λP. P = (λx. T)):
   thm
val FORALL_EQ = fn: term -> thm -> thm
val FORALL_IMP_CONV = fn: conv
val FORALL_NOT_CONV = fn: conv
val FORALL_OR_CONV = fn: conv
val FORALL_SIMP =
   |- ∀t. (∀x. t) ⇔ t:
   thm
val FORALL_SIMP_CONV = fn: conv
val FORALL_THM =
   |- $! f ⇔ ∀x. f x:
   thm
val FORK_CONV = fn: conv * conv -> conv
val FREEZE_THEN = fn: thm_tactical
val FULL_SIMP_TAC = fn: simpset -> thm list -> tactic
val FULL_STRUCT_CASES_TAC = fn: thm_tactic
val FUN_EQ_CONV = fn: conv
val FUN_EQ_THM =
   |- ∀f g. (f = g) ⇔ ∀x. f x = g x:
   thm
val FVL = fn: term list -> term set -> term set
val F_DEF =
   |- F ⇔ ∀t. t:
   thm
val F_IMP =
   |- ∀t. ¬t ⇒ t ⇒ F:
   thm
val GEN = fn: term -> thm -> thm
val GENL = fn: term list -> thm -> thm
val GEN_ABS = fn: term option -> term list -> thm -> thm
val GEN_ALL = fn: thm -> thm
val GEN_ALPHA_CONV = fn: term -> term -> thm
val GEN_COND_CASES_TAC = fn: (term -> bool) -> tactic
val GEN_EXISTS_TAC = fn: string -> term frag list -> tactic
val GEN_REWRITE_CONV = fn: (conv -> conv) -> rewrites -> thm list -> conv
val GEN_REWRITE_RULE = fn:
   (conv -> conv) -> rewrites -> thm list -> thm -> thm
val GEN_REWRITE_TAC = fn: (conv -> conv) -> rewrites -> thm list -> tactic
val GEN_TAC = fn: tactic
val GEN_VALIDATE = fn: bool -> tactic -> tactic
val GEN_VALIDATE_LT = fn: bool -> list_tactic -> list_tactic
val GSPEC = fn: thm -> thm
val GSUBS = fn:
   ((term, term) subst -> term -> term) -> thm list -> thm -> thm
val GSUBST_TAC = fn:
   ((term, term) Lib.subst -> term -> term) -> thm list -> tactic
val GSYM = fn: thm -> thm
val HEADGOAL = fn: tactic -> list_tactic
val HINT_EXISTS_TAC = fn: tactic
val HOLDIR = "/usr/local/share/HOL": string
exception HOL_ERR of error_record
val HOL_MESG = fn: string -> unit
val HOL_PROGRESS_MESG = fn: string * string -> ('a -> 'b) -> 'a -> 'b
val HOL_WARNING = fn: string -> string -> string -> unit
val HOL_WARNINGloc = fn: string -> string -> locn.locn -> string -> unit
val HO_BACKCHAIN_TAC = fn: thm -> tactic
val HO_MATCH_ACCEPT_TAC = fn: thm -> tactic
val HO_MATCH_MP = fn: thm -> thm -> thm
val HO_MATCH_MP_TAC = fn: thm -> tactic
val HO_PART_MATCH = fn: (term -> term) -> thm -> term -> thm
val HO_REWR_CONV = fn: thm -> conv
val HYP_CONV_RULE = fn: (term -> bool) -> conv -> thm -> thm
val HardSpace = fn: int -> pp_element
val Hol_coreln = fn: term quotation -> thm * thm * thm
val Hol_datatype = fn: hol_type quotation -> unit
val Hol_defn = fn: string -> term quotation -> defn
val Hol_reln = fn: term quotation -> thm * thm * thm
val I = fn: 'a -> 'a
val ID_EX_TAC = fn: tactic
val ID_SPEC_TAC = fn: term -> tactic
val IFC = fn: conv -> conv -> conv -> conv
val IF_CASES_TAC = fn: tactic
val IF_THEN_T_IMP =
   |- ∀b e. (if b then T else e) ⇔ ¬b ⇒ e:
   thm
val IMP_ANTISYM_AX =
   |- ∀t1 t2. (t1 ⇒ t2) ⇒ (t2 ⇒ t1) ⇒ (t1 ⇔ t2):
   thm
val IMP_ANTISYM_RULE = fn: thm -> thm -> thm
val IMP_CANON = fn: thm -> thm list
val IMP_CLAUSES =
   |- ∀t.
     (T ⇒ t ⇔ t) ∧ (t ⇒ T ⇔ T) ∧ (F ⇒ t ⇔ T) ∧ (t ⇒ t ⇔ T) ∧
     (t ⇒ F ⇔ ¬t):
   thm
val IMP_CONG =
   |- ∀x x' y y'. (x ⇔ x') ∧ (x' ⇒ (y ⇔ y')) ⇒ (x ⇒ y ⇔ x' ⇒ y'):
   thm
val IMP_CONJ = fn: thm -> thm -> thm
val IMP_CONJ_THM =
   |- ∀P Q R. P ⇒ Q ∧ R ⇔ (P ⇒ Q) ∧ (P ⇒ R):
   thm
val IMP_DISJ_THM =
   |- ∀A B. A ⇒ B ⇔ ¬A ∨ B:
   thm
val IMP_ELIM = fn: thm -> thm
val IMP_F =
   |- ∀t. (t ⇒ F) ⇒ ¬t:
   thm
val IMP_F_EQ_F =
   |- ∀t. t ⇒ F ⇔ (t ⇔ F):
   thm
val IMP_RES_TAC = fn: thm -> tactic
val IMP_RES_THEN = fn: thm_tactic -> thm -> tactic
val IMP_TRANS = fn: thm -> thm -> thm
val INDUCT_THEN = fn: thm -> (thm -> tactic) -> tactic
val INFINITY_AX =
   |- ∃f. ONE_ONE f ∧ ¬ONTO f:
   thm
val INST = fn: (term, term) Lib.subst -> thm -> thm
val INST_TT_HYPS = fn:
   (term, term) subst * (hol_type, hol_type) subst -> thm -> thm * term list
val INST_TYPE = fn: (hol_type, hol_type) Lib.subst -> thm -> thm
val INST_TY_TERM = fn:
   (term, term) subst * (hol_type, hol_type) subst -> thm -> thm
val IN_DEF =
   |- $IN = (λx f. f x):
   thm
val IN_tm = “$IN”:
   term
val IRULE_CANON = fn: thm -> thm
val IRULE_TAC = fn: thm -> tactic
val ISPEC = fn: term -> thm -> thm
val ISPECL = fn: term list -> thm -> thm
val ITSELF_UNIQUE =
   |- ∀i. i = (:α):
   thm
val Induct = fn: tactic
val Induct_on = fn: term quotation -> tactic
val Infixl = fn: int -> fixity
val Infixr = fn: int -> fixity
val JRH_INDUCT_UTIL =
   |- ∀P t. (∀x. (x = t) ⇒ P x) ⇒ $? P:
   thm
val K = fn: 'a -> 'b -> 'a
val KNOW_TAC = fn: term -> tactic
val LAND_CONV = fn: conv -> conv
val LASTGOAL = fn: tactic -> list_tactic
val LAST_ASSUM = fn: thm_tactic -> tactic
val LAST_EXISTS_CONV = fn: conv -> conv
val LAST_FORALL_CONV = fn: conv -> conv
val LAST_X_ASSUM = fn: thm_tactic -> tactic
val LCOMM_THM =
   |- ∀f.
     (∀x y z. f x (f y z) = f (f x y) z) ⇒
     (∀x y. f x y = f y x) ⇒
     ∀x y z. f x (f y z) = f y (f x z):
   thm
val LEFT = LEFT: associativity
val LEFT_AND_CONG =
   |- ∀P P' Q Q'. (P ⇔ P') ∧ (P' ⇒ (Q ⇔ Q')) ⇒ (P ∧ Q ⇔ P' ∧ Q'):
   thm
val LEFT_AND_EXISTS_CONV = fn: conv
val LEFT_AND_FORALL_CONV = fn: conv
val LEFT_AND_FORALL_THM =
   |- ∀P Q. (∀x. P x) ∧ Q ⇔ ∀x. P x ∧ Q:
   thm
val LEFT_AND_OVER_OR =
   |- ∀A B C. A ∧ (B ∨ C) ⇔ A ∧ B ∨ A ∧ C:
   thm
val LEFT_EXISTS_AND_THM =
   |- ∀P Q. (∃x. P x ∧ Q) ⇔ (∃x. P x) ∧ Q:
   thm
val LEFT_EXISTS_IMP_THM =
   |- ∀P Q. (∃x. P x ⇒ Q) ⇔ (∀x. P x) ⇒ Q:
   thm
val LEFT_FORALL_IMP_THM =
   |- ∀P Q. (∀x. P x ⇒ Q) ⇔ (∃x. P x) ⇒ Q:
   thm
val LEFT_FORALL_OR_THM =
   |- ∀Q P. (∀x. P x ∨ Q) ⇔ (∀x. P x) ∨ Q:
   thm
val LEFT_IMP_EXISTS_CONV = fn: conv
val LEFT_IMP_FORALL_CONV = fn: conv
val LEFT_OR_CONG =
   |- ∀P P' Q Q'. (P ⇔ P') ∧ (¬P' ⇒ (Q ⇔ Q')) ⇒ (P ∨ Q ⇔ P' ∨ Q'):
   thm
val LEFT_OR_EXISTS_CONV = fn: conv
val LEFT_OR_EXISTS_THM =
   |- ∀P Q. (∃x. P x) ∨ Q ⇔ ∃x. P x ∨ Q:
   thm
val LEFT_OR_FORALL_CONV = fn: conv
val LEFT_OR_OVER_AND =
   |- ∀A B C. A ∨ B ∧ C ⇔ (A ∨ B) ∧ (A ∨ C):
   thm
val LET_CONG =
   |- ∀f g M N. (M = N) ∧ (∀x. (x = N) ⇒ (f x = g x)) ⇒ (LET f M = LET g N):
   thm
val LET_DEF =
   |- LET = (λf x. f x):
   thm
val LET_RAND =
   |- P (let x = M in N x) ⇔ (let x = M in P (N x)):
   thm
val LET_RATOR =
   |- (let x = M in N x) b = (let x = M in N x b):
   thm
val LET_THM =
   |- ∀f x. LET f x = f x:
   thm
val LHS_CONV = fn: conv -> conv
val LIST_BETA_CONV = fn: term -> thm
val LIST_CONJ = fn: thm list -> thm
val LIST_EXISTS_AND_CONV = fn: conv
val LIST_EXISTS_IMP_CONV = fn: bool -> conv
val LIST_EXISTS_NOT_CONV = fn: conv
val LIST_EXISTS_OR_CONV = fn: conv
val LIST_EXISTS_SIMP_CONV = fn: conv
val LIST_FORALL_AND_CONV = fn: conv
val LIST_FORALL_IMP_CONV = fn: bool -> conv
val LIST_FORALL_NOT_CONV = fn: conv
val LIST_FORALL_OR_CONV = fn: conv
val LIST_FORALL_SIMP_CONV = fn: conv
val LIST_MK_EXISTS = fn: term list -> thm -> thm
val LIST_MP = fn: thm list -> thm -> thm
val ListForm = fn:
   {block_info: block_info,
     cons: string, nilstr: string, separator: pp_element list} -> pp_element
structure LoadableThyData:
  sig
    val new:
       {merge: 'a * 'a -> 'a,
         read: (string -> term) -> string -> 'a option,
         terms: 'a -> term list,
         thydataty: string, write: (term -> string) -> 'a -> string} ->
         ('a -> t) * (t -> 'a option)
    val segment_data: {thy: string, thydataty: string} -> t option
    val set_theory_data: {data: t, thydataty: string} -> unit
    type t
    val temp_encoded_update:
       {data: string, read: string -> term, thy: string, thydataty: string}
         -> unit
    val write_data_update: {data: t, thydataty: string} -> unit
  end
val MAP_EVERY = fn: ('a -> tactic) -> 'a list -> tactic
val MAP_FIRST = fn: ('a -> tactic) -> 'a list -> tactic
val MAP_THM = fn: conv -> thm -> thm
val MATCH_ACCEPT_TAC = fn: thm -> tactic
val MATCH_MP = fn: thm -> thm -> thm
val MATCH_MP_TAC = fn: thm -> tactic
val MESG_outstream = ref fn: (string -> unit) ref
val MESG_to_string = ref fn: (string -> string) ref
val METIS_PROVE = fn: thm list -> term -> thm
val METIS_TAC = fn: thm list -> tactic
val MINISCOPE_EXISTS_CONV = fn: bool -> conv
val MINISCOPE_FORALL_CONV = fn: bool -> conv
val MK_ABS = fn: thm -> thm
val MK_AC_LCOMM = fn: thm * thm -> thm * thm * thm
val MK_BOUNDED = fn: thm -> int -> thm
val MK_COMB = fn: thm * thm -> thm
val MK_COMB_TAC = fn: tactic
val MK_EXISTS = fn: thm -> thm
val MODIFY_CONS = fn: (thm -> thm) -> thm -> thm
val MONO_ALL =
   |- (∀x. P x ⇒ Q x) ⇒ (∀x. P x) ⇒ ∀x. Q x:
   thm
val MONO_AND =
   |- (x ⇒ y) ∧ (z ⇒ w) ⇒ x ∧ z ⇒ y ∧ w:
   thm
val MONO_COND =
   |- (x ⇒ y) ⇒ (z ⇒ w) ⇒ (if b then x else z) ⇒ if b then y else w:
   thm
val MONO_EXISTS =
   |- (∀x. P x ⇒ Q x) ⇒ (∃x. P x) ⇒ ∃x. Q x:
   thm
val MONO_IMP =
   |- (y ⇒ x) ∧ (z ⇒ w) ⇒ (x ⇒ z) ⇒ y ⇒ w:
   thm
val MONO_NOT =
   |- (y ⇒ x) ⇒ ¬x ⇒ ¬y:
   thm
val MONO_NOT_EQ =
   |- y ⇒ x ⇔ ¬x ⇒ ¬y:
   thm
val MONO_OR =
   |- (x ⇒ y) ∧ (z ⇒ w) ⇒ x ∨ z ⇒ y ∨ w:
   thm
val MP = fn: thm -> thm -> thm
val MP_CANON = fn: thm -> thm
val MP_GENEQ_CANON = fn: bool list -> thm -> thm
val MP_LEQ_CANON = fn: thm -> thm
val MP_REQ_CANON = fn: thm -> thm
val MP_TAC = fn: thm_tactic
val Mk_abs = fn: thm -> term * thm * (thm -> thm)
val Mk_comb = fn: thm -> thm * thm * (thm -> thm -> thm)
val NEG_DISCH = fn: term -> thm -> thm
val NONASSOC = NONASSOC: associativity
val NOT_AND =
   |- ¬(t ∧ ¬t):
   thm
val NOT_CLAUSES =
   |- (∀t. ¬ ¬t ⇔ t) ∧ (¬T ⇔ F) ∧ (¬F ⇔ T):
   thm
val NOT_DEF =
   |- $~ = (λt. t ⇒ F):
   thm
val NOT_ELIM = fn: thm -> thm
val NOT_EQ_SYM = fn: thm -> thm
val NOT_EXISTS_CONV = fn: conv
val NOT_EXISTS_THM =
   |- ∀P. ¬(∃x. P x) ⇔ ∀x. ¬P x:
   thm
val NOT_F =
   |- ∀t. ¬t ⇒ (t ⇔ F):
   thm
val NOT_FORALL_CONV = fn: conv
val NOT_FORALL_THM =
   |- ∀P. ¬(∀x. P x) ⇔ ∃x. ¬P x:
   thm
val NOT_IMP =
   |- ∀A B. ¬(A ⇒ B) ⇔ A ∧ ¬B:
   thm
val NOT_INTRO = fn: thm -> thm
val NO_CONV = fn: conv
val NO_LT = fn: list_tactic
val NO_STRIP_FULL_SIMP_TAC = fn: simpset -> thm list -> tactic
val NO_STRIP_REV_FULL_SIMP_TAC = fn: simpset -> thm list -> tactic
val NO_TAC = fn: tactic
val NO_THEN = fn: thm_tactical
val NTAC = fn: int -> tactic -> tactic
val NTH_GOAL = fn: tactic -> int -> list_tactic
val NULL_OK_LT = fn: list_tactic -> list_tactic
val NoPhrasing = NoPhrasing: PhraseBlockStyle
val NotEvenIfRand = NotEvenIfRand: ParenStyle
val Ntimes = fn: thm -> int -> thm
val ONCE_ASM_REWRITE_RULE = fn: thm list -> thm -> thm
val ONCE_ASM_REWRITE_TAC = fn: thm list -> tactic
val ONCE_DEPTH_CONV = fn: conv -> conv
val ONCE_REWRITE_CONV = fn: thm list -> conv
val ONCE_REWRITE_RULE = fn: thm list -> thm -> thm
val ONCE_REWRITE_TAC = fn: thm list -> tactic
val ONE_ONE_DEF =
   |- ONE_ONE = (λf. ∀x1 x2. (f x1 = f x2) ⇒ (x1 = x2)):
   thm
val ONE_ONE_THM =
   |- ∀f. ONE_ONE f ⇔ ∀x1 x2. (f x1 = f x2) ⇒ (x1 = x2):
   thm
val ONTO_DEF =
   |- ONTO = (λf. ∀y. ∃x. y = f x):
   thm
val ONTO_THM =
   |- ∀f. ONTO f ⇔ ∀y. ∃x. y = f x:
   thm
val ORELSE = fn: tactic * tactic -> tactic
val ORELSEC = fn: conv * conv -> conv
val ORELSE_LT = fn: list_tactic * list_tactic -> list_tactic
val ORELSE_TCL = fn: thm_tactical * thm_tactical -> thm_tactical
val OR_CLAUSES =
   |- ∀t.
     (T ∨ t ⇔ T) ∧ (t ∨ T ⇔ T) ∧ (F ∨ t ⇔ t) ∧ (t ∨ F ⇔ t) ∧ (t ∨ t ⇔ t):
   thm
val OR_CONG =
   |- ∀P P' Q Q'. (¬Q ⇒ (P ⇔ P')) ∧ (¬P' ⇒ (Q ⇔ Q')) ⇒ (P ∨ Q ⇔ P' ∨ Q'):
   thm
val OR_DEF =
   |- $\/ = (λt1 t2. ∀t. (t1 ⇒ t) ⇒ (t2 ⇒ t) ⇒ t):
   thm
val OR_ELIM_THM =
   |- ∀t t1 t2. t1 ∨ t2 ⇒ (t1 ⇒ t) ⇒ (t2 ⇒ t) ⇒ t:
   thm
val OR_EXISTS_CONV = fn: conv
val OR_FORALL_CONV = fn: conv
val OR_IMP_THM =
   |- ∀A B. (A ⇔ B ∨ A) ⇔ B ⇒ A:
   thm
val OR_INTRO_THM1 =
   |- ∀t1 t2. t1 ⇒ t1 ∨ t2:
   thm
val OR_INTRO_THM2 =
   |- ∀t1 t2. t2 ⇒ t1 ∨ t2:
   thm
val Once = fn: thm -> thm
val OnlyIfNecessary = OnlyIfNecessary: ParenStyle
val PART_MATCH = fn: (term -> term) -> thm -> term -> thm
val PART_MATCH_A = fn: (term -> term) -> thm -> term -> thm
val PATH_CONV = fn: string -> conv -> conv
val PAT_ASSUM = fn: term -> thm_tactic -> tactic
val PAT_CONV = fn: term -> conv -> conv
val PAT_X_ASSUM = fn: term -> thm_tactic -> tactic
val PEIRCE =
   |- ((P ⇒ Q) ⇒ P) ⇒ P:
   thm
val POP_ASSUM = fn: thm_tactic -> tactic
val POP_ASSUM_LIST = fn: (thm list -> tactic) -> tactic
val PPBlock = fn: pp_element list * block_info -> pp_element
val PRED_ASSUM = fn: (term -> bool) -> thm_tactic -> tactic
val PRINT_CONV = fn: conv
val PROVE = fn: thm list -> term -> thm
val PROVE_HYP = fn: thm -> thm -> thm
val PROVE_TAC = fn: thm list -> tactic
val PULL_EXISTS =
   |- ∀P Q.
     ((∃x. P x) ⇒ Q ⇔ ∀x. P x ⇒ Q) ∧ ((∃x. P x) ∧ Q ⇔ ∃x. P x ∧ Q) ∧
     (Q ∧ (∃x. P x) ⇔ ∃x. Q ∧ P x):
   thm
val PULL_FORALL =
   |- ∀P Q.
     (Q ⇒ (∀x. P x) ⇔ ∀x. Q ⇒ P x) ∧ ((∀x. P x) ∧ Q ⇔ ∀x. P x ∧ Q) ∧
     (Q ∧ (∀x. P x) ⇔ ∀x. Q ∧ P x):
   thm
val PURE_ASM_REWRITE_RULE = fn: thm list -> thm -> thm
val PURE_ASM_REWRITE_TAC = fn: thm list -> tactic
val PURE_ONCE_ASM_REWRITE_RULE = fn: thm list -> thm -> thm
val PURE_ONCE_ASM_REWRITE_TAC = fn: thm list -> tactic
val PURE_ONCE_REWRITE_CONV = fn: thm list -> conv
val PURE_ONCE_REWRITE_RULE = fn: thm list -> thm -> thm
val PURE_ONCE_REWRITE_TAC = fn: thm list -> tactic
val PURE_REWRITE_CONV = fn: thm list -> conv
val PURE_REWRITE_RULE = fn: thm list -> thm -> thm
val PURE_REWRITE_TAC = fn: thm list -> tactic
val PairCases_on = fn: term quotation -> tactic
eqtype ParenStyle
val ParoundName = ParoundName: ParenStyle
val ParoundPrec = ParoundPrec: ParenStyle
eqtype PhraseBlockStyle
val Preterm = fn: term frag list -> Preterm_dtype.preterm
val QCHANGED_CONV = fn: conv -> conv
val QCONV = fn: conv -> conv
val QI_TAC = fn: tactic
val QI_ss =
   Simplification set: <anonymous>
Decision procedures:
   QUANT_INSTANTIATE
:
   ssfrag
val QTY_TAC = fn: hol_type -> (term -> tactic) -> term frag list -> tactic
val QUANT_CONV = fn: conv -> conv
val Q_TAC = fn: (term -> tactic) -> term frag list -> tactic
val Q_TAC0 = fn:
   {traces: (string * int) list} ->
     hol_type option -> (term -> tactic) -> term frag list -> tactic
val RAND_CONV = fn: conv -> conv
val RATOR_CONV = fn: conv -> conv
val REABBREV_TAC = fn: tactic
val REDEPTH_CONV = fn: conv -> conv
val REFL = fn: term -> thm
val REFL_CLAUSE =
   |- ∀x. (x = x) ⇔ T:
   thm
val REFL_TAC = fn: tactic
val RENAME_VARS_CONV = fn: string list -> conv
val REORDER_ANTS = fn: (term list -> term list) -> thm -> thm
val REORDER_ANTS_MOD = fn:
   (term list -> term list) -> (thm -> thm) -> thm -> thm
val REPEAT = fn: tactic -> tactic
val REPEATC = fn: conv -> conv
val REPEAT_GTCL = fn: thm_tactical -> (thm -> tactic) -> thm_tactic
val REPEAT_LT = fn: list_tactic -> list_tactic
val REPEAT_TCL = fn: thm_tactical -> thm_tactical
val RESORT_EXISTS_CONV = fn: (term list -> term list) -> conv
val RESORT_FORALL_CONV = fn: (term list -> term list) -> conv
val RES_ABSTRACT_DEF =
   |- (∀p m x. x ∈ p ⇒ (RES_ABSTRACT p m x = m x)) ∧
   ∀p m1 m2.
     (∀x. x ∈ p ⇒ (m1 x = m2 x)) ⇒
     (RES_ABSTRACT p m1 = RES_ABSTRACT p m2):
   thm
val RES_CANON = fn: thm -> thm list
val RES_EXISTS_CONG =
   |- (P = Q) ⇒
   (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
   (RES_EXISTS P f ⇔ RES_EXISTS Q g):
   thm
val RES_EXISTS_DEF =
   |- RES_EXISTS = (λp m. ∃x. x ∈ p ∧ m x):
   thm
val RES_EXISTS_FALSE =
   |- (∃x::P. F) ⇔ F:
   thm
val RES_EXISTS_THM =
   |- ∀P f. RES_EXISTS P f ⇔ ∃x. x ∈ P ∧ f x:
   thm
val RES_EXISTS_UNIQUE_DEF =
   |- RES_EXISTS_UNIQUE =
   (λp m. (∃x::p. m x) ∧ ∀x y::p. m x ∧ m y ⇒ (x = y)):
   thm
val RES_EXISTS_UNIQUE_THM =
   |- ∀P f.
     RES_EXISTS_UNIQUE P f ⇔ (∃x::P. f x) ∧ ∀x y::P. f x ∧ f y ⇒ (x = y):
   thm
val RES_FORALL_CONG =
   |- (P = Q) ⇒
   (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
   (RES_FORALL P f ⇔ RES_FORALL Q g):
   thm
val RES_FORALL_DEF =
   |- RES_FORALL = (λp m. ∀x. x ∈ p ⇒ m x):
   thm
val RES_FORALL_THM =
   |- ∀P f. RES_FORALL P f ⇔ ∀x. x ∈ P ⇒ f x:
   thm
val RES_FORALL_TRUE =
   |- (∀x::P. T) ⇔ T:
   thm
val RES_SELECT_DEF =
   |- RES_SELECT = (λp m. @x. x ∈ p ∧ m x):
   thm
val RES_SELECT_THM =
   |- ∀P f. RES_SELECT P f = @x. x ∈ P ∧ f x:
   thm
val RES_TAC = fn: tactic
val RES_THEN = fn: thm_tactic -> tactic
val REVERSE = fn: tactic -> tactic
val REVERSE_LT = fn: list_tactic
val REV_FULL_SIMP_TAC = fn: simpset -> thm list -> tactic
val REWRITES_CONV = fn: rewrites -> conv
val REWRITE_CONV = fn: thm list -> conv
val REWRITE_RULE = fn: thm list -> thm -> thm
val REWRITE_TAC = fn: thm list -> tactic
val REWR_CONV = fn: thm -> conv
val REWR_CONV_A = fn: thm -> conv
val RHS_CONV = fn: conv -> conv
val RIGHT = RIGHT: associativity
val RIGHT_AND_EXISTS_CONV = fn: conv
val RIGHT_AND_FORALL_CONV = fn: conv
val RIGHT_AND_FORALL_THM =
   |- ∀P Q. P ∧ (∀x. Q x) ⇔ ∀x. P ∧ Q x:
   thm
val RIGHT_AND_OVER_OR =
   |- ∀A B C. (B ∨ C) ∧ A ⇔ B ∧ A ∨ C ∧ A:
   thm
val RIGHT_BETA = fn: thm -> thm
val RIGHT_CONV_RULE = fn: conv -> thm -> thm
val RIGHT_ETA = fn: thm -> thm
val RIGHT_EXISTS_AND_THM =
   |- ∀P Q. (∃x. P ∧ Q x) ⇔ P ∧ ∃x. Q x:
   thm
val RIGHT_EXISTS_IMP_THM =
   |- ∀P Q. (∃x. P ⇒ Q x) ⇔ P ⇒ ∃x. Q x:
   thm
val RIGHT_FORALL_IMP_THM =
   |- ∀P Q. (∀x. P ⇒ Q x) ⇔ P ⇒ ∀x. Q x:
   thm
val RIGHT_FORALL_OR_THM =
   |- ∀P Q. (∀x. P ∨ Q x) ⇔ P ∨ ∀x. Q x:
   thm
val RIGHT_IMP_EXISTS_CONV = fn: conv
val RIGHT_IMP_FORALL_CONV = fn: conv
val RIGHT_LIST_BETA = fn: thm -> thm
val RIGHT_OR_EXISTS_CONV = fn: conv
val RIGHT_OR_EXISTS_THM =
   |- ∀P Q. P ∨ (∃x. Q x) ⇔ ∃x. P ∨ Q x:
   thm
val RIGHT_OR_FORALL_CONV = fn: conv
val RIGHT_OR_OVER_AND =
   |- ∀A B C. B ∧ C ∨ A ⇔ (B ∨ A) ∧ (C ∨ A):
   thm
val ROTATE_LT = fn: int -> list_tactic
val RULE_ASSUM_TAC = fn: (thm -> thm) -> tactic
val RULE_L_ASSUM_TAC = fn: (thm -> thm list) -> tactic
val RW_TAC = fn: simpset -> thm list -> tactic
val Raise = fn: exn -> 'a
val S = fn: ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
val SELECT_AX =
   |- ∀P x. P x ⇒ P ($@ P):
   thm
val SELECT_CONV = fn: conv
val SELECT_ELIM = fn: thm -> term * thm -> thm
val SELECT_ELIM_TAC = fn: tactic
val SELECT_ELIM_THM =
   |- ∀P Q. (∃x. P x) ∧ (∀x. P x ⇒ Q x) ⇒ Q ($@ P):
   thm
val SELECT_EQ = fn: term -> thm -> thm
val SELECT_INTRO = fn: thm -> thm
val SELECT_REFL =
   |- ∀x. (@y. y = x) = x:
   thm
val SELECT_REFL_2 =
   |- ∀x. (@y. x = y) = x:
   thm
val SELECT_RULE = fn: thm -> thm
val SELECT_THM =
   |- ∀P. P (@x. P x) ⇔ ∃x. P x:
   thm
val SELECT_UNIQUE =
   |- ∀P x. (∀y. P y ⇔ (y = x)) ⇒ ($@ P = x):
   thm
val SIMPLE_CHOOSE = fn: term -> thm -> thm
val SIMPLE_EXISTS = fn: term -> thm -> thm
val SIMP_CONV = fn: simpset -> thm list -> conv
val SIMP_RULE = fn: simpset -> thm list -> thm -> thm
val SIMP_TAC = fn: simpset -> thm list -> tactic
val SKOLEM_CONV = fn: conv
val SKOLEM_THM =
   |- ∀P. (∀x. ∃y. P x y) ⇔ ∃f. ∀x. P x (f x):
   thm
val SPEC = fn: term -> thm -> thm
val SPECL = fn: term list -> thm -> thm
val SPEC_ALL = fn: thm -> thm
val SPEC_TAC = fn: term * term -> tactic
val SPEC_UNDISCH_EXL = fn: thm -> thm
val SPEC_VAR = fn: thm -> term * thm
val SPLIT_LT = fn: int -> list_tactic * list_tactic -> list_tactic
val SPOSE_NOT_THEN = fn: (thm -> tactic) -> tactic
val SQI_ss =
   Simplification set: SIMPLE_QUANT_INSTANTIATE_GEN
Conversions:
   SIMPLE_EXISTS_INSTANTIATE_CONV_GEN, keyed on pattern  “∃x. P”
   SIMPLE_FORALL_INSTANTIATE_CONV_GEN, keyed on pattern  “∀x. P”
   SIMPLE_UEXISTS_INSTANTIATE_CONV_GEN, keyed on pattern  “∃!x. P”
   SIMPLE_SOME_INSTANTIATE_CONV_GEN, keyed on pattern  “some x. P”
   SIMPLE_SELECT_INSTANTIATE_CONV_GEN, keyed on pattern  “@x. P”
Rewrite rules:
   |- (∀l. (HD l::TL l = l) ⇔ l ≠ []) ∧
      (∀l. (HD l::HD (TL l)::TL (TL l) = l) ⇔ LENGTH l > 1) ∧
      (∀l.
         (HD l::HD (TL l)::HD (TL (TL l))::TL (TL (TL l)) = l) ⇔
         LENGTH l > 2) ∧
      (∀l.
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              TL (TL (TL (TL l))) =
          l) ⇔ LENGTH l > 3) ∧
      (∀l.
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::TL (TL (TL (TL (TL l)))) =
          l) ⇔ LENGTH l > 4) ∧
      (∀l.
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              TL (TL (TL (TL (TL (TL l))))) =
          l) ⇔ LENGTH l > 5) ∧
      (∀l.
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              TL (TL (TL (TL (TL (TL (TL l)))))) =
          l) ⇔ LENGTH l > 6) ∧
      (∀l.
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              HD (TL (TL (TL (TL (TL (TL (TL l)))))))::
              TL (TL (TL (TL (TL (TL (TL (TL l))))))) =
          l) ⇔ LENGTH l > 7) ∧
      (∀l.
         (HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              HD (TL (TL (TL (TL (TL (TL (TL l)))))))::
              HD (TL (TL (TL (TL (TL (TL (TL (TL l))))))))::
              TL (TL (TL (TL (TL (TL (TL (TL (TL l)))))))) =
          l) ⇔ LENGTH l > 8) ∧ (∀l. ([HD l] = l) ⇔ (LENGTH l = 1)) ∧
      (∀l. ([HD l; HD (TL l)] = l) ⇔ (LENGTH l = 2)) ∧
      (∀l. ([HD l; HD (TL l); HD (TL (TL l))] = l) ⇔ (LENGTH l = 3)) ∧
      (∀l.
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)))] = l) ⇔
         (LENGTH l = 4)) ∧
      (∀l.
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l))))] =
          l) ⇔ (LENGTH l = 5)) ∧
      (∀l.
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))))] =
          l) ⇔ (LENGTH l = 6)) ∧
      (∀l.
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))))] =
          l) ⇔ (LENGTH l = 7)) ∧
      (∀l.
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))));
           HD (TL (TL (TL (TL (TL (TL (TL l)))))))] =
          l) ⇔ (LENGTH l = 8)) ∧
      (∀l.
         ([HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))));
           HD (TL (TL (TL (TL (TL (TL (TL l)))))));
           HD (TL (TL (TL (TL (TL (TL (TL (TL l))))))))] =
          l) ⇔ (LENGTH l = 9)) ∧ (∀l. (l = HD l::TL l) ⇔ l ≠ []) ∧
      (∀l. (l = HD l::HD (TL l)::TL (TL l)) ⇔ LENGTH l > 1) ∧
      (∀l.
         (l = HD l::HD (TL l)::HD (TL (TL l))::TL (TL (TL l))) ⇔
         LENGTH l > 2) ∧
      (∀l.
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              TL (TL (TL (TL l)))) ⇔ LENGTH l > 3) ∧
      (∀l.
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::TL (TL (TL (TL (TL l))))) ⇔
         LENGTH l > 4) ∧
      (∀l.
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              TL (TL (TL (TL (TL (TL l)))))) ⇔ LENGTH l > 5) ∧
      (∀l.
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              TL (TL (TL (TL (TL (TL (TL l))))))) ⇔ LENGTH l > 6) ∧
      (∀l.
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              HD (TL (TL (TL (TL (TL (TL (TL l)))))))::
              TL (TL (TL (TL (TL (TL (TL (TL l)))))))) ⇔ LENGTH l > 7) ∧
      (∀l.
         (l =
          HD l::HD (TL l)::HD (TL (TL l))::HD (TL (TL (TL l)))::
              HD (TL (TL (TL (TL l))))::HD (TL (TL (TL (TL (TL l)))))::
              HD (TL (TL (TL (TL (TL (TL l))))))::
              HD (TL (TL (TL (TL (TL (TL (TL l)))))))::
              HD (TL (TL (TL (TL (TL (TL (TL (TL l))))))))::
              TL (TL (TL (TL (TL (TL (TL (TL (TL l))))))))) ⇔
         LENGTH l > 8) ∧ (∀l. (l = [HD l]) ⇔ (LENGTH l = 1)) ∧
      (∀l. (l = [HD l; HD (TL l)]) ⇔ (LENGTH l = 2)) ∧
      (∀l. (l = [HD l; HD (TL l); HD (TL (TL l))]) ⇔ (LENGTH l = 3)) ∧
      (∀l.
         (l = [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)))]) ⇔
         (LENGTH l = 4)) ∧
      (∀l.
         (l =
          [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l))))]) ⇔ (LENGTH l = 5)) ∧
      (∀l.
         (l =
          [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))))]) ⇔
         (LENGTH l = 6)) ∧
      (∀l.
         (l =
          [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))))]) ⇔ (LENGTH l = 7)) ∧
      (∀l.
         (l =
          [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
           HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
           HD (TL (TL (TL (TL (TL (TL l))))));
           HD (TL (TL (TL (TL (TL (TL (TL l)))))))]) ⇔ (LENGTH l = 8)) ∧
      ∀l.
        (l =
         [HD l; HD (TL l); HD (TL (TL l)); HD (TL (TL (TL l)));
          HD (TL (TL (TL (TL l)))); HD (TL (TL (TL (TL (TL l)))));
          HD (TL (TL (TL (TL (TL (TL l))))));
          HD (TL (TL (TL (TL (TL (TL (TL l)))))));
          HD (TL (TL (TL (TL (TL (TL (TL (TL l))))))))]) ⇔
        (LENGTH l = 9)
   |- ∀opt. (SOME (THE opt) = opt) ⇔ IS_SOME opt
   |- ∀p p2. ((FST p,p2) = p) ⇔ (p2 = SND p)
   |- ∀p p1. ((p1,SND p) = p) ⇔ (p1 = FST p)
   |- ∀opt. (opt = SOME (THE opt)) ⇔ IS_SOME opt
   |- ∀p p2. (p = (FST p,p2)) ⇔ (SND p = p2)
   |- ∀p p1. (p = (p1,SND p)) ⇔ (FST p = p1)
:
   ssfrag
val SRW_TAC = fn: ssfrag list -> thm list -> tactic
val STRIP_ASSUME_TAC = fn: thm_tactic
val STRIP_BINDER_CONV = fn: term option -> conv -> conv
val STRIP_GOAL_THEN = fn: thm_tactic -> tactic
val STRIP_QUANT_CONV = fn: conv -> conv
val STRIP_TAC = fn: tactic
val STRIP_THM_THEN = fn: thm_tactical
val STRUCT_CASES_TAC = fn: thm_tactic
val SUBGOAL_THEN = fn: term -> thm_tactic -> tactic
val SUBS = fn: thm list -> thm -> thm
val SUBST = fn: (term, thm) Lib.subst -> term -> thm -> thm
val SUBST1_TAC = fn: thm -> tactic
val SUBST_ALL_TAC = fn: thm -> tactic
val SUBST_CONV = fn: (term, thm) subst -> term -> term -> thm
val SUBST_MATCH = fn: thm -> thm -> thm
val SUBST_OCCS_TAC = fn: (int list * thm) list -> tactic
val SUBST_TAC = fn: thm list -> tactic
val SUBS_OCCS = fn: (int list * thm) list -> thm -> thm
val SUB_CONV = fn: conv -> conv
val SUFF_TAC = fn: term -> tactic
val SWAP_EXISTS_CONV = fn: conv
val SWAP_EXISTS_THM =
   |- ∀P. (∃x y. P x y) ⇔ ∃y x. P x y:
   thm
val SWAP_FORALL_CONV = fn: conv
val SWAP_FORALL_THM =
   |- ∀P. (∀x y. P x y) ⇔ ∀y x. P x y:
   thm
val SWAP_VARS_CONV = fn: conv
val SYM = fn: thm -> thm
val SYM_CONV = fn: conv
val SimpL = fn: term -> thm
val SimpLHS =
   |- Cong ((x = x') ⇒ ((x = y) ⇔ (x' = y))):
   thm
val SimpR = fn: term -> thm
val SimpRHS =
   |- Cong ((y = y') ⇒ ((x = y) ⇔ (x = y'))):
   thm
val Specialize = fn: term -> thm -> thm
val T = “T”: term
val TACS_TO_LT = fn: tactic list -> list_tactic
val TAC_PROOF = fn: goal * tactic -> thm
val THEN = fn: ('a, 'b) gentactic * tactic -> ('a, 'b) gentactic
val THEN1 = fn: tactic * tactic -> tactic
val THENC = fn: conv * conv -> conv
val THENL = fn: ('a, 'b) gentactic * tactic list -> ('a, 'b) gentactic
val THEN_LT = fn: ('a, 'b) gentactic * list_tactic -> ('a, 'b) gentactic
val THEN_TCL = fn: thm_tactical * thm_tactical -> thm_tactical
val TM = RE TM: pp_element
val TOK = fn: string -> pp_element
val TOP_DEPTH_CONV = fn: conv -> conv
val TOP_SWEEP_CONV = fn: conv -> conv
val TRANS = fn: thm -> thm -> thm
val TRUTH = |- T: thm
val TRY = fn: tactic -> tactic
val TRYALL = fn: tactic -> list_tactic
val TRY_CONV = fn: conv -> conv
val TRY_LT = fn: list_tactic -> list_tactic
val TYPE_DEFINITION =
   |- TYPE_DEFINITION =
   (λP rep.
      (∀x' x''. (rep x' = rep x'') ⇒ (x' = x'')) ∧
      ∀x. P x ⇔ ∃x'. x = rep x'):
   thm
val TYPE_DEFINITION_THM =
   |- ∀P rep.
     TYPE_DEFINITION P rep ⇔
     (∀x' x''. (rep x' = rep x'') ⇒ (x' = x'')) ∧
     ∀x. P x ⇔ ∃x'. x = rep x':
   thm
val T_DEF =
   |- T ⇔ ((λx. x) = (λx. x)):
   thm
val TeX_notation = fn: {TeX: string * int, hol: string} -> unit
val Term = fn: term frag list -> term
val Type = fn: hol_type frag list -> hol_type
val U = fn: ''a list list -> ''a list
val UEXISTS_OR_THM =
   |- ∀P Q. (∃!x. P x ∨ Q x) ⇒ (∃!x. P x) ∨ ∃!x. Q x:
   thm
val UEXISTS_SIMP =
   |- (∃!x. t) ⇔ t ∧ ∀x y. x = y:
   thm
val UNABBREV_ALL_TAC = fn: tactic
val UNBETA_CONV = fn: term -> conv
exception UNCHANGED
val UNDISCH = fn: thm -> thm
val UNDISCH_ALL = fn: thm -> thm
val UNDISCH_SPLIT = fn: thm -> thm
val UNDISCH_TAC = fn: term -> tactic
val UNDISCH_THEN = fn: term -> thm_tactic -> tactic
val UNDISCH_TM = fn: thm -> term * thm
val UNIQUE_SKOLEM_ALT =
   |- ∀P. (∀x. ∃!y. P x y) ⇔ ∃f. ∀x y. P x y ⇔ (f x = y):
   thm
val UNIQUE_SKOLEM_THM =
   |- ∀P. (∀x. ∃!y. P x y) ⇔ ∃!f. ∀x. P x (f x):
   thm
val UNWIND_FORALL_THM1 =
   |- ∀f v. (∀x. (v = x) ⇒ f x) ⇔ f v:
   thm
val UNWIND_FORALL_THM2 =
   |- ∀f v. (∀x. (x = v) ⇒ f x) ⇔ f v:
   thm
val UNWIND_THM1 =
   |- ∀P a. (∃x. (a = x) ∧ P x) ⇔ P a:
   thm
val UNWIND_THM2 =
   |- ∀P a. (∃x. (x = a) ∧ P x) ⇔ P a:
   thm
val USE_SG_THEN = fn: thm_tactic -> int -> int -> list_tactic
structure Unicode:
  sig
    structure UChar: UnicodeChars
    val temp_unicode_version: {tmnm: string, u: string} -> unit
    val unicode_version: {tmnm: string, u: string} -> unit
  end
val VALID = fn: tactic -> tactic
val VALIDATE = fn: tactic -> tactic
val VALIDATE_LT = fn: list_tactic -> list_tactic
val VALID_LT = fn: list_tactic -> list_tactic
val W = fn: ('a -> 'a -> 'b) -> 'a -> 'b
val WARNING_outstream = ref fn: (string -> unit) ref
val WARNING_to_string = ref fn: (string -> string -> string -> string) ref
val WARNINGs_as_ERRs = ref false: bool ref
val WEAKEN_TAC = fn: (term -> bool) -> tactic
val WF_REL_TAC = fn: term quotation -> tactic
val WITHOUT_ABBREVS = fn: tactic -> tactic
val X_CASES_THEN = fn: term list list -> thm_tactical
val X_CASES_THENL = fn:
   (('a list -> 'b list -> ('a * 'b) list) ->
     thm_tactic list -> (term list * thm_tactic) list) ->
     thm_tactic list -> thm_tactic
val X_CHOOSE_TAC = fn: term -> thm_tactic
val X_CHOOSE_THEN = fn: term -> thm_tactical
val X_FUN_EQ_CONV = fn: term -> conv
val X_GEN_TAC = fn: term -> tactic
val X_SKOLEM_CONV = fn: term -> conv
val ZAP_TAC = fn: simpset -> thm list -> tactic
val \\ = fn: ('a, 'b) gentactic * tactic -> ('a, 'b) gentactic
val absyn_to_preterm = fn:
   Absyn_dtype.absyn -> Preterm_dtype.preterm Pretype.in_env
val absyn_to_term = fn: term_grammar.grammar -> Absyn_dtype.absyn -> term
val aconv = fn: term -> term -> bool
val add_ML_dependency = fn: string -> unit
val add_absyn_postprocessor = fn: string -> unit
val add_bare_numeral_form = fn: char * string option -> unit
val add_const = fn: string -> unit
val add_implicit_rewrites = fn: thm list -> unit
val add_infix = fn: string * int * associativity -> unit
val add_infix_type = fn:
   {Assoc: associativity, Name: string, ParseName: string option, Prec: int}
     -> unit
val add_listform = fn:
   {block_info: block_info,
     cons: string,
     leftdelim: pp_element list,
     nilstr: string, rightdelim: pp_element list, separator: pp_element list}
     -> unit
val add_numeral_form = fn: char * string option -> unit
val add_qtype = fn: {Name: string, Thy: string} -> unit
val add_record_field = fn: string * term -> unit
val add_record_fupdate = fn: string * term -> unit
val add_rewrites = fn: rewrites -> thm list -> rewrites
val add_rule = fn:
   {block_style: PhraseBlockStyle * block_info,
     fixity: fixity,
     paren_style: ParenStyle, pp_elements: pp_element list, term_name: string}
     -> unit
val add_style_to_string = fn: term_pp_types.pp_style list -> string -> string
val add_tag = fn: tag * thm -> thm
val add_type = fn: string -> unit
val add_user_printer = fn: string * term -> unit
val adjoin_to_theory = fn: thy_addon -> unit
val all = fn: ('a -> bool) -> 'a list -> bool
val all2 = fn: ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
val all_atoms = fn: term -> term set
val all_atomsl = fn: term list -> term set -> term set
val all_consts = fn: unit -> term list
val all_data = fn: string -> (string * (string * thm) list) list
val all_set_types = fn: unit -> string list
val all_tac = fn: tactic
val all_vars = fn: term -> term list
val all_varsl = fn: term list -> term list
val allow_schema_definition = ref false: bool ref
val alpha = “:α”: hol_type
val ancestry = fn: string -> string list
val apfst = fn: ('a -> 'b) -> 'a * 'c -> 'b * 'c
val apnth = fn: ('a -> 'a) -> int -> 'a list -> 'a list
val append = fn: 'a list -> 'a list -> 'a list
val appi = fn: (int -> 'a -> unit) -> 'a list -> unit
val apropos = fn: term -> DB.data list
val apropos_in = fn: term -> DB.data list -> DB.data list
val apsnd = fn: ('a -> 'b) -> 'c * 'a -> 'c * 'b
val arb = “ARB”: term
val arith_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern  “(λx. y) z”
Congruence rules:
   |- (v = v') ⇒ (literal_case f v = literal_case f (I v'))
Rewrite rules:
   |- ∀x. (x = x) ⇔ T
   |- ∀t.
        ((T ⇔ t) ⇔ t) ∧ ((t ⇔ T) ⇔ t) ∧ ((F ⇔ t) ⇔ ¬t) ∧ ((t ⇔ F) ⇔ ¬t)
   |- (∀t. ¬ ¬t ⇔ t) ∧ (¬T ⇔ F) ∧ (¬F ⇔ T)
   |- ∀t.
        (T ∧ t ⇔ t) ∧ (t ∧ T ⇔ t) ∧ (F ∧ t ⇔ F) ∧ (t ∧ F ⇔ F) ∧
        (t ∧ t ⇔ t)
   |- ∀t.
        (T ∨ t ⇔ T) ∧ (t ∨ T ⇔ T) ∧ (F ∨ t ⇔ t) ∧ (t ∨ F ⇔ t) ∧
        (t ∨ t ⇔ t)
   |- ∀t.
        (T ⇒ t ⇔ t) ∧ (t ⇒ T ⇔ T) ∧ (F ⇒ t ⇔ T) ∧ (t ⇒ t ⇔ T) ∧
        (t ⇒ F ⇔ ¬t)
   |- ∀t1 t2.
        ((if T then t1 else t2) = t1) ∧ ((if F then t1 else t2) = t2)
   |- ∀t. (∀x. t) ⇔ t
   |- ∀t. (∃x. t) ⇔ t
   |- ∀b t. (if b then t else t) = t
   |- ∀a. ∃x. x = a
   |- ∀a. ∃x. a = x
   |- ∀a. ∃!x. x = a
   |- ∀a. ∃!x. a = x
   |- (∀b e. (if b then T else e) ⇔ b ∨ e) ∧
      (∀b t. (if b then t else T) ⇔ b ⇒ t) ∧
      (∀b e. (if b then F else e) ⇔ ¬b ∧ e) ∧
      ∀b t. (if b then t else F) ⇔ b ∧ t
   |- literal_case f (I x) = f x
   |- ∀t. t ∨ ¬t
   |- ∀t. ¬t ∨ t
   |- (∀t1 t2. (if T then t1 else t2) = t1) ∧
      ∀t1 t2. (if F then t1 else t2) = t2
   |- ¬(t ∧ ¬t)
   |- ∀x. (@y. y = x) = x
   |- ∀x. (@y. x = y) = x
   |- (∀x::P. T) ⇔ T
   |- (∃x::P. F) ⇔ F

Simplification set: NOT
Rewrite rules:
   |- ∀A B. ¬(A ⇒ B) ⇔ A ∧ ¬B
   |- ∀A B. (¬(A ∧ B) ⇔ ¬A ∨ ¬B) ∧ (¬(A ∨ B) ⇔ ¬A ∧ ¬B)
   |- ∀P. ¬(∀x. P x) ⇔ ∃x. ¬P x
   |- ∀P. ¬(∃x. P x) ⇔ ∀x. ¬P x
   |- (¬p ⇔ ¬q) ⇔ (p ⇔ q)

Simplification set: CONG
Congruence rules:
   |- ∀x x' y y'. (x ⇔ x') ⇒ (x' ⇒ (y ⇔ y')) ⇒ (x ⇒ y ⇔ x' ⇒ y')
   |- ∀P Q x x' y y'.
        (P ⇔ Q) ⇒
        (Q ⇒ (x = x')) ⇒
        (¬Q ⇒ (y = y')) ⇒
        ((if P then x else y) = if Q then x' else y')
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_FORALL P f ⇔ RES_FORALL Q g)
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_EXISTS P f ⇔ RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  “∃x. P”
   UNWIND_FORALL_CONV, keyed on pattern  “∀x. P”

Simplification set: PAIR
Rewrite rules:
   |- ∀x. (FST x,SND x) = x
   |- ∀x y. FST (x,y) = x
   |- ∀x y. SND (x,y) = y
   |- ∀x y a b. ((x,y) = (a,b)) ⇔ (x = a) ∧ (y = b)
   |- ∀f. CURRY (UNCURRY f) = f
   |- ∀f. UNCURRY (CURRY f) = f
   |- (CURRY f = CURRY g) ⇔ (f = g)
   |- (UNCURRY f = UNCURRY g) ⇔ (f = g)
   |- ∀f x y. CURRY f x y = f (x,y)
   |- ∀f g x y. (f ## g) (x,y) = (f x,g y)
   |- ∀f x y. UNCURRY f (x,y) = f x y

Simplification set: option
Rewrite rules:
   |- ∀x y. (SOME x = SOME y) ⇔ (x = y)
   |- ∀x. option_CASE x x SOME = x
   |- (OPTION_JOIN NONE = NONE) ∧ ∀x. OPTION_JOIN (SOME x) = x
   |- (∀v f. option_CASE NONE v f = v) ∧
      ∀x v f. option_CASE (SOME x) v f = f x
   |- ∀x. THE (SOME x) = x
   |- ∀x. option_CASE x NONE SOME = x
   |- ∀x. ¬IS_SOME x ⇔ (x = NONE)
   |- ∀x. IS_NONE x ⇔ (x = NONE)
   |- (∀x. IS_SOME (SOME x) ⇔ T) ∧ (IS_SOME NONE ⇔ F)
   |- ((some x. x = y) = SOME y) ∧ ((some x. y = x) = SOME y)
   |- (∀P. OPTION_ALL P NONE ⇔ T) ∧ ∀P x. OPTION_ALL P (SOME x) ⇔ P x
   |- (some x. F) = NONE
   |- (∀x. R x x) ⇒ ∀x. OPTREL R x x
   |- ((OPTION_MAP f x = NONE) ⇔ (x = NONE)) ∧
      ((NONE = OPTION_MAP f x) ⇔ (x = NONE))
   |- (∀x. NONE <*> x = NONE) ∧ ∀f x. SOME f <*> x = OPTION_MAP f x
   |- OPTION_CHOICE m1 NONE = m1
   |- (∀m2. OPTION_CHOICE NONE m2 = m2) ∧
      ∀x m2. OPTION_CHOICE (SOME x) m2 = SOME x
   |- ((OPTION_GUARD b = SOME ()) ⇔ b) ∧ ((OPTION_GUARD b = NONE) ⇔ ¬b)
   |- (OPTION_GUARD T = SOME ()) ∧ (OPTION_GUARD F = NONE)
   |- ((OPTION_IGNORE_BIND m1 m2 = NONE) ⇔ (m1 = NONE) ∨ (m2 = NONE)) ∧
      ((OPTION_IGNORE_BIND m1 m2 = SOME y) ⇔
       ∃x. (m1 = SOME x) ∧ (m2 = SOME y))
   |- (OPTION_IGNORE_BIND NONE m = NONE) ∧
      (OPTION_IGNORE_BIND (SOME v) m = m)
   |- ((OPTION_BIND p f = NONE) ⇔
       (p = NONE) ∨ ∃x. (p = SOME x) ∧ (f x = NONE)) ∧
      ((OPTION_BIND p f = SOME y) ⇔ ∃x. (p = SOME x) ∧ (f x = SOME y))
   |- (∀f. OPTION_BIND NONE f = NONE) ∧
      ∀x f. OPTION_BIND (SOME x) f = f x
   |- (OPTION_MAP2 f o1 o2 = NONE) ⇔ (o1 = NONE) ∨ (o2 = NONE)
   |- (OPTION_MAP2 f o1 o2 = SOME v) ⇔
      ∃x1 x2. (o1 = SOME x1) ∧ (o2 = SOME x2) ∧ (v = f x1 x2)
   |- ∀f x y. (OPTION_MAP f x = SOME y) ⇔ ∃z. (x = SOME z) ∧ (y = f z)
   |- (((if P then SOME x else NONE) = NONE) ⇔ ¬P) ∧
      (((if P then NONE else SOME x) = NONE) ⇔ P) ∧
      (((if P then SOME x else NONE) = SOME y) ⇔ P ∧ (x = y)) ∧
      (((if P then NONE else SOME x) = SOME y) ⇔ ¬P ∧ (x = y))
   |- (((if P then X else NONE) = NONE) ⇔ P ⇒ IS_NONE X) ∧
      (((if P then NONE else X) = NONE) ⇔ IS_SOME X ⇒ P) ∧
      (((if P then X else NONE) = SOME x) ⇔ P ∧ (X = SOME x)) ∧
      (((if P then NONE else X) = SOME x) ⇔ ¬P ∧ (X = SOME x))
   |- ∀x. NONE ≠ SOME x
   |- (OPTION_MAP2 f (SOME x) (SOME y) = SOME (f x y)) ∧
      (OPTION_MAP2 f (SOME x) NONE = NONE) ∧
      (OPTION_MAP2 f NONE (SOME y) = NONE) ∧
      (OPTION_MAP2 f NONE NONE = NONE)
   |- (∀f x. OPTION_MAP f (SOME x) = SOME (f x)) ∧
      ∀f. OPTION_MAP f NONE = NONE

Simplification set: REDUCE
Conversions:
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “EVEN x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “ODD x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “PRE x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “SUC x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “DIV2 x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x * y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x + y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x − y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x DIV y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x MOD y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ** y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x < y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ≤ y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x > y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ≥ y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “MIN x y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “MAX x y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x = y”

Simplification set: sum
Rewrite rules:
   |- (∀y x. (INL x = INL y) ⇔ (x = y)) ∧
      ∀y x. (INR x = INR y) ⇔ (x = y)
   |- (∀P Q x. SUM_ALL P Q (INL x) ⇔ P x) ∧
      ∀P Q y. SUM_ALL P Q (INR y) ⇔ Q y
   |- (∀f g a. (f ++ g) (INL a) = INL (f a)) ∧
      ∀f g b. (f ++ g) (INR b) = INR (g b)
   |- ∀x. ¬ISR x ⇔ ISL x
   |- ∀x. ¬ISL x ⇔ ISR x
   |- (∀x y z. ((if P then INR x else INL y) = INR z) ⇔ P ∧ (z = x)) ∧
      (∀x y z. ((if P then INR x else INL y) = INL z) ⇔ ¬P ∧ (z = y)) ∧
      (∀x y z. ((if P then INL x else INR y) = INL z) ⇔ P ∧ (z = x)) ∧
      ∀x y z. ((if P then INL x else INR y) = INR z) ⇔ ¬P ∧ (z = y)
   |- (∀x f f1. sum_CASE (INL x) f f1 = f x) ∧
      ∀y f f1. sum_CASE (INR y) f f1 = f1 y
   |- ∀x. OUTL (INL x) = x
   |- ∀x. ISR x ⇒ (INR (OUTR x) = x)
   |- ∀x. ISL x ⇒ (INL (OUTL x) = x)
   |- ∀x. OUTR (INR x) = x
   |- (∀x. ISL (INL x)) ∧ ∀y. ¬ISL (INR y)
   |- (∀x. ISR (INR x)) ∧ ∀y. ¬ISR (INL y)
   |- ∀x y. INL x ≠ INR y

Simplification set: COMBIN
Rewrite rules:
   |- ∀x. I x = x
   |- ∀f. (I ∘ f = f) ∧ (f ∘ I = f)
   |- ∀x y. K x y = x
   |- ∀f g x. S f g x = f x (g x)
   |- ∀f g h. (f ∘ g) ∘ h = f ∘ g ∘ h
   |- ∀f g x. (f ∘ g) x = f (g x)
   |- ∀f x. W f x = f x x
   |- ∀f x y. combin$C f x y = f y x
   |- (∀f v. K v ∘ f = K v) ∧ ∀f v. f ∘ K v = K (f v)

Simplification set: ARITH_RWTS
Rewrite rules:
   |- ∀x. ((SUC x = 1) ⇔ (x = 0)) ∧ ((1 = SUC x) ⇔ (x = 0))
   |- ∀x. ((SUC x = 2) ⇔ (x = 1)) ∧ ((2 = SUC x) ⇔ (x = 1))
   |- ∀m. m + 0 = m
   |- ∀m. 0 + m = m
   |- ∀m n. (m + n = 0) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (0 = m + n) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (m + n = m) ⇔ (n = 0)
   |- ∀m n. (n + m = m) ⇔ (n = 0)
   |- ∀m n. (m * n = 0) ⇔ (m = 0) ∨ (n = 0)
   |- ∀m n. (0 = m * n) ⇔ (m = 0) ∨ (n = 0)
   |- ∀x y. (x * y = 1) ⇔ (x = 1) ∧ (y = 1)
   |- ∀x y. (1 = x * y) ⇔ (x = 1) ∧ (y = 1)
   |- ∀m. m * 0 = 0
   |- ∀m. 0 * m = 0
   |- ∀x y. (x * y = SUC 0) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀x y. (SUC 0 = x * y) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀m. m * 1 = m
   |- ∀m. 1 * m = m
   |- ∀c. c − c = 0
   |- ∀m. SUC m − 1 = m
   |- ∀m. (0 − m = 0) ∧ (m − 0 = m)
   |- ∀a c. a + c − c = a
   |- ∀a c. c + a − c = a
   |- ∀m n. (m − n = 0) ⇔ m ≤ n
   |- ∀m n. (0 = m − n) ⇔ m ≤ n
   |- ∀n m. n − m ≤ n
   |- ∀n m. SUC n − SUC m = n − m
   |- ∀m n p. m − n > p ⇔ m > n + p
   |- ∀m n p. m − n < p ⇔ m < n + p ∧ 0 < p
   |- ∀m n p. m − n ≥ p ⇔ m ≥ n + p ∨ 0 ≥ p
   |- ∀m n p. m − n ≤ p ⇔ m ≤ n + p
   |- (PRE 0 = 0) ∧ ∀m. PRE (SUC m) = m
   |- ∀n m. (n ** m = 0) ⇔ (n = 0) ∧ 0 < m
   |- ∀n. (1 ** n = 1) ∧ (n ** 1 = n)
   |- ∀n m. (n ** m = 1) ⇔ (n = 1) ∨ (m = 0)
   |- 0 < x ** y ⇔ 0 < x ∨ (y = 0)
   |- ∀b1 b2 x. (b1 ** x = b2 ** x) ⇔ (x = 0) ∨ (b1 = b2)
   |- ∀b. 1 < b ⇒ ∀n m. (b ** n = b ** m) ⇔ (n = m)
   |- ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n
   |- ∀b. 1 < b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n
   |- ∀a b. a ** n < b ** n ⇔ a < b ∧ 0 < n
   |- ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ (n = 0)
   |- ∀n. n ≤ 0 ⇔ (n = 0)
   |- ∀n. 0 < SUC n
   |- ∀m n. m ≤ m + n
   |- 0 ≤ x
   |- SUC x > 0
   |- x ≥ 0
   |- x < SUC x
   |- x ≤ SUC x
   |- x < x + c ⇔ 0 < c
   |- x < c + x ⇔ 0 < c
   |- x ≤ x + c ⇔ 0 ≤ c
   |- x ≤ c + x ⇔ 0 ≤ c
   |- ∀m. m ≤ m
   |- x ≥ x
   |- ∀m n p. m + p < n + p ⇔ m < n
   |- ∀m n p. p + m < p + n ⇔ m < n
   |- ∀m n p. m + n ≤ m + p ⇔ n ≤ p
   |- ∀m n p. n + m ≤ p + m ⇔ n ≤ p
   |- ∀m n p. (m + p = n + p) ⇔ (m = n)
   |- ∀m n p. (p + m = p + n) ⇔ (m = n)
   |- x + y < w + x ⇔ y < w
   |- y + x < x + w ⇔ y < w
   |- ∀m n. (SUC m = SUC n) ⇔ (m = n)
   |- ∀m n. SUC m < SUC n ⇔ m < n
   |- ∀n m. SUC n ≤ SUC m ⇔ n ≤ m
   |- ∀m i n. SUC n * m < SUC n * i ⇔ m < i
   |- ∀p m n. (n * SUC p = m * SUC p) ⇔ (n = m)
   |- ∀m i n. (SUC n * m = SUC n * i) ⇔ (m = i)
   |- ∀n m. ¬(SUC n ≤ m) ⇔ m ≤ n
   |- ∀p q n m. (n * SUC q ** p = m * SUC q ** p) ⇔ (n = m)
   |- ∀m n p. m * n ≤ m * p ⇔ (m = 0) ∨ n ≤ p
   |- ∀m n p. m * n ≤ p * n ⇔ (n = 0) ∨ m ≤ p
   |- ∀m n p. m * n < m * p ⇔ 0 < m ∧ n < p
   |- ∀m n p. m * n < p * n ⇔ 0 < n ∧ m < p
   |- (m < m * n ⇔ 0 < m ∧ 1 < n) ∧ (m < n * m ⇔ 0 < m ∧ 1 < n)
   |- (m * n < m ⇔ 0 < m ∧ (n = 0)) ∧ (m * n < n ⇔ 0 < n ∧ (m = 0))
   |- (m ≤ m * n ⇔ (m = 0) ∨ 0 < n) ∧ (m ≤ n * m ⇔ (m = 0) ∨ 0 < n)
   |- (m * n ≤ m ⇔ (m = 0) ∨ n ≤ 1) ∧ (m * n ≤ n ⇔ (n = 0) ∨ m ≤ 1)
   |- ∀m n. SUC n ** m ≠ 0
   |- ∀n m. SUC (n + n) ≠ m + m
   |- ∀m n. ¬(SUC (m + n) ≤ m)
   |- ∀n. ¬(SUC n ≤ 0)
   |- ∀n. ¬(n < 0)
   |- ∀n. ¬(n < n)
   |- ¬(x > x)
   |- ∀n. (MIN n 0 = 0) ∧ (MIN 0 n = 0)
   |- ∀n. (MAX n 0 = n) ∧ (MAX 0 n = n)
   |- ∀n. MIN n n = n
   |- ∀n. MAX n n = n
   |- ∀n m p.
        (MIN m n ≤ p ⇔ m ≤ p ∨ n ≤ p) ∧ (p ≤ MIN m n ⇔ p ≤ m ∧ p ≤ n)
   |- ∀n m p.
        (p ≤ MAX m n ⇔ p ≤ m ∨ p ≤ n) ∧ (MAX m n ≤ p ⇔ m ≤ p ∧ n ≤ p)
   |- ∀n m p.
        (MIN m n < p ⇔ m < p ∨ n < p) ∧ (p < MIN m n ⇔ p < m ∧ p < n)
   |- ∀n m p.
        (p < MAX m n ⇔ p < m ∨ p < n) ∧ (MAX m n < p ⇔ m < p ∧ n < p)
   |- ∀m n. (MIN m n = MAX m n) ⇔ (m = n)
   |- ∀m n. MIN m n < MAX m n ⇔ m ≠ n
   |- ∀x y. 0 < y ⇒ ((x MOD y = x) ⇔ x < y)
   |- ∀n. 0 < n ⇒ (n DIV n = 1) ∧ (n MOD n = 0)
   |- ∀q. q DIV 1 = q
   |- ∀k. k MOD 1 = 0
   |- ∀n k. k < n ⇒ (k MOD n = k)
   |- ∀n. 0 < n ⇒ (0 MOD n = 0)
   |- ∀n. 0 < n ⇒ ∀k. k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT1 x) = 0)) ∧
      ((NUMERAL (BIT2 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT2 x) = 0))
   |- ∀m n. 0 < n ⇒ m MOD n < n
   |- ∀n d. 0 < n ∧ 1 < d ⇒ n DIV d < n

Simplification set: ARITH_DP
Conversions:
   MUL_CANON_CONV, keyed on pattern  “x * y”
Decision procedures:
   ARITH_REDUCER

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER
:
   simpset
val asm_rewrite_tac = fn: thm list -> tactic
val asm_simp_tac = fn: simpset -> thm list -> tactic
val assert = fn: ('a -> bool) -> 'a -> 'a
val assert_exn = fn: ('a -> bool) -> 'a -> exn -> 'a
val assoc = fn: ''a -> (''a * 'b) list -> 'b
val assoc1 = fn: ''a -> (''a * 'b) list -> (''a * 'b) option
val assoc2 = fn: ''a -> ('b * ''a) list -> ('b * ''a) option
val assoc_tm =
   “f x (f y z) = f (f x y) z”:
   term
val associate_restriction = fn: string * string -> unit
eqtype associativity
val assume_tac = fn: thm_tactic
val augment_srw_ss = fn: ssfrag list -> unit
val axiom = fn: string -> thm
val axioms = fn: string -> (string * thm) list
val beta = “:β”: hol_type
val beta_conv = fn: term -> term
val bindl = fn: string -> (string * thm * class) list -> unit
type block_info = term_grammar.block_info
val body = fn: term -> term
val bool = “:bool”: hol_type
val boolAxiom =
   |- ∀t1 t2. ∃fn. (fn T = t1) ∧ (fn F = t2):
   thm
val bool_EQ_CONV = fn: conv
val bool_INDUCT =
   |- ∀P. P T ∧ P F ⇒ ∀b. P b:
   thm
val bool_case = “COND”:
   term
val bool_case_CONG =
   |- ∀P Q x x' y y'.
     (P ⇔ Q) ∧ (Q ⇒ (x = x')) ∧ (¬Q ⇒ (y = y')) ⇒
     ((if P then x else y) = if Q then x' else y'):
   thm
val bool_case_ID =
   |- ∀b t. (if b then t else t) = t:
   thm
val bool_case_thm =
   |- (∀t1 t2. (if T then t1 else t2) = t1) ∧
   ∀t1 t2. (if F then t1 else t2) = t2:
   thm
val bool_compare = fn: bool cmp
val bool_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
         TY  ::=  bool | (TY, TY)fun | ind | TY itself
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             ,
    (0)    TM  ::=  "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "∉" TM  [NOTIN] | TM "NOTIN" TM | TM "∈" TM  [IN] |
                TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≠" TM | TM "<>" TM   (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
   _ fakeconst4.case,S10.case magic,7.default ! /\ <=/=> <=> <> = ==> ?
  ?! @ ARB BOUNDED COND DATATYPE F IN LET NOTIN ONE_ONE ONTO
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT T
  TYPE_DEFINITION \/ case itself_case literal_case the_value ~ ≠
Overloading:
  <=/=> ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>   ->  =
  <>    ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  NOTIN ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  case  ->  itself_case literal_case COND
  ≠     ->  (λ(x :α) (y :α). bool$~ (min$= x y))
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET):
   type_grammar.grammar * term_grammar.grammar
val bool_rewrites =
   |- (x = x) ⇔ T;  |- (T ⇔ t) ⇔ t;  |- (t ⇔ T) ⇔ t;  |- (F ⇔ t) ⇔ ¬t;
|- (t ⇔ F) ⇔ ¬t;  |- ¬ ¬t ⇔ t;  |- ¬T ⇔ F;  |- ¬F ⇔ T;  |- T ∧ t ⇔ t;
|- t ∧ T ⇔ t;  |- F ∧ t ⇔ F;  |- t ∧ F ⇔ F;  |- t ∧ t ⇔ t;
|- T ∨ t ⇔ T;  |- t ∨ T ⇔ T;  |- F ∨ t ⇔ t;  |- t ∨ F ⇔ t;
|- t ∨ t ⇔ t;  |- T ⇒ t ⇔ t;  |- t ⇒ T ⇔ T;  |- F ⇒ t ⇔ T;
|- t ⇒ t ⇔ T;  |- t ⇒ F ⇔ ¬t;  |- (if T then t1 else t2) = t1;
|- (if F then t1 else t2) = t2;  |- (∀x. t) ⇔ t;  |- (∃x. t) ⇔ t;
|- (λx. t1) t2 = t1
Number of rewrite rules = 28
:
   rewrites
val bool_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern  “(λx. y) z”
Congruence rules:
   |- (v = v') ⇒ (literal_case f v = literal_case f (I v'))
Rewrite rules:
   |- ∀x. (x = x) ⇔ T
   |- ∀t.
        ((T ⇔ t) ⇔ t) ∧ ((t ⇔ T) ⇔ t) ∧ ((F ⇔ t) ⇔ ¬t) ∧ ((t ⇔ F) ⇔ ¬t)
   |- (∀t. ¬ ¬t ⇔ t) ∧ (¬T ⇔ F) ∧ (¬F ⇔ T)
   |- ∀t.
        (T ∧ t ⇔ t) ∧ (t ∧ T ⇔ t) ∧ (F ∧ t ⇔ F) ∧ (t ∧ F ⇔ F) ∧
        (t ∧ t ⇔ t)
   |- ∀t.
        (T ∨ t ⇔ T) ∧ (t ∨ T ⇔ T) ∧ (F ∨ t ⇔ t) ∧ (t ∨ F ⇔ t) ∧
        (t ∨ t ⇔ t)
   |- ∀t.
        (T ⇒ t ⇔ t) ∧ (t ⇒ T ⇔ T) ∧ (F ⇒ t ⇔ T) ∧ (t ⇒ t ⇔ T) ∧
        (t ⇒ F ⇔ ¬t)
   |- ∀t1 t2.
        ((if T then t1 else t2) = t1) ∧ ((if F then t1 else t2) = t2)
   |- ∀t. (∀x. t) ⇔ t
   |- ∀t. (∃x. t) ⇔ t
   |- ∀b t. (if b then t else t) = t
   |- ∀a. ∃x. x = a
   |- ∀a. ∃x. a = x
   |- ∀a. ∃!x. x = a
   |- ∀a. ∃!x. a = x
   |- (∀b e. (if b then T else e) ⇔ b ∨ e) ∧
      (∀b t. (if b then t else T) ⇔ b ⇒ t) ∧
      (∀b e. (if b then F else e) ⇔ ¬b ∧ e) ∧
      ∀b t. (if b then t else F) ⇔ b ∧ t
   |- literal_case f (I x) = f x
   |- ∀t. t ∨ ¬t
   |- ∀t. ¬t ∨ t
   |- (∀t1 t2. (if T then t1 else t2) = t1) ∧
      ∀t1 t2. (if F then t1 else t2) = t2
   |- ¬(t ∧ ¬t)
   |- ∀x. (@y. y = x) = x
   |- ∀x. (@y. x = y) = x
   |- (∀x::P. T) ⇔ T
   |- (∃x::P. F) ⇔ F

Simplification set: NOT
Rewrite rules:
   |- ∀A B. ¬(A ⇒ B) ⇔ A ∧ ¬B
   |- ∀A B. (¬(A ∧ B) ⇔ ¬A ∨ ¬B) ∧ (¬(A ∨ B) ⇔ ¬A ∧ ¬B)
   |- ∀P. ¬(∀x. P x) ⇔ ∃x. ¬P x
   |- ∀P. ¬(∃x. P x) ⇔ ∀x. ¬P x
   |- (¬p ⇔ ¬q) ⇔ (p ⇔ q)

Simplification set: CONG
Congruence rules:
   |- ∀x x' y y'. (x ⇔ x') ⇒ (x' ⇒ (y ⇔ y')) ⇒ (x ⇒ y ⇔ x' ⇒ y')
   |- ∀P Q x x' y y'.
        (P ⇔ Q) ⇒
        (Q ⇒ (x = x')) ⇒
        (¬Q ⇒ (y = y')) ⇒
        ((if P then x else y) = if Q then x' else y')
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_FORALL P f ⇔ RES_FORALL Q g)
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_EXISTS P f ⇔ RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  “∃x. P”
   UNWIND_FORALL_CONV, keyed on pattern  “∀x. P”
:
   simpset
val bounded_tm = “BOUNDED”:
   term
val bring_to_front_overload = fn:
   string -> {Name: string, Thy: string} -> unit
val butlast = fn: 'a list -> 'a list
val bvar = fn: term -> term
val bvk_find_term = fn:
   (term list * term -> bool) -> (term -> 'a) -> term -> 'a option
val by = fn: term quotation * tactic -> tactic
val can = fn: ('a -> 'b) -> 'a -> bool
val case_cong_thm = fn: thm -> thm -> thm
val case_constant_defn_name = fn: {type_name: string} -> string
val case_constant_name = fn: {type_name: string} -> string
val cheat = fn: tactic
val checking_const_names = ref true: bool ref
val checking_type_names = ref true: bool ref
datatype class = Axm | Def | Thm
val clear_overloads_on = fn: string -> unit
type 'a cmp = 'a * 'a -> order
val combine = fn: 'a list * 'b list -> ('a * 'b) list
val comm_tm =
   “f x y = f y x”:
   term
val commafy = fn: string list -> string list
val compare = fn: term * term -> order
val completeInduct_on = fn: term quotation -> tactic
val concl = fn: thm -> term
val conditional =
   “COND”: term
val condprinter = fn: term_grammar.userprinter
val conj_asm1_tac = fn: tactic
val conj_asm2_tac = fn: tactic
val conj_tac = fn: tactic
val conjunction = “$/\”:
   term
val cons = fn: 'a -> 'a list -> 'a list
val constants = fn: string -> term list
datatype control = BOUNDED of int ref | UNBOUNDED
type controlled_thm = thm * control
type conv = term -> thm
val csimp = fn: thm list -> tactic
val current_ML_deps = fn: unit -> string list
val current_axioms = fn: unit -> (string * thm) list
val current_backend =
   ref
      {add_break = fn, add_newline = fn, add_string = fn, add_xstring = fn,
       begin_block = fn, begin_style = fn, end_block = fn, end_style = fn,
       name = "emacs_terminal", tm_grammar_upd = fn, ty_grammar_upd = fn}:
   PPBackEnd.t ref
val current_data = fn: string -> (string * thm) list
val current_definitions = fn: unit -> (string * thm) list
val current_grammars = fn:
   unit -> type_grammar.grammar * term_grammar.grammar
val current_theorems = fn: unit -> (string * thm) list
val current_theory = fn: unit -> string
val current_trace = fn: string -> int
val curry = fn: ('a * 'b -> 'c) -> 'a -> 'b -> 'c
type data
val data_exportfn = fn:
   string -> (string -> (string * thm) list -> unit) option
val data_list_to_string = fn: DB.data list -> string
val data_storefn = fn: string -> (string -> unit) option
val decide_tac = fn: tactic
val decls = fn: string -> term list
val def_suffix = ref "_def": string ref
val default_prover = fn: term * tactic -> thm
val define_case_constant = fn: thm -> thm list
val define_new_type_bijections = fn:
   {ABS: string, REP: string, name: string, tyax: thm} -> thm
val definition = fn: string -> thm
val definitions = fn: string -> (string * thm) list
type defn
val deinitcomment = fn: string -> string
val deinitcommentss = fn: substring -> substring
val del_segment = fn: string -> unit
val delete_binding = fn: string -> unit
val delete_const = fn: string -> unit
val delete_hook = fn: string -> unit
val delete_type = fn: string -> unit
datatype 'a delta = DIFF of 'a | SAME
val delta = “:δ”: hol_type
val delta_apply = fn: ('a -> 'a delta) -> 'a -> 'a
val delta_map = fn: ('a -> 'a delta) -> 'a list -> 'a list delta
val delta_pair = fn:
   ('a -> 'a delta) -> ('b -> 'b delta) -> 'a * 'b -> ('a * 'b) delta
type depdisk = (string * int) * (string * int list) list
val dest_IN = fn: term -> term * term
val dest_abs = fn: term -> term * term
val dest_arb = fn: term -> hol_type
val dest_binder = fn: term -> exn -> term -> term * term
val dest_binop = fn: term -> exn -> term -> term * term
val dest_bool_case = fn: term -> term * term * term
val dest_comb = fn: term -> term * term
val dest_cond = fn: term -> term * term * term
val dest_conj = fn: term -> term * term
val dest_const = fn: term -> string * hol_type
val dest_disj = fn: term -> term * term
val dest_eq = fn: term -> term * term
val dest_eq_ty = fn: term -> term * term * hol_type
val dest_exists = fn: term -> term * term
val dest_exists1 = fn: term -> term * term
val dest_forall = fn: term -> term * term
val dest_imp = fn: term -> term * term
val dest_imp_only = fn: term -> term * term
val dest_itself = fn: term -> hol_type
val dest_let = fn: term -> term * term
val dest_literal_case = fn: term -> term * term
val dest_monop = fn: term -> exn -> term -> term
val dest_neg = fn: term -> term
val dest_quadop = fn: term -> exn -> term -> term * term * term * term
val dest_res_abstract = fn: term -> term * term * term
val dest_res_exists = fn: term -> term * term * term
val dest_res_exists_unique = fn: term -> term * term * term
val dest_res_forall = fn: term -> term * term * term
val dest_res_select = fn: term -> term * term * term
val dest_rewrites = fn: rewrites -> thm list
val dest_select = fn: term -> term * term
val dest_strip_comb = fn: term -> string * term list
val dest_tagged_rewrite = fn: thm -> controlled_thm
val dest_temp_binding = fn: string -> string
val dest_term = fn: term -> lambda
val dest_theory = fn: string -> theory
val dest_thm = fn: thm -> term list * term
val dest_thy_const = fn: term -> {Name: string, Thy: string, Ty: hol_type}
val dest_thy_type = fn:
   hol_type -> {Args: hol_type list, Thy: string, Tyop: string}
val dest_triop = fn: term -> exn -> term -> term * term * term
val dest_type = fn: hol_type -> string * hol_type list
val dest_var = fn: term -> string * hol_type
val dest_vartype = fn: hol_type -> string
val dict_topsort = fn: ('a, 'a list) Redblackmap.dict -> 'a list
val diminish_srw_ss = fn: string list -> ssfrag list
val disable_hook = fn: string -> ('a -> 'b) -> 'a -> 'b
val disable_tyabbrev_printing = fn: string -> unit
val disch = fn: term * term list -> term list
val disch_then = fn: thm_tactic -> tactic
val disj1_tac = fn: tactic
val disj2_tac = fn: tactic
val disjunction = “$\/”:
   term
val disk_thm = fn: (depdisk * string list) * term list -> thm
val dom_rng = fn: hol_type -> hol_type * hol_type
val doms_of_tyaxiom = fn: thm -> hol_type list
val dsimp = fn: thm list -> tactic
val el = fn: int -> 'a list -> 'a
val emitCAMLDir = ref "/usr/local/share/HOL/src/emit/Caml/": string ref
val emitMLDir = ref "/usr/local/share/HOL/src/emit/ML/": string ref
val emit_ERR = ref true: bool ref
val emit_MESG = ref true: bool ref
val emit_WARNING = ref true: bool ref
val empty_rewrites = <empty rule set>
Number of rewrite rules = 0
: rewrites
val empty_tmset = ?: term set
val empty_varset = ?: term set
val enable_hook = fn: string -> ('a -> 'b) -> 'a -> 'b
val end_itlist = fn: ('a -> 'a -> 'a) -> 'a list -> 'a
val end_real_time = fn: Timer.real_timer -> unit
val end_time = fn: Timer.cpu_timer -> unit
val enumerate = fn: int -> 'a list -> (int * 'a) list
val eq_tac = fn: tactic
val equal = fn: ''a -> ''a -> bool
val equality = “$=”: term
type error_record =
   {message: string, origin_function: string, origin_structure: string}
val eta_conv = fn: term -> term
val etyvar = “:ε”: hol_type
val existential = “$?”: term
val exists = fn: ('a -> bool) -> 'a list -> bool
val exists1 = “$?!”: term
val exists_tac = fn: term -> tactic
val exists_tyvar = fn: (hol_type -> bool) -> hol_type -> bool
val exn_to_string = fn: exn -> string
val export_mono = fn: string -> unit
val export_rewrites = fn: string list -> unit
val export_theorems_as_docfiles = fn: string -> (string * thm) list -> unit
val export_theory = fn: unit -> unit
val export_theory_as_docfiles = fn: string -> unit
val fail = fn: unit -> 'a
val failwith = fn: string -> 'a
val fetch = fn: string -> string -> thm
val filter = fn: ('a -> bool) -> 'a list -> 'a list
val find = fn: string -> DB.data list
val find_in = fn: string -> DB.data list -> DB.data list
val find_maximal_terms = fn: (term -> bool) -> term -> term set
val find_maximal_termsl = fn: (term -> bool) -> term -> term list
val find_term = fn: (term -> bool) -> term -> term
val find_terms = fn: (term -> bool) -> term -> term list
val first = fn: ('a -> bool) -> 'a list -> 'a
val first_assum = fn: thm_tactic -> tactic
val first_opt = fn: (int -> 'a -> 'b option) -> 'a list -> 'b option
val first_x_assum = fn: thm_tactic -> tactic
datatype fixity =
    Binder
  | Closefix
  | Infix of associativity * int
  | Prefix of int
  | Suffix of int
val fixity = fn: string -> fixity option
val fixityToString = fn: fixity -> string
val flatten = fn: 'a list list -> 'a list
val flip_cmp = fn: 'a cmp -> 'a cmp
val flip_order = fn: order -> order
val foldl_map = fn: ('a * 'b -> 'a * 'c) -> 'a * 'b list -> 'a * 'c list
val for = fn: int -> int -> (int -> 'a) -> 'a list
val for_se = fn: int -> int -> (int -> unit) -> unit
val format_ERR = fn: error_record -> string
val format_MESG = fn: string -> string
val format_WARNING = fn: string -> string -> string -> string
eqtype 'a frag
val free_in = fn: term -> term -> bool
val free_vars = fn: term -> term list
val free_vars_lr = fn: term -> term list
val free_varsl = fn: term list -> term list
val front_last = fn: 'a list -> 'a list * 'a
val fs = fn: thm list -> tactic
val fsrw_tac = fn: ssfrag list -> thm list -> tactic
val fst = fn: 'a * 'b -> 'a
val ftyvar = “:ζ”: hol_type
val full_simp_tac = fn: simpset -> thm list -> tactic
val funpow = fn: int -> ('a -> 'a) -> 'a -> 'a
val gamma = “:γ”: hol_type
val gen_all = fn: term -> term
val gen_find_term = fn: (term list * term -> 'a option) -> term -> 'a option
val gen_find_terms = fn: (term list * term -> 'a option) -> term -> 'a list
val gen_new_specification = fn: string * thm -> thm
val gen_prim_specification = fn: string -> thm -> string list * thm
val gen_remove_ovl_mapping = fn: string -> term -> unit
val gen_tac = fn: tactic
val gen_tyvar = fn: unit -> hol_type
val gen_variant = fn: (string -> bool) -> string -> term list -> term -> term
type ('a, 'b) gentactic = 'a -> goal list * (thm list -> 'b)
val genvar = fn: hol_type -> term
val genvars = fn: hol_type -> int -> term list
val get_first = fn: ('a -> 'b option) -> 'a list -> 'b option
val get_hooks = fn: unit -> (string * (TheoryDelta.t -> unit)) list
val get_term_printer = fn: unit -> ppstream -> term -> unit
val get_tracefn = fn: string -> unit -> int
val give_num_priority = fn: char -> unit
type goal = term list * term
val goal_assum = fn: thm_tactic -> tactic
val goal_line = ref "------------------------------------": string ref
val grammarDB = fn: string -> grammarDB_info option
val grammarDB_fold = fn: (string * grammarDB_info * 'a -> 'a) -> 'a -> 'a
type grammarDB_info = type_grammar.grammar * term_grammar.grammar
val grammarDB_insert = fn: string * grammarDB_info -> unit
val guessing_overloads = ref true: bool ref
val guessing_tyvars = ref true: bool ref
val hash = fn: int -> string -> int * int -> int
val hdtm_assum = fn: term -> thm_tactic -> tactic
val hdtm_x_assum = fn: term -> thm_tactic -> tactic
val hidden = fn: string -> bool
val hide = fn:
   string ->
     {Name: string, Thy: string} list * {Name: string, Thy: string} list
val ho_match_mp_tac = fn: thm -> tactic
val ho_match_term = fn:
   hol_type list ->
     term set ->
       term ->
         term ->
           {redex: term, residue: term} list * (hol_type, hol_type) Lib.subst
val ho_match_term0 = fn:
   hol_type list ->
     term set ->
       term ->
         term ->
           {redex: term, residue: int} list *
           {redex: term, residue: term} list *
           ((hol_type, hol_type) Lib.subst * hol_type list)
val hol_clock = ?: Timer.cpu_timer
eqtype hol_type
val html_theory = fn: string -> unit
val hyp = fn: thm -> term list
val hyp_frees = fn: thm -> term set
val hyp_tyvars = fn: thm -> hol_type set
val hypset = fn: thm -> term set
val idem_tm =
   “g (g x) = g x”:
   term
val imp_res_tac = fn: thm -> tactic
val impl_keep_tac = fn: tactic
val impl_tac = fn: tactic
val implication = “$==>”:
   term
val implicit_rewrites = fn: unit -> rewrites
val incorporate_consts = fn:
   string -> hol_type vector -> (string * int) list -> unit
val incorporate_types = fn: string -> (string * int) list -> unit
val ind = “:ind”: hol_type
val index = fn: ('a -> bool) -> 'a list -> int
val inferior_overload_on = fn: string * term -> unit
val insert = fn: ''a -> ''a list -> ''a list
val inst = fn: (hol_type, hol_type) Term.subst -> term -> term
val int_sort = fn: int list -> int list
val int_to_string = fn: int -> string
val interactive = ref true: bool ref
val interactive_ppbackend = fn: unit -> PPBackEnd.t
val intersect = fn: ''a list -> ''a list -> ''a list
val inv_img_cmp = fn: ('a -> 'b) -> 'b cmp -> 'a cmp
val irule = fn: thm -> tactic
val is_IN = fn: term -> bool
val is_abs = fn: term -> bool
val is_arb = fn: term -> bool
val is_bool_case = fn: term -> bool
val is_comb = fn: term -> bool
val is_cond = fn: term -> bool
val is_conj = fn: term -> bool
val is_const = fn: term -> bool
val is_constname = fn: string -> bool
val is_disj = fn: term -> bool
val is_eq = fn: term -> bool
val is_exists = fn: term -> bool
val is_exists1 = fn: term -> bool
val is_forall = fn: term -> bool
val is_gen_tyvar = fn: hol_type -> bool
val is_genvar = fn: term -> bool
val is_imp = fn: term -> bool
val is_imp_only = fn: term -> bool
val is_let = fn: term -> bool
val is_literal_case = fn: term -> bool
val is_neg = fn: term -> bool
val is_res_abstract = fn: term -> bool
val is_res_exists = fn: term -> bool
val is_res_exists_unique = fn: term -> bool
val is_res_forall = fn: term -> bool
val is_res_select = fn: term -> bool
val is_select = fn: term -> bool
val is_substring = fn: string -> string -> bool
val is_temp_binding = fn: string -> bool
val is_the_value = fn: term -> bool
val is_type = fn: hol_type -> bool
val is_var = fn: term -> bool
val is_vartype = fn: hol_type -> bool
type ('a, 'b) istream
val itlist = fn: ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val itlist2 = fn: ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val itself_Axiom =
   |- ∀e. ∃f. f (:β) = e:
   thm
val itself_TY_DEF =
   |- ∃rep. TYPE_DEFINITION ($= ARB) rep:
   thm
val itself_case_thm =
   |- ∀b. (case (:α) of (:α) => b) = b:
   thm
val itself_induction =
   |- ∀P. P (:α) ⇒ ∀i. P i:
   thm
val kall_tac = fn: 'a -> tactic
val kernelid = "stdknl": string
val known_constants = fn: unit -> string list
datatype lambda =
    COMB of term * term
  | CONST of {Name: string, Thy: string, Ty: hol_type}
  | LAMB of term * term
  | VAR of string * hol_type
val last = fn: 'a list -> 'a
val last_assum = fn: thm_tactic -> tactic
val last_x_assum = fn: thm_tactic -> tactic
val ldistrib_tm =
   “f x (g y z) = g (f x y) (f x z)”:
   term
val let_tm = “LET”: term
val lex_cmp = fn: 'a cmp * 'b cmp -> ('c -> 'a) * ('c -> 'b) -> 'c cmp
val lfs = fn: thm list -> tactic
val lhand = fn: term -> term
val lhs = fn: term -> term
val lift_bool = fn: hol_type -> bool -> term
val limit = fn: int -> simpset -> simpset
val linewidth = ref 72: int ref
val link_parents = fn:
   string * num * num -> (string * num * num) list -> unit
val listDB = fn: unit -> DB.data list
val list_compare = fn: 'a cmp -> 'a list cmp
val list_mk_abs = fn: term list * term -> term
val list_mk_binder = fn: term option -> term list * term -> term
val list_mk_comb = fn: term * term list -> term
val list_mk_conj = fn: term list -> term
val list_mk_disj = fn: term list -> term
val list_mk_exists = fn: term list * term -> term
val list_mk_forall = fn: term list * term -> term
val list_mk_fun = fn: hol_type list * hol_type -> hol_type
val list_mk_icomb = fn: term * term list -> term
val list_mk_imp = fn: term list * term -> term
val list_mk_lbinop = fn: ('a -> 'a -> 'a) -> 'a list -> 'a
val list_mk_rbinop = fn: ('a -> 'a -> 'a) -> 'a list -> 'a
val list_mk_res_exists = fn: (term * term) list * term -> term
val list_mk_res_forall = fn: (term * term) list * term -> term
val list_of_pair = fn: 'a * 'a -> 'a list
val list_of_quadruple = fn: 'a * 'a * 'a * 'a -> 'a list
val list_of_singleton = fn: 'a -> 'a list
val list_of_triple = fn: 'a * 'a * 'a -> 'a list
val list_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern  “(λx. y) z”
Congruence rules:
   |- (v = v') ⇒ (literal_case f v = literal_case f (I v'))
Rewrite rules:
   |- ∀x. (x = x) ⇔ T
   |- ∀t.
        ((T ⇔ t) ⇔ t) ∧ ((t ⇔ T) ⇔ t) ∧ ((F ⇔ t) ⇔ ¬t) ∧ ((t ⇔ F) ⇔ ¬t)
   |- (∀t. ¬ ¬t ⇔ t) ∧ (¬T ⇔ F) ∧ (¬F ⇔ T)
   |- ∀t.
        (T ∧ t ⇔ t) ∧ (t ∧ T ⇔ t) ∧ (F ∧ t ⇔ F) ∧ (t ∧ F ⇔ F) ∧
        (t ∧ t ⇔ t)
   |- ∀t.
        (T ∨ t ⇔ T) ∧ (t ∨ T ⇔ T) ∧ (F ∨ t ⇔ t) ∧ (t ∨ F ⇔ t) ∧
        (t ∨ t ⇔ t)
   |- ∀t.
        (T ⇒ t ⇔ t) ∧ (t ⇒ T ⇔ T) ∧ (F ⇒ t ⇔ T) ∧ (t ⇒ t ⇔ T) ∧
        (t ⇒ F ⇔ ¬t)
   |- ∀t1 t2.
        ((if T then t1 else t2) = t1) ∧ ((if F then t1 else t2) = t2)
   |- ∀t. (∀x. t) ⇔ t
   |- ∀t. (∃x. t) ⇔ t
   |- ∀b t. (if b then t else t) = t
   |- ∀a. ∃x. x = a
   |- ∀a. ∃x. a = x
   |- ∀a. ∃!x. x = a
   |- ∀a. ∃!x. a = x
   |- (∀b e. (if b then T else e) ⇔ b ∨ e) ∧
      (∀b t. (if b then t else T) ⇔ b ⇒ t) ∧
      (∀b e. (if b then F else e) ⇔ ¬b ∧ e) ∧
      ∀b t. (if b then t else F) ⇔ b ∧ t
   |- literal_case f (I x) = f x
   |- ∀t. t ∨ ¬t
   |- ∀t. ¬t ∨ t
   |- (∀t1 t2. (if T then t1 else t2) = t1) ∧
      ∀t1 t2. (if F then t1 else t2) = t2
   |- ¬(t ∧ ¬t)
   |- ∀x. (@y. y = x) = x
   |- ∀x. (@y. x = y) = x
   |- (∀x::P. T) ⇔ T
   |- (∃x::P. F) ⇔ F

Simplification set: NOT
Rewrite rules:
   |- ∀A B. ¬(A ⇒ B) ⇔ A ∧ ¬B
   |- ∀A B. (¬(A ∧ B) ⇔ ¬A ∨ ¬B) ∧ (¬(A ∨ B) ⇔ ¬A ∧ ¬B)
   |- ∀P. ¬(∀x. P x) ⇔ ∃x. ¬P x
   |- ∀P. ¬(∃x. P x) ⇔ ∀x. ¬P x
   |- (¬p ⇔ ¬q) ⇔ (p ⇔ q)

Simplification set: CONG
Congruence rules:
   |- ∀x x' y y'. (x ⇔ x') ⇒ (x' ⇒ (y ⇔ y')) ⇒ (x ⇒ y ⇔ x' ⇒ y')
   |- ∀P Q x x' y y'.
        (P ⇔ Q) ⇒
        (Q ⇒ (x = x')) ⇒
        (¬Q ⇒ (y = y')) ⇒
        ((if P then x else y) = if Q then x' else y')
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_FORALL P f ⇔ RES_FORALL Q g)
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_EXISTS P f ⇔ RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  “∃x. P”
   UNWIND_FORALL_CONV, keyed on pattern  “∀x. P”

Simplification set: PAIR
Rewrite rules:
   |- ∀x. (FST x,SND x) = x
   |- ∀x y. FST (x,y) = x
   |- ∀x y. SND (x,y) = y
   |- ∀x y a b. ((x,y) = (a,b)) ⇔ (x = a) ∧ (y = b)
   |- ∀f. CURRY (UNCURRY f) = f
   |- ∀f. UNCURRY (CURRY f) = f
   |- (CURRY f = CURRY g) ⇔ (f = g)
   |- (UNCURRY f = UNCURRY g) ⇔ (f = g)
   |- ∀f x y. CURRY f x y = f (x,y)
   |- ∀f g x y. (f ## g) (x,y) = (f x,g y)
   |- ∀f x y. UNCURRY f (x,y) = f x y

Simplification set: option
Rewrite rules:
   |- ∀x y. (SOME x = SOME y) ⇔ (x = y)
   |- ∀x. option_CASE x x SOME = x
   |- (OPTION_JOIN NONE = NONE) ∧ ∀x. OPTION_JOIN (SOME x) = x
   |- (∀v f. option_CASE NONE v f = v) ∧
      ∀x v f. option_CASE (SOME x) v f = f x
   |- ∀x. THE (SOME x) = x
   |- ∀x. option_CASE x NONE SOME = x
   |- ∀x. ¬IS_SOME x ⇔ (x = NONE)
   |- ∀x. IS_NONE x ⇔ (x = NONE)
   |- (∀x. IS_SOME (SOME x) ⇔ T) ∧ (IS_SOME NONE ⇔ F)
   |- ((some x. x = y) = SOME y) ∧ ((some x. y = x) = SOME y)
   |- (∀P. OPTION_ALL P NONE ⇔ T) ∧ ∀P x. OPTION_ALL P (SOME x) ⇔ P x
   |- (some x. F) = NONE
   |- (∀x. R x x) ⇒ ∀x. OPTREL R x x
   |- ((OPTION_MAP f x = NONE) ⇔ (x = NONE)) ∧
      ((NONE = OPTION_MAP f x) ⇔ (x = NONE))
   |- (∀x. NONE <*> x = NONE) ∧ ∀f x. SOME f <*> x = OPTION_MAP f x
   |- OPTION_CHOICE m1 NONE = m1
   |- (∀m2. OPTION_CHOICE NONE m2 = m2) ∧
      ∀x m2. OPTION_CHOICE (SOME x) m2 = SOME x
   |- ((OPTION_GUARD b = SOME ()) ⇔ b) ∧ ((OPTION_GUARD b = NONE) ⇔ ¬b)
   |- (OPTION_GUARD T = SOME ()) ∧ (OPTION_GUARD F = NONE)
   |- ((OPTION_IGNORE_BIND m1 m2 = NONE) ⇔ (m1 = NONE) ∨ (m2 = NONE)) ∧
      ((OPTION_IGNORE_BIND m1 m2 = SOME y) ⇔
       ∃x. (m1 = SOME x) ∧ (m2 = SOME y))
   |- (OPTION_IGNORE_BIND NONE m = NONE) ∧
      (OPTION_IGNORE_BIND (SOME v) m = m)
   |- ((OPTION_BIND p f = NONE) ⇔
       (p = NONE) ∨ ∃x. (p = SOME x) ∧ (f x = NONE)) ∧
      ((OPTION_BIND p f = SOME y) ⇔ ∃x. (p = SOME x) ∧ (f x = SOME y))
   |- (∀f. OPTION_BIND NONE f = NONE) ∧
      ∀x f. OPTION_BIND (SOME x) f = f x
   |- (OPTION_MAP2 f o1 o2 = NONE) ⇔ (o1 = NONE) ∨ (o2 = NONE)
   |- (OPTION_MAP2 f o1 o2 = SOME v) ⇔
      ∃x1 x2. (o1 = SOME x1) ∧ (o2 = SOME x2) ∧ (v = f x1 x2)
   |- ∀f x y. (OPTION_MAP f x = SOME y) ⇔ ∃z. (x = SOME z) ∧ (y = f z)
   |- (((if P then SOME x else NONE) = NONE) ⇔ ¬P) ∧
      (((if P then NONE else SOME x) = NONE) ⇔ P) ∧
      (((if P then SOME x else NONE) = SOME y) ⇔ P ∧ (x = y)) ∧
      (((if P then NONE else SOME x) = SOME y) ⇔ ¬P ∧ (x = y))
   |- (((if P then X else NONE) = NONE) ⇔ P ⇒ IS_NONE X) ∧
      (((if P then NONE else X) = NONE) ⇔ IS_SOME X ⇒ P) ∧
      (((if P then X else NONE) = SOME x) ⇔ P ∧ (X = SOME x)) ∧
      (((if P then NONE else X) = SOME x) ⇔ ¬P ∧ (X = SOME x))
   |- ∀x. NONE ≠ SOME x
   |- (OPTION_MAP2 f (SOME x) (SOME y) = SOME (f x y)) ∧
      (OPTION_MAP2 f (SOME x) NONE = NONE) ∧
      (OPTION_MAP2 f NONE (SOME y) = NONE) ∧
      (OPTION_MAP2 f NONE NONE = NONE)
   |- (∀f x. OPTION_MAP f (SOME x) = SOME (f x)) ∧
      ∀f. OPTION_MAP f NONE = NONE

Simplification set: REDUCE
Conversions:
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “EVEN x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “ODD x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “PRE x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “SUC x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “DIV2 x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x * y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x + y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x − y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x DIV y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x MOD y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ** y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x < y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ≤ y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x > y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ≥ y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “MIN x y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “MAX x y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x = y”

Simplification set: sum
Rewrite rules:
   |- (∀y x. (INL x = INL y) ⇔ (x = y)) ∧
      ∀y x. (INR x = INR y) ⇔ (x = y)
   |- (∀P Q x. SUM_ALL P Q (INL x) ⇔ P x) ∧
      ∀P Q y. SUM_ALL P Q (INR y) ⇔ Q y
   |- (∀f g a. (f ++ g) (INL a) = INL (f a)) ∧
      ∀f g b. (f ++ g) (INR b) = INR (g b)
   |- ∀x. ¬ISR x ⇔ ISL x
   |- ∀x. ¬ISL x ⇔ ISR x
   |- (∀x y z. ((if P then INR x else INL y) = INR z) ⇔ P ∧ (z = x)) ∧
      (∀x y z. ((if P then INR x else INL y) = INL z) ⇔ ¬P ∧ (z = y)) ∧
      (∀x y z. ((if P then INL x else INR y) = INL z) ⇔ P ∧ (z = x)) ∧
      ∀x y z. ((if P then INL x else INR y) = INR z) ⇔ ¬P ∧ (z = y)
   |- (∀x f f1. sum_CASE (INL x) f f1 = f x) ∧
      ∀y f f1. sum_CASE (INR y) f f1 = f1 y
   |- ∀x. OUTL (INL x) = x
   |- ∀x. ISR x ⇒ (INR (OUTR x) = x)
   |- ∀x. ISL x ⇒ (INL (OUTL x) = x)
   |- ∀x. OUTR (INR x) = x
   |- (∀x. ISL (INL x)) ∧ ∀y. ¬ISL (INR y)
   |- (∀x. ISR (INR x)) ∧ ∀y. ¬ISR (INL y)
   |- ∀x y. INL x ≠ INR y

Simplification set: COMBIN
Rewrite rules:
   |- ∀x. I x = x
   |- ∀f. (I ∘ f = f) ∧ (f ∘ I = f)
   |- ∀x y. K x y = x
   |- ∀f g x. S f g x = f x (g x)
   |- ∀f g h. (f ∘ g) ∘ h = f ∘ g ∘ h
   |- ∀f g x. (f ∘ g) x = f (g x)
   |- ∀f x. W f x = f x x
   |- ∀f x y. combin$C f x y = f y x
   |- (∀f v. K v ∘ f = K v) ∧ ∀f v. f ∘ K v = K (f v)

Simplification set: ARITH_RWTS
Rewrite rules:
   |- ∀x. ((SUC x = 1) ⇔ (x = 0)) ∧ ((1 = SUC x) ⇔ (x = 0))
   |- ∀x. ((SUC x = 2) ⇔ (x = 1)) ∧ ((2 = SUC x) ⇔ (x = 1))
   |- ∀m. m + 0 = m
   |- ∀m. 0 + m = m
   |- ∀m n. (m + n = 0) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (0 = m + n) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (m + n = m) ⇔ (n = 0)
   |- ∀m n. (n + m = m) ⇔ (n = 0)
   |- ∀m n. (m * n = 0) ⇔ (m = 0) ∨ (n = 0)
   |- ∀m n. (0 = m * n) ⇔ (m = 0) ∨ (n = 0)
   |- ∀x y. (x * y = 1) ⇔ (x = 1) ∧ (y = 1)
   |- ∀x y. (1 = x * y) ⇔ (x = 1) ∧ (y = 1)
   |- ∀m. m * 0 = 0
   |- ∀m. 0 * m = 0
   |- ∀x y. (x * y = SUC 0) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀x y. (SUC 0 = x * y) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀m. m * 1 = m
   |- ∀m. 1 * m = m
   |- ∀c. c − c = 0
   |- ∀m. SUC m − 1 = m
   |- ∀m. (0 − m = 0) ∧ (m − 0 = m)
   |- ∀a c. a + c − c = a
   |- ∀a c. c + a − c = a
   |- ∀m n. (m − n = 0) ⇔ m ≤ n
   |- ∀m n. (0 = m − n) ⇔ m ≤ n
   |- ∀n m. n − m ≤ n
   |- ∀n m. SUC n − SUC m = n − m
   |- ∀m n p. m − n > p ⇔ m > n + p
   |- ∀m n p. m − n < p ⇔ m < n + p ∧ 0 < p
   |- ∀m n p. m − n ≥ p ⇔ m ≥ n + p ∨ 0 ≥ p
   |- ∀m n p. m − n ≤ p ⇔ m ≤ n + p
   |- (PRE 0 = 0) ∧ ∀m. PRE (SUC m) = m
   |- ∀n m. (n ** m = 0) ⇔ (n = 0) ∧ 0 < m
   |- ∀n. (1 ** n = 1) ∧ (n ** 1 = n)
   |- ∀n m. (n ** m = 1) ⇔ (n = 1) ∨ (m = 0)
   |- 0 < x ** y ⇔ 0 < x ∨ (y = 0)
   |- ∀b1 b2 x. (b1 ** x = b2 ** x) ⇔ (x = 0) ∨ (b1 = b2)
   |- ∀b. 1 < b ⇒ ∀n m. (b ** n = b ** m) ⇔ (n = m)
   |- ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n
   |- ∀b. 1 < b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n
   |- ∀a b. a ** n < b ** n ⇔ a < b ∧ 0 < n
   |- ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ (n = 0)
   |- ∀n. n ≤ 0 ⇔ (n = 0)
   |- ∀n. 0 < SUC n
   |- ∀m n. m ≤ m + n
   |- 0 ≤ x
   |- SUC x > 0
   |- x ≥ 0
   |- x < SUC x
   |- x ≤ SUC x
   |- x < x + c ⇔ 0 < c
   |- x < c + x ⇔ 0 < c
   |- x ≤ x + c ⇔ 0 ≤ c
   |- x ≤ c + x ⇔ 0 ≤ c
   |- ∀m. m ≤ m
   |- x ≥ x
   |- ∀m n p. m + p < n + p ⇔ m < n
   |- ∀m n p. p + m < p + n ⇔ m < n
   |- ∀m n p. m + n ≤ m + p ⇔ n ≤ p
   |- ∀m n p. n + m ≤ p + m ⇔ n ≤ p
   |- ∀m n p. (m + p = n + p) ⇔ (m = n)
   |- ∀m n p. (p + m = p + n) ⇔ (m = n)
   |- x + y < w + x ⇔ y < w
   |- y + x < x + w ⇔ y < w
   |- ∀m n. (SUC m = SUC n) ⇔ (m = n)
   |- ∀m n. SUC m < SUC n ⇔ m < n
   |- ∀n m. SUC n ≤ SUC m ⇔ n ≤ m
   |- ∀m i n. SUC n * m < SUC n * i ⇔ m < i
   |- ∀p m n. (n * SUC p = m * SUC p) ⇔ (n = m)
   |- ∀m i n. (SUC n * m = SUC n * i) ⇔ (m = i)
   |- ∀n m. ¬(SUC n ≤ m) ⇔ m ≤ n
   |- ∀p q n m. (n * SUC q ** p = m * SUC q ** p) ⇔ (n = m)
   |- ∀m n p. m * n ≤ m * p ⇔ (m = 0) ∨ n ≤ p
   |- ∀m n p. m * n ≤ p * n ⇔ (n = 0) ∨ m ≤ p
   |- ∀m n p. m * n < m * p ⇔ 0 < m ∧ n < p
   |- ∀m n p. m * n < p * n ⇔ 0 < n ∧ m < p
   |- (m < m * n ⇔ 0 < m ∧ 1 < n) ∧ (m < n * m ⇔ 0 < m ∧ 1 < n)
   |- (m * n < m ⇔ 0 < m ∧ (n = 0)) ∧ (m * n < n ⇔ 0 < n ∧ (m = 0))
   |- (m ≤ m * n ⇔ (m = 0) ∨ 0 < n) ∧ (m ≤ n * m ⇔ (m = 0) ∨ 0 < n)
   |- (m * n ≤ m ⇔ (m = 0) ∨ n ≤ 1) ∧ (m * n ≤ n ⇔ (n = 0) ∨ m ≤ 1)
   |- ∀m n. SUC n ** m ≠ 0
   |- ∀n m. SUC (n + n) ≠ m + m
   |- ∀m n. ¬(SUC (m + n) ≤ m)
   |- ∀n. ¬(SUC n ≤ 0)
   |- ∀n. ¬(n < 0)
   |- ∀n. ¬(n < n)
   |- ¬(x > x)
   |- ∀n. (MIN n 0 = 0) ∧ (MIN 0 n = 0)
   |- ∀n. (MAX n 0 = n) ∧ (MAX 0 n = n)
   |- ∀n. MIN n n = n
   |- ∀n. MAX n n = n
   |- ∀n m p.
        (MIN m n ≤ p ⇔ m ≤ p ∨ n ≤ p) ∧ (p ≤ MIN m n ⇔ p ≤ m ∧ p ≤ n)
   |- ∀n m p.
        (p ≤ MAX m n ⇔ p ≤ m ∨ p ≤ n) ∧ (MAX m n ≤ p ⇔ m ≤ p ∧ n ≤ p)
   |- ∀n m p.
        (MIN m n < p ⇔ m < p ∨ n < p) ∧ (p < MIN m n ⇔ p < m ∧ p < n)
   |- ∀n m p.
        (p < MAX m n ⇔ p < m ∨ p < n) ∧ (MAX m n < p ⇔ m < p ∧ n < p)
   |- ∀m n. (MIN m n = MAX m n) ⇔ (m = n)
   |- ∀m n. MIN m n < MAX m n ⇔ m ≠ n
   |- ∀x y. 0 < y ⇒ ((x MOD y = x) ⇔ x < y)
   |- ∀n. 0 < n ⇒ (n DIV n = 1) ∧ (n MOD n = 0)
   |- ∀q. q DIV 1 = q
   |- ∀k. k MOD 1 = 0
   |- ∀n k. k < n ⇒ (k MOD n = k)
   |- ∀n. 0 < n ⇒ (0 MOD n = 0)
   |- ∀n. 0 < n ⇒ ∀k. k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT1 x) = 0)) ∧
      ((NUMERAL (BIT2 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT2 x) = 0))
   |- ∀m n. 0 < n ⇒ m MOD n < n
   |- ∀n d. 0 < n ∧ 1 < d ⇒ n DIV d < n

Simplification set: ARITH_DP
Conversions:
   MUL_CANON_CONV, keyed on pattern  “x * y”
Decision procedures:
   ARITH_REDUCER

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER

Simplification set: list
Rewrite rules:
   |- ∀h t. HD (h::t) = h
   |- (∀v f. list_CASE [] v f = v) ∧
      ∀a0 a1 v f. list_CASE (a0::a1) v f = f a0 a1
   |- ∀xs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys
   |- ∀x n ys. LENGTH (LUPDATE x n ys) = LENGTH ys
   |- (∀f e. FOLDR f e [] = e) ∧
      ∀f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)
   |- (∀f e. FOLDL f e [] = e) ∧
      ∀f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l
   |- ∀P l. ¬EXISTS P l ⇔ EVERY ($~ ∘ P) l
   |- ∀P l. ¬EVERY P l ⇔ EXISTS ($~ ∘ P) l
   |- ∀c l. EXISTS (λx. c) l ⇔ l ≠ [] ∧ c
   |- ∀c l. EVERY (λx. c) l ⇔ (l = []) ∨ c
   |- ∀P l1 l2. EXISTS P (l1 ++ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2
   |- ∀P l1 l2. EVERY P (l1 ++ l2) ⇔ EVERY P l1 ∧ EVERY P l2
   |- ∀pl.
        (LENGTH (FST (UNZIP pl)) = LENGTH pl) ∧
        (LENGTH (SND (UNZIP pl)) = LENGTH pl)
   |- ∀l1 l2.
        (LENGTH l1 = LENGTH l2) ⇒
        (LENGTH (ZIP (l1,l2)) = LENGTH l1) ∧
        (LENGTH (ZIP (l1,l2)) = LENGTH l2)
   |- ∀l1 l2. (LENGTH l1 = LENGTH l2) ⇒ (UNZIP (ZIP (l1,l2)) = (l1,l2))
   |- ∀l. ZIP (UNZIP l) = l
   |- (UNZIP [] = ([],[])) ∧
      ∀x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
   |- (ZIP ([],[]) = []) ∧
      ∀x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
   |- ∀l. set (nub l) = set l
   |- ∀l x. l ≠ x::l ∧ x::l ≠ l
   |- ∀a1 a0. [] ≠ a0::a1
   |- ∀a1 a0. a0::a1 ≠ []
   |- ∀f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2
   |- ∀l f. LENGTH (MAP f l) = LENGTH l
   |- ∀a0 a1 a0' a1'. (a0::a1 = a0'::a1') ⇔ (a0 = a0') ∧ (a1 = a1')
   |- ∀l. ¬NULL l ⇒ (HD l::TL l = l)
   |- ∀l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3
   |- (SUM [] = 0) ∧ ∀h t. SUM (h::t) = h + SUM t
   |- (NULL [] ⇔ T) ∧ ∀h t. NULL (h::t) ⇔ F
   |- (∀f. MAP2 f [] [] = []) ∧
      ∀f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2
   |- (∀l1 l2 l3. (l1 ++ l2 = l1 ++ l3) ⇔ (l2 = l3)) ∧
      ∀l1 l2 l3. (l2 ++ l1 = l3 ++ l1) ⇔ (l2 = l3)
   |- (∀P. dropWhile P [] = []) ∧
      ∀P h t. dropWhile P (h::t) = if P h then dropWhile P t else h::t
   |- (∀P ys. LIST_REL P [] ys ⇔ (ys = [])) ∧
      (∀P yys x xs.
         LIST_REL P (x::xs) yys ⇔
         ∃y ys. (yys = y::ys) ∧ P x y ∧ LIST_REL P xs ys) ∧
      (∀P xs. LIST_REL P xs [] ⇔ (xs = [])) ∧
      ∀P xxs y ys.
        LIST_REL P xxs (y::ys) ⇔
        ∃x xs. (xxs = x::xs) ∧ P x y ∧ LIST_REL P xs ys
   |- (∀l. [] ≼ l ⇔ T) ∧
      ∀h t l. h::t ≼ l ⇔ case l of [] => F | h'::t' => (h = h') ∧ t ≼ t'
   |- ¬LLEX R l []
   |- (¬LLEX R [] [] ∧ ¬LLEX R (h1::t1) []) ∧ LLEX R [] (h2::t2) ∧
      (LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ (h1 = h2) ∧ LLEX R t1 t2)
   |- [f] <*> [x] = [f x]
   |- LIST_BIND [x] f = f x
   |- (LIST_BIND [] f = []) ∧
      (LIST_BIND (h::t) f = f h ++ LIST_BIND t f)
   |- ∀xs n x. (LUPDATE x n xs = []) ⇔ (xs = [])
   |- INFINITE 𝕌(:α list)
   |- ∀ls f. MAP f (ZIP (ls,ls)) = MAP (λx. f (x,x)) ls
   |- ∀ls f e. FOLDL f e (ZIP (ls,ls)) = FOLDL (λx y. f x (y,y)) e ls
   |- (GENLIST f 0 = []) ∧
      (GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) [])
   |- ∀f n x. x < n ⇒ (EL x (GENLIST f n) = f x)
   |- (∀f l. GENLIST_AUX f 0 l = l) ∧
      (∀f n l.
         GENLIST_AUX f (NUMERAL (BIT1 n)) l =
         GENLIST_AUX f (NUMERAL (BIT1 n) − 1)
           (f (NUMERAL (BIT1 n) − 1)::l)) ∧
      ∀f n l.
        GENLIST_AUX f (NUMERAL (BIT2 n)) l =
        GENLIST_AUX f (NUMERAL (BIT1 n)) (f (NUMERAL (BIT1 n))::l)
   |- ∀f n. LENGTH (GENLIST f n) = n
   |- ∀x y a b. (SNOC x y = SNOC a b) ⇔ (x = a) ∧ (y = b)
   |- ∀y x l. MEM y (SNOC x l) ⇔ (y = x) ∨ MEM y l
   |- ∀x l. FRONT (SNOC x l) = l
   |- ∀x l. LAST (SNOC x l) = x
   |- ∀x l. LENGTH (SNOC x l) = SUC (LENGTH l)
   |- (∀x. SNOC x [] = [x]) ∧ ∀x x' l. SNOC x (x'::l) = x'::SNOC x l
   |- ([] ≼ l ⇔ T) ∧ (h::t ≼ [] ⇔ F) ∧
      (h1::t1 ≼ h2::t2 ⇔ (h1 = h2) ∧ t1 ≼ t2)
   |- SET_TO_LIST ∅ = []
   |- ∀s. FINITE s ⇒ ALL_DISTINCT (SET_TO_LIST s)
   |- SET_TO_LIST {x} = [x]
   |- ∀s. FINITE s ⇒ ∀x. MEM x (SET_TO_LIST s) ⇔ x ∈ s
   |- TAKE 0 l = []
   |- ∀ls. set (REVERSE ls) = set ls
   |- ∀l. FINITE (set l)
   |- ((set l = ∅) ⇔ (l = [])) ∧ ((∅ = set l) ⇔ (l = []))
   |- ∀l1 l2. set (l1 ++ l2) = set l1 ∪ set l2
   |- ∀xs. ALL_DISTINCT (FLAT (REVERSE xs)) ⇔ ALL_DISTINCT (FLAT xs)
   |- ∀l. ALL_DISTINCT (REVERSE l) ⇔ ALL_DISTINCT l
   |- (ALL_DISTINCT [] ⇔ T) ∧
      ∀h t. ALL_DISTINCT (h::t) ⇔ ¬MEM h t ∧ ALL_DISTINCT t
   |- (∀f cs c bs b a.
         FOLDL2 f a (b::bs) (c::cs) = FOLDL2 f (f a b c) bs cs) ∧
      (∀f cs a. FOLDL2 f a [] cs = a) ∧
      ∀v7 v6 f a. FOLDL2 f a (v6::v7) [] = a
   |- ∀n l. LENGTH (DROP n l) = LENGTH l − n
   |- ∀n l. TAKE n l ++ DROP n l = l
   |- DROP 0 l = l
   |- ∀n l. n ≤ LENGTH l ⇒ (LENGTH (TAKE n l) = n)
   |- ∀l. TAKE (LENGTH l) l = l
   |- 0 < n ⇒ (TAKE n (x::xs) = x::TAKE (n − 1) xs)
   |- 0 < n ⇒ (DROP n (x::xs) = DROP (n − 1) xs)
   |- ∀n. DROP n [] = []
   |- ∀n. TAKE n [] = []
   |- (REVERSE l = []) ⇔ (l = [])
   |- ∀h l1 l2. LAST (l1 ++ h::l2) = LAST (h::l2)
   |- (∀x xs. (FRONT (x::xs) = []) ⇔ (xs = [])) ∧
      (∀x xs. ([] = FRONT (x::xs)) ⇔ (xs = [])) ∧
      ∀x xs. NULL (FRONT (x::xs)) ⇔ NULL xs
   |- ∀x xs. LENGTH (FRONT (x::xs)) = LENGTH xs
   |- (∀x. FRONT [x] = []) ∧ ∀x y z. FRONT (x::y::z) = x::FRONT (y::z)
   |- ∀l f. l ≠ [] ⇒ (LAST (MAP f l) = f (LAST l))
   |- (∀x. LAST [x] = x) ∧ ∀x y z. LAST (x::y::z) = LAST (y::z)
   |- (REVERSE l = [e]) ⇔ (l = [e])
   |- ∀l x. MEM x (REVERSE l) ⇔ MEM x l
   |- ∀l. LENGTH (REVERSE l) = LENGTH l
   |- ∀l1 l2. (REVERSE l1 = REVERSE l2) ⇔ (l1 = l2)
   |- (REVERSE [] = []) ∧ ∀h t. REVERSE (h::t) = REVERSE t ++ [h]
   |- ∀l. REVERSE (REVERSE l) = l
   |- (∀x. MEM x [] ⇔ F) ∧ ∀x h t. MEM x (h::t) ⇔ (x = h) ∨ MEM x t
   |- (LIST_REL R [] x ⇔ (x = [])) ∧ (LIST_REL R [] y ⇔ (y = []))
   |- (LIST_REL R [] [] ⇔ T) ∧ (LIST_REL R (a::as) [] ⇔ F) ∧
      (LIST_REL R [] (b::bs) ⇔ F) ∧
      (LIST_REL R (a::as) (b::bs) ⇔ R a b ∧ LIST_REL R as bs)
   |- (EL (NUMERAL (BIT1 n)) (l::ls) = EL (PRE (NUMERAL (BIT1 n))) ls) ∧
      (EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls)
   |- (EL 0 = HD) ∧ (EL (SUC n) (l::ls) = EL n ls)
   |- ∀e l1 l2. MEM e (l1 ++ l2) ⇔ MEM e l1 ∨ MEM e l2
   |- (∀l1 l2. ([] = l1 ++ l2) ⇔ (l1 = []) ∧ (l2 = [])) ∧
      ∀l1 l2. (l1 ++ l2 = []) ⇔ (l1 = []) ∧ (l2 = [])
   |- (0 = LENGTH l) ⇔ (l = [])
   |- ∀l. (LENGTH l = 0) ⇔ (l = [])
   |- ∀l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2
   |- ∀l f. ((MAP f l = []) ⇔ (l = [])) ∧ (([] = MAP f l) ⇔ (l = []))
   |- (MAP f l = [x]) ⇔ ∃x0. (l = [x0]) ∧ (x = f x0)
   |- (MAP (λx. x) l = l) ∧ (MAP I l = l)
   |- (LENGTH [] = 0) ∧ ∀h t. LENGTH (h::t) = SUC (LENGTH t)
   |- ∀l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2
   |- ∀l. l ++ [] = l
   |- (∀P. EXISTS P [] ⇔ F) ∧ ∀P h t. EXISTS P (h::t) ⇔ P h ∨ EXISTS P t
   |- (∀P. EVERY P [] ⇔ T) ∧ ∀P h t. EVERY P (h::t) ⇔ P h ∧ EVERY P t
   |- (∀P. FILTER P [] = []) ∧
      ∀P h t.
        FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t
   |- (set [] = ∅) ∧ (set (h::t) = h INSERT set t)
   |- (∀x. set [] x ⇔ F) ∧ ∀h t x. set (h::t) x ⇔ (x = h) ∨ set t x
   |- (∀f. MAP f [] = []) ∧ ∀f h t. MAP f (h::t) = f h::MAP f t
   |- ∀h t. TL (h::t) = t
   |- (FLAT [] = []) ∧ ∀h t. FLAT (h::t) = h ++ FLAT t
   |- (∀l. [] ++ l = l) ∧ ∀l1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2)

Simplification set: <anonymous>
Rewrite rules:
   |- ∀x y s. x ∈ y INSERT s ⇔ (x = y) ∨ x ∈ s
   |- ∀x. x ∉ ∅
   |- ∀s t x. x ∈ s ∪ t ⇔ x ∈ s ∨ x ∈ t
:
   simpset
type list_tactic = goal list -> goal list * list_validation
type list_validation = thm list -> thm list
val literal_case =
   “literal_case”:
   term
val literal_case_CONG =
   |- ∀f g M N.
     (M = N) ∧ (∀x. (x = N) ⇒ (f x = g x)) ⇒
     (literal_case f M = literal_case g N):
   thm
val literal_case_DEF =
   |- literal_case = (λf x. f x):
   thm
val literal_case_RAND =
   |- P (case M of x => N x) = case M of x => P (N x):
   thm
val literal_case_RATOR =
   |- (case M of x => N x) b = case M of x => N x b:
   thm
val literal_case_THM =
   |- ∀f x. literal_case f x = f x:
   thm
val literal_case_id =
   |- (case a of a => t | x => u) = t:
   thm
val load_complete = fn: string -> unit
val loose_equality = fn: unit -> unit
val lrfs = fn: thm list -> tactic
val lrw = fn: thm list -> tactic
val lspine_binop = fn: ('a -> ('a * 'a) option) -> 'a -> 'a list
val map2 = fn: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
val map_every = fn: ('a -> tactic) -> 'a list -> tactic
val mapfilter = fn: ('a -> 'b) -> 'a list -> 'b list
val mapi = fn: (int -> 'a -> 'b) -> 'a list -> 'b list
val mapshape = fn: int list -> ('a list -> 'b) list -> 'a list -> 'b list
val match = fn: string list -> term -> DB.data list
val match_mp_tac = fn: thm -> tactic
val match_term = fn:
   term -> term -> (term, term) Term.subst * (hol_type, hol_type) Term.subst
val match_terml = fn:
   hol_type list ->
     term set ->
       term ->
         term -> (term, term) Term.subst * (hol_type, hol_type) Term.subst
val match_type = fn: hol_type -> hol_type -> (hol_type, hol_type) Lib.subst
val match_type_in_context = fn:
   hol_type ->
     hol_type ->
       (hol_type, hol_type) Lib.subst -> (hol_type, hol_type) Lib.subst
val match_type_restr = fn:
   hol_type list -> hol_type -> hol_type -> (hol_type, hol_type) Lib.subst
val matcher = fn: (term -> term -> 'a) -> string list -> term -> DB.data list
val matches = fn: term -> thm -> bool
val matchp = fn: (thm -> bool) -> string list -> DB.data list
val max_print_depth = ref ~1: int ref
val measureInduct_on = fn: term quotation -> tactic
val measure_cmp = fn: ('a -> int) -> 'a cmp
val mem = fn: ''a -> ''a list -> bool
val memoize = fn:
   (term -> 'a option) ->
     ('a, thm) Redblackmap.dict -> (term -> bool) -> exn -> conv -> conv
val merge_grammars = fn:
   string list -> type_grammar.grammar * term_grammar.grammar
val metis_tac = fn: thm list -> tactic
val min_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
         TY  ::=  bool | (TY, TY)fun | ind
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          ,
    (0)    TM  ::=  "@" <..binders..> "." TM | "λ" <..binders..> "." TM |
                "\" <..binders..> "." TM
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(100)  TM  ::=  TM "=" TM   (non-associative)
(200)  TM  ::=  TM "==>" TM   (R-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
  = ==> @):
   type_grammar.grammar * term_grammar.grammar
val minprint = fn: term -> string
val mk_HOL_ERR = fn: string -> string -> string -> exn
val mk_HOL_ERRloc = fn: string -> string -> locn.locn -> string -> exn
val mk_IN = fn: term * term -> term
val mk_abs = fn: term * term -> term
val mk_arb = fn: hol_type -> term
val mk_axiom_thm = fn: string Nonce.t * term -> thm
val mk_binder = fn: term -> string -> term * term -> term
val mk_binop = fn: term -> term * term -> term
val mk_bool_case = fn: term * term * term -> term
val mk_comb = fn: term * term -> term
val mk_cond = fn: term * term * term -> term
val mk_conj = fn: term * term -> term
val mk_const = fn: string * hol_type -> term
val mk_disj = fn: term * term -> term
val mk_eq = fn: term * term -> term
val mk_exists = fn: term * term -> term
val mk_exists1 = fn: term * term -> term
val mk_forall = fn: term * term -> term
val mk_icomb = fn: term * term -> term
val mk_imp = fn: term * term -> term
val mk_istream = fn: ('a -> 'a) -> 'a -> ('a -> 'b) -> ('a, 'b) istream
val mk_itself = fn: hol_type -> term
val mk_let = fn: term * term -> term
val mk_literal_case = fn: term * term -> term
val mk_monop = fn: term -> term -> term
val mk_neg = fn: term -> term
val mk_oracle_thm = fn: string -> term list * term -> thm
val mk_primed_var = fn: string * hol_type -> term
val mk_quadop = fn: term -> term * term * term * term -> term
val mk_res_abstract = fn: term * term * term -> term
val mk_res_exists = fn: term * term * term -> term
val mk_res_exists_unique = fn: term * term * term -> term
val mk_res_forall = fn: term * term * term -> term
val mk_res_select = fn: term * term * term -> term
val mk_rewrites = fn: thm -> thm list
val mk_select = fn: term * term -> term
val mk_set = fn: ''a list -> ''a list
val mk_thm = fn: term list * term -> thm
val mk_thy_const = fn: {Name: string, Thy: string, Ty: hol_type} -> term
val mk_thy_type = fn:
   {Args: hol_type list, Thy: string, Tyop: string} -> hol_type
val mk_triop = fn: term -> term * term * term -> term
val mk_type = fn: string * hol_type list -> hol_type
val mk_var = fn: string * hol_type -> term
val mk_vartype = fn: string -> hol_type
val mlquote = fn: string -> string
val monitoring = ref false: bool ref
val mp_tac = fn: thm_tactic
val negation = “$~”: term
val net_of = fn: rewrites -> conv Net.net
val new_axiom = fn: string * term -> thm
val new_binder = fn: string * hol_type -> unit
val new_binder_definition = fn: string * term -> thm
val new_constant = fn: string * hol_type -> unit
val new_definition = fn: string * term -> thm
val new_definition_hook = ref (fn, fn):
   ((term -> term list * term) * (term list * thm -> thm)) ref
val new_exporter = fn:
   string ->
     (string -> (string * thm) list -> unit) ->
       {dest: data -> (string * thm) list option,
         export: string -> unit,
         mk: string list -> data * (string * thm) list}
val new_infix = fn: string * hol_type * int -> unit
val new_infix_type = fn:
   {Arity: int,
     Assoc: associativity, Name: string, ParseName: string option, Prec: int}
     -> unit
val new_infixl_definition = fn: string * term * int -> thm
val new_infixr_definition = fn: string * term * int -> thm
val new_recursive_definition = fn:
   {def: term, name: string, rec_axiom: thm} -> thm
val new_specification = fn: string * string list * thm -> thm
val new_storage_attribute = fn: string -> unit
val new_theory = fn: string -> unit
val new_type = fn: string * int -> unit
val new_type_definition = fn: string * thm -> thm
val next = fn: ('a, 'b) istream -> ('a, 'b) istream
val norm_subst = fn:
   ((term, term) Term.subst * term set) *
   ((hol_type, hol_type) Term.subst * hol_type list) ->
     (term, term) Term.subst * (hol_type, hol_type) Term.subst
val notify_on_tyvar_guess = ref true: bool ref
val ntac = fn: int -> tactic -> tactic
val null_intersection = fn: ''a list -> ''a list -> bool
eqtype num
val old = fn: string -> string
val old_ARITH_ss =
   Simplification set: ARITH_RWTS, OLD_ARITH_DP
Decision procedures:
   ARITH_REDUCER
Rewrite rules:
   |- ∀x. ((SUC x = 1) ⇔ (x = 0)) ∧ ((1 = SUC x) ⇔ (x = 0))
   |- ∀x. ((SUC x = 2) ⇔ (x = 1)) ∧ ((2 = SUC x) ⇔ (x = 1))
   |- ∀m. m + 0 = m
   |- ∀m. 0 + m = m
   |- ∀m n. (m + n = 0) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (0 = m + n) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (m + n = m) ⇔ (n = 0)
   |- ∀m n. (n + m = m) ⇔ (n = 0)
   |- ∀m n. (m * n = 0) ⇔ (m = 0) ∨ (n = 0)
   |- ∀m n. (0 = m * n) ⇔ (m = 0) ∨ (n = 0)
   |- ∀x y. (x * y = 1) ⇔ (x = 1) ∧ (y = 1)
   |- ∀x y. (1 = x * y) ⇔ (x = 1) ∧ (y = 1)
   |- ∀m. m * 0 = 0
   |- ∀m. 0 * m = 0
   |- ∀x y. (x * y = SUC 0) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀x y. (SUC 0 = x * y) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀m. m * 1 = m
   |- ∀m. 1 * m = m
   |- ∀c. c − c = 0
   |- ∀m. SUC m − 1 = m
   |- ∀m. (0 − m = 0) ∧ (m − 0 = m)
   |- ∀a c. a + c − c = a
   |- ∀a c. c + a − c = a
   |- ∀m n. (m − n = 0) ⇔ m ≤ n
   |- ∀m n. (0 = m − n) ⇔ m ≤ n
   |- ∀n m. n − m ≤ n
   |- ∀n m. SUC n − SUC m = n − m
   |- ∀m n p. m − n > p ⇔ m > n + p
   |- ∀m n p. m − n < p ⇔ m < n + p ∧ 0 < p
   |- ∀m n p. m − n ≥ p ⇔ m ≥ n + p ∨ 0 ≥ p
   |- ∀m n p. m − n ≤ p ⇔ m ≤ n + p
   |- (PRE 0 = 0) ∧ ∀m. PRE (SUC m) = m
   |- ∀n m. (n ** m = 0) ⇔ (n = 0) ∧ 0 < m
   |- ∀n. (1 ** n = 1) ∧ (n ** 1 = n)
   |- ∀n m. (n ** m = 1) ⇔ (n = 1) ∨ (m = 0)
   |- 0 < x ** y ⇔ 0 < x ∨ (y = 0)
   |- ∀b1 b2 x. (b1 ** x = b2 ** x) ⇔ (x = 0) ∨ (b1 = b2)
   |- ∀b. 1 < b ⇒ ∀n m. (b ** n = b ** m) ⇔ (n = m)
   |- ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n
   |- ∀b. 1 < b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n
   |- ∀a b. a ** n < b ** n ⇔ a < b ∧ 0 < n
   |- ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ (n = 0)
   |- ∀n. n ≤ 0 ⇔ (n = 0)
   |- ∀n. 0 < SUC n
   |- ∀m n. m ≤ m + n
   |- 0 ≤ x
   |- SUC x > 0
   |- x ≥ 0
   |- x < SUC x
   |- x ≤ SUC x
   |- x < x + c ⇔ 0 < c
   |- x < c + x ⇔ 0 < c
   |- x ≤ x + c ⇔ 0 ≤ c
   |- x ≤ c + x ⇔ 0 ≤ c
   |- ∀m. m ≤ m
   |- x ≥ x
   |- ∀m n p. m + p < n + p ⇔ m < n
   |- ∀m n p. p + m < p + n ⇔ m < n
   |- ∀m n p. m + n ≤ m + p ⇔ n ≤ p
   |- ∀m n p. n + m ≤ p + m ⇔ n ≤ p
   |- ∀m n p. (m + p = n + p) ⇔ (m = n)
   |- ∀m n p. (p + m = p + n) ⇔ (m = n)
   |- x + y < w + x ⇔ y < w
   |- y + x < x + w ⇔ y < w
   |- ∀m n. (SUC m = SUC n) ⇔ (m = n)
   |- ∀m n. SUC m < SUC n ⇔ m < n
   |- ∀n m. SUC n ≤ SUC m ⇔ n ≤ m
   |- ∀m i n. SUC n * m < SUC n * i ⇔ m < i
   |- ∀p m n. (n * SUC p = m * SUC p) ⇔ (n = m)
   |- ∀m i n. (SUC n * m = SUC n * i) ⇔ (m = i)
   |- ∀n m. ¬(SUC n ≤ m) ⇔ m ≤ n
   |- ∀p q n m. (n * SUC q ** p = m * SUC q ** p) ⇔ (n = m)
   |- ∀m n p. m * n ≤ m * p ⇔ (m = 0) ∨ n ≤ p
   |- ∀m n p. m * n ≤ p * n ⇔ (n = 0) ∨ m ≤ p
   |- ∀m n p. m * n < m * p ⇔ 0 < m ∧ n < p
   |- ∀m n p. m * n < p * n ⇔ 0 < n ∧ m < p
   |- (m < m * n ⇔ 0 < m ∧ 1 < n) ∧ (m < n * m ⇔ 0 < m ∧ 1 < n)
   |- (m * n < m ⇔ 0 < m ∧ (n = 0)) ∧ (m * n < n ⇔ 0 < n ∧ (m = 0))
   |- (m ≤ m * n ⇔ (m = 0) ∨ 0 < n) ∧ (m ≤ n * m ⇔ (m = 0) ∨ 0 < n)
   |- (m * n ≤ m ⇔ (m = 0) ∨ n ≤ 1) ∧ (m * n ≤ n ⇔ (n = 0) ∨ m ≤ 1)
   |- ∀m n. SUC n ** m ≠ 0
   |- ∀n m. SUC (n + n) ≠ m + m
   |- ∀m n. ¬(SUC (m + n) ≤ m)
   |- ∀n. ¬(SUC n ≤ 0)
   |- ∀n. ¬(n < 0)
   |- ∀n. ¬(n < n)
   |- ¬(x > x)
   |- ∀n. (MIN n 0 = 0) ∧ (MIN 0 n = 0)
   |- ∀n. (MAX n 0 = n) ∧ (MAX 0 n = n)
   |- ∀n. MIN n n = n
   |- ∀n. MAX n n = n
   |- ∀n m p.
        (MIN m n ≤ p ⇔ m ≤ p ∨ n ≤ p) ∧ (p ≤ MIN m n ⇔ p ≤ m ∧ p ≤ n)
   |- ∀n m p.
        (p ≤ MAX m n ⇔ p ≤ m ∨ p ≤ n) ∧ (MAX m n ≤ p ⇔ m ≤ p ∧ n ≤ p)
   |- ∀n m p.
        (MIN m n < p ⇔ m < p ∨ n < p) ∧ (p < MIN m n ⇔ p < m ∧ p < n)
   |- ∀n m p.
        (p < MAX m n ⇔ p < m ∨ p < n) ∧ (MAX m n < p ⇔ m < p ∧ n < p)
   |- ∀m n. (MIN m n = MAX m n) ⇔ (m = n)
   |- ∀m n. MIN m n < MAX m n ⇔ m ≠ n
   |- ∀x y. 0 < y ⇒ ((x MOD y = x) ⇔ x < y)
   |- ∀n. 0 < n ⇒ (n DIV n = 1) ∧ (n MOD n = 0)
   |- ∀q. q DIV 1 = q
   |- ∀k. k MOD 1 = 0
   |- ∀n k. k < n ⇒ (k MOD n = k)
   |- ∀n. 0 < n ⇒ (0 MOD n = 0)
   |- ∀n. 0 < n ⇒ ∀k. k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT1 x) = 0)) ∧
      ((NUMERAL (BIT2 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT2 x) = 0))
   |- ∀m n. 0 < n ⇒ m MOD n < n
   |- ∀n d. 0 < n ∧ 1 < d ⇒ n DIV d < n
:
   ssfrag
val old_arith_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern  “(λx. y) z”
Congruence rules:
   |- (v = v') ⇒ (literal_case f v = literal_case f (I v'))
Rewrite rules:
   |- ∀x. (x = x) ⇔ T
   |- ∀t.
        ((T ⇔ t) ⇔ t) ∧ ((t ⇔ T) ⇔ t) ∧ ((F ⇔ t) ⇔ ¬t) ∧ ((t ⇔ F) ⇔ ¬t)
   |- (∀t. ¬ ¬t ⇔ t) ∧ (¬T ⇔ F) ∧ (¬F ⇔ T)
   |- ∀t.
        (T ∧ t ⇔ t) ∧ (t ∧ T ⇔ t) ∧ (F ∧ t ⇔ F) ∧ (t ∧ F ⇔ F) ∧
        (t ∧ t ⇔ t)
   |- ∀t.
        (T ∨ t ⇔ T) ∧ (t ∨ T ⇔ T) ∧ (F ∨ t ⇔ t) ∧ (t ∨ F ⇔ t) ∧
        (t ∨ t ⇔ t)
   |- ∀t.
        (T ⇒ t ⇔ t) ∧ (t ⇒ T ⇔ T) ∧ (F ⇒ t ⇔ T) ∧ (t ⇒ t ⇔ T) ∧
        (t ⇒ F ⇔ ¬t)
   |- ∀t1 t2.
        ((if T then t1 else t2) = t1) ∧ ((if F then t1 else t2) = t2)
   |- ∀t. (∀x. t) ⇔ t
   |- ∀t. (∃x. t) ⇔ t
   |- ∀b t. (if b then t else t) = t
   |- ∀a. ∃x. x = a
   |- ∀a. ∃x. a = x
   |- ∀a. ∃!x. x = a
   |- ∀a. ∃!x. a = x
   |- (∀b e. (if b then T else e) ⇔ b ∨ e) ∧
      (∀b t. (if b then t else T) ⇔ b ⇒ t) ∧
      (∀b e. (if b then F else e) ⇔ ¬b ∧ e) ∧
      ∀b t. (if b then t else F) ⇔ b ∧ t
   |- literal_case f (I x) = f x
   |- ∀t. t ∨ ¬t
   |- ∀t. ¬t ∨ t
   |- (∀t1 t2. (if T then t1 else t2) = t1) ∧
      ∀t1 t2. (if F then t1 else t2) = t2
   |- ¬(t ∧ ¬t)
   |- ∀x. (@y. y = x) = x
   |- ∀x. (@y. x = y) = x
   |- (∀x::P. T) ⇔ T
   |- (∃x::P. F) ⇔ F

Simplification set: NOT
Rewrite rules:
   |- ∀A B. ¬(A ⇒ B) ⇔ A ∧ ¬B
   |- ∀A B. (¬(A ∧ B) ⇔ ¬A ∨ ¬B) ∧ (¬(A ∨ B) ⇔ ¬A ∧ ¬B)
   |- ∀P. ¬(∀x. P x) ⇔ ∃x. ¬P x
   |- ∀P. ¬(∃x. P x) ⇔ ∀x. ¬P x
   |- (¬p ⇔ ¬q) ⇔ (p ⇔ q)

Simplification set: CONG
Congruence rules:
   |- ∀x x' y y'. (x ⇔ x') ⇒ (x' ⇒ (y ⇔ y')) ⇒ (x ⇒ y ⇔ x' ⇒ y')
   |- ∀P Q x x' y y'.
        (P ⇔ Q) ⇒
        (Q ⇒ (x = x')) ⇒
        (¬Q ⇒ (y = y')) ⇒
        ((if P then x else y) = if Q then x' else y')
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_FORALL P f ⇔ RES_FORALL Q g)
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_EXISTS P f ⇔ RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  “∃x. P”
   UNWIND_FORALL_CONV, keyed on pattern  “∀x. P”

Simplification set: PAIR
Rewrite rules:
   |- ∀x. (FST x,SND x) = x
   |- ∀x y. FST (x,y) = x
   |- ∀x y. SND (x,y) = y
   |- ∀x y a b. ((x,y) = (a,b)) ⇔ (x = a) ∧ (y = b)
   |- ∀f. CURRY (UNCURRY f) = f
   |- ∀f. UNCURRY (CURRY f) = f
   |- (CURRY f = CURRY g) ⇔ (f = g)
   |- (UNCURRY f = UNCURRY g) ⇔ (f = g)
   |- ∀f x y. CURRY f x y = f (x,y)
   |- ∀f g x y. (f ## g) (x,y) = (f x,g y)
   |- ∀f x y. UNCURRY f (x,y) = f x y

Simplification set: option
Rewrite rules:
   |- ∀x y. (SOME x = SOME y) ⇔ (x = y)
   |- ∀x. option_CASE x x SOME = x
   |- (OPTION_JOIN NONE = NONE) ∧ ∀x. OPTION_JOIN (SOME x) = x
   |- (∀v f. option_CASE NONE v f = v) ∧
      ∀x v f. option_CASE (SOME x) v f = f x
   |- ∀x. THE (SOME x) = x
   |- ∀x. option_CASE x NONE SOME = x
   |- ∀x. ¬IS_SOME x ⇔ (x = NONE)
   |- ∀x. IS_NONE x ⇔ (x = NONE)
   |- (∀x. IS_SOME (SOME x) ⇔ T) ∧ (IS_SOME NONE ⇔ F)
   |- ((some x. x = y) = SOME y) ∧ ((some x. y = x) = SOME y)
   |- (∀P. OPTION_ALL P NONE ⇔ T) ∧ ∀P x. OPTION_ALL P (SOME x) ⇔ P x
   |- (some x. F) = NONE
   |- (∀x. R x x) ⇒ ∀x. OPTREL R x x
   |- ((OPTION_MAP f x = NONE) ⇔ (x = NONE)) ∧
      ((NONE = OPTION_MAP f x) ⇔ (x = NONE))
   |- (∀x. NONE <*> x = NONE) ∧ ∀f x. SOME f <*> x = OPTION_MAP f x
   |- OPTION_CHOICE m1 NONE = m1
   |- (∀m2. OPTION_CHOICE NONE m2 = m2) ∧
      ∀x m2. OPTION_CHOICE (SOME x) m2 = SOME x
   |- ((OPTION_GUARD b = SOME ()) ⇔ b) ∧ ((OPTION_GUARD b = NONE) ⇔ ¬b)
   |- (OPTION_GUARD T = SOME ()) ∧ (OPTION_GUARD F = NONE)
   |- ((OPTION_IGNORE_BIND m1 m2 = NONE) ⇔ (m1 = NONE) ∨ (m2 = NONE)) ∧
      ((OPTION_IGNORE_BIND m1 m2 = SOME y) ⇔
       ∃x. (m1 = SOME x) ∧ (m2 = SOME y))
   |- (OPTION_IGNORE_BIND NONE m = NONE) ∧
      (OPTION_IGNORE_BIND (SOME v) m = m)
   |- ((OPTION_BIND p f = NONE) ⇔
       (p = NONE) ∨ ∃x. (p = SOME x) ∧ (f x = NONE)) ∧
      ((OPTION_BIND p f = SOME y) ⇔ ∃x. (p = SOME x) ∧ (f x = SOME y))
   |- (∀f. OPTION_BIND NONE f = NONE) ∧
      ∀x f. OPTION_BIND (SOME x) f = f x
   |- (OPTION_MAP2 f o1 o2 = NONE) ⇔ (o1 = NONE) ∨ (o2 = NONE)
   |- (OPTION_MAP2 f o1 o2 = SOME v) ⇔
      ∃x1 x2. (o1 = SOME x1) ∧ (o2 = SOME x2) ∧ (v = f x1 x2)
   |- ∀f x y. (OPTION_MAP f x = SOME y) ⇔ ∃z. (x = SOME z) ∧ (y = f z)
   |- (((if P then SOME x else NONE) = NONE) ⇔ ¬P) ∧
      (((if P then NONE else SOME x) = NONE) ⇔ P) ∧
      (((if P then SOME x else NONE) = SOME y) ⇔ P ∧ (x = y)) ∧
      (((if P then NONE else SOME x) = SOME y) ⇔ ¬P ∧ (x = y))
   |- (((if P then X else NONE) = NONE) ⇔ P ⇒ IS_NONE X) ∧
      (((if P then NONE else X) = NONE) ⇔ IS_SOME X ⇒ P) ∧
      (((if P then X else NONE) = SOME x) ⇔ P ∧ (X = SOME x)) ∧
      (((if P then NONE else X) = SOME x) ⇔ ¬P ∧ (X = SOME x))
   |- ∀x. NONE ≠ SOME x
   |- (OPTION_MAP2 f (SOME x) (SOME y) = SOME (f x y)) ∧
      (OPTION_MAP2 f (SOME x) NONE = NONE) ∧
      (OPTION_MAP2 f NONE (SOME y) = NONE) ∧
      (OPTION_MAP2 f NONE NONE = NONE)
   |- (∀f x. OPTION_MAP f (SOME x) = SOME (f x)) ∧
      ∀f. OPTION_MAP f NONE = NONE

Simplification set: REDUCE
Conversions:
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “EVEN x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “ODD x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “PRE x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “SUC x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “DIV2 x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x * y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x + y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x − y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x DIV y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x MOD y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ** y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x < y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ≤ y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x > y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ≥ y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “MIN x y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “MAX x y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x = y”

Simplification set: sum
Rewrite rules:
   |- (∀y x. (INL x = INL y) ⇔ (x = y)) ∧
      ∀y x. (INR x = INR y) ⇔ (x = y)
   |- (∀P Q x. SUM_ALL P Q (INL x) ⇔ P x) ∧
      ∀P Q y. SUM_ALL P Q (INR y) ⇔ Q y
   |- (∀f g a. (f ++ g) (INL a) = INL (f a)) ∧
      ∀f g b. (f ++ g) (INR b) = INR (g b)
   |- ∀x. ¬ISR x ⇔ ISL x
   |- ∀x. ¬ISL x ⇔ ISR x
   |- (∀x y z. ((if P then INR x else INL y) = INR z) ⇔ P ∧ (z = x)) ∧
      (∀x y z. ((if P then INR x else INL y) = INL z) ⇔ ¬P ∧ (z = y)) ∧
      (∀x y z. ((if P then INL x else INR y) = INL z) ⇔ P ∧ (z = x)) ∧
      ∀x y z. ((if P then INL x else INR y) = INR z) ⇔ ¬P ∧ (z = y)
   |- (∀x f f1. sum_CASE (INL x) f f1 = f x) ∧
      ∀y f f1. sum_CASE (INR y) f f1 = f1 y
   |- ∀x. OUTL (INL x) = x
   |- ∀x. ISR x ⇒ (INR (OUTR x) = x)
   |- ∀x. ISL x ⇒ (INL (OUTL x) = x)
   |- ∀x. OUTR (INR x) = x
   |- (∀x. ISL (INL x)) ∧ ∀y. ¬ISL (INR y)
   |- (∀x. ISR (INR x)) ∧ ∀y. ¬ISR (INL y)
   |- ∀x y. INL x ≠ INR y

Simplification set: COMBIN
Rewrite rules:
   |- ∀x. I x = x
   |- ∀f. (I ∘ f = f) ∧ (f ∘ I = f)
   |- ∀x y. K x y = x
   |- ∀f g x. S f g x = f x (g x)
   |- ∀f g h. (f ∘ g) ∘ h = f ∘ g ∘ h
   |- ∀f g x. (f ∘ g) x = f (g x)
   |- ∀f x. W f x = f x x
   |- ∀f x y. combin$C f x y = f y x
   |- (∀f v. K v ∘ f = K v) ∧ ∀f v. f ∘ K v = K (f v)

Simplification set: ARITH_RWTS
Rewrite rules:
   |- ∀x. ((SUC x = 1) ⇔ (x = 0)) ∧ ((1 = SUC x) ⇔ (x = 0))
   |- ∀x. ((SUC x = 2) ⇔ (x = 1)) ∧ ((2 = SUC x) ⇔ (x = 1))
   |- ∀m. m + 0 = m
   |- ∀m. 0 + m = m
   |- ∀m n. (m + n = 0) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (0 = m + n) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (m + n = m) ⇔ (n = 0)
   |- ∀m n. (n + m = m) ⇔ (n = 0)
   |- ∀m n. (m * n = 0) ⇔ (m = 0) ∨ (n = 0)
   |- ∀m n. (0 = m * n) ⇔ (m = 0) ∨ (n = 0)
   |- ∀x y. (x * y = 1) ⇔ (x = 1) ∧ (y = 1)
   |- ∀x y. (1 = x * y) ⇔ (x = 1) ∧ (y = 1)
   |- ∀m. m * 0 = 0
   |- ∀m. 0 * m = 0
   |- ∀x y. (x * y = SUC 0) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀x y. (SUC 0 = x * y) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀m. m * 1 = m
   |- ∀m. 1 * m = m
   |- ∀c. c − c = 0
   |- ∀m. SUC m − 1 = m
   |- ∀m. (0 − m = 0) ∧ (m − 0 = m)
   |- ∀a c. a + c − c = a
   |- ∀a c. c + a − c = a
   |- ∀m n. (m − n = 0) ⇔ m ≤ n
   |- ∀m n. (0 = m − n) ⇔ m ≤ n
   |- ∀n m. n − m ≤ n
   |- ∀n m. SUC n − SUC m = n − m
   |- ∀m n p. m − n > p ⇔ m > n + p
   |- ∀m n p. m − n < p ⇔ m < n + p ∧ 0 < p
   |- ∀m n p. m − n ≥ p ⇔ m ≥ n + p ∨ 0 ≥ p
   |- ∀m n p. m − n ≤ p ⇔ m ≤ n + p
   |- (PRE 0 = 0) ∧ ∀m. PRE (SUC m) = m
   |- ∀n m. (n ** m = 0) ⇔ (n = 0) ∧ 0 < m
   |- ∀n. (1 ** n = 1) ∧ (n ** 1 = n)
   |- ∀n m. (n ** m = 1) ⇔ (n = 1) ∨ (m = 0)
   |- 0 < x ** y ⇔ 0 < x ∨ (y = 0)
   |- ∀b1 b2 x. (b1 ** x = b2 ** x) ⇔ (x = 0) ∨ (b1 = b2)
   |- ∀b. 1 < b ⇒ ∀n m. (b ** n = b ** m) ⇔ (n = m)
   |- ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n
   |- ∀b. 1 < b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n
   |- ∀a b. a ** n < b ** n ⇔ a < b ∧ 0 < n
   |- ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ (n = 0)
   |- ∀n. n ≤ 0 ⇔ (n = 0)
   |- ∀n. 0 < SUC n
   |- ∀m n. m ≤ m + n
   |- 0 ≤ x
   |- SUC x > 0
   |- x ≥ 0
   |- x < SUC x
   |- x ≤ SUC x
   |- x < x + c ⇔ 0 < c
   |- x < c + x ⇔ 0 < c
   |- x ≤ x + c ⇔ 0 ≤ c
   |- x ≤ c + x ⇔ 0 ≤ c
   |- ∀m. m ≤ m
   |- x ≥ x
   |- ∀m n p. m + p < n + p ⇔ m < n
   |- ∀m n p. p + m < p + n ⇔ m < n
   |- ∀m n p. m + n ≤ m + p ⇔ n ≤ p
   |- ∀m n p. n + m ≤ p + m ⇔ n ≤ p
   |- ∀m n p. (m + p = n + p) ⇔ (m = n)
   |- ∀m n p. (p + m = p + n) ⇔ (m = n)
   |- x + y < w + x ⇔ y < w
   |- y + x < x + w ⇔ y < w
   |- ∀m n. (SUC m = SUC n) ⇔ (m = n)
   |- ∀m n. SUC m < SUC n ⇔ m < n
   |- ∀n m. SUC n ≤ SUC m ⇔ n ≤ m
   |- ∀m i n. SUC n * m < SUC n * i ⇔ m < i
   |- ∀p m n. (n * SUC p = m * SUC p) ⇔ (n = m)
   |- ∀m i n. (SUC n * m = SUC n * i) ⇔ (m = i)
   |- ∀n m. ¬(SUC n ≤ m) ⇔ m ≤ n
   |- ∀p q n m. (n * SUC q ** p = m * SUC q ** p) ⇔ (n = m)
   |- ∀m n p. m * n ≤ m * p ⇔ (m = 0) ∨ n ≤ p
   |- ∀m n p. m * n ≤ p * n ⇔ (n = 0) ∨ m ≤ p
   |- ∀m n p. m * n < m * p ⇔ 0 < m ∧ n < p
   |- ∀m n p. m * n < p * n ⇔ 0 < n ∧ m < p
   |- (m < m * n ⇔ 0 < m ∧ 1 < n) ∧ (m < n * m ⇔ 0 < m ∧ 1 < n)
   |- (m * n < m ⇔ 0 < m ∧ (n = 0)) ∧ (m * n < n ⇔ 0 < n ∧ (m = 0))
   |- (m ≤ m * n ⇔ (m = 0) ∨ 0 < n) ∧ (m ≤ n * m ⇔ (m = 0) ∨ 0 < n)
   |- (m * n ≤ m ⇔ (m = 0) ∨ n ≤ 1) ∧ (m * n ≤ n ⇔ (n = 0) ∨ m ≤ 1)
   |- ∀m n. SUC n ** m ≠ 0
   |- ∀n m. SUC (n + n) ≠ m + m
   |- ∀m n. ¬(SUC (m + n) ≤ m)
   |- ∀n. ¬(SUC n ≤ 0)
   |- ∀n. ¬(n < 0)
   |- ∀n. ¬(n < n)
   |- ¬(x > x)
   |- ∀n. (MIN n 0 = 0) ∧ (MIN 0 n = 0)
   |- ∀n. (MAX n 0 = n) ∧ (MAX 0 n = n)
   |- ∀n. MIN n n = n
   |- ∀n. MAX n n = n
   |- ∀n m p.
        (MIN m n ≤ p ⇔ m ≤ p ∨ n ≤ p) ∧ (p ≤ MIN m n ⇔ p ≤ m ∧ p ≤ n)
   |- ∀n m p.
        (p ≤ MAX m n ⇔ p ≤ m ∨ p ≤ n) ∧ (MAX m n ≤ p ⇔ m ≤ p ∧ n ≤ p)
   |- ∀n m p.
        (MIN m n < p ⇔ m < p ∨ n < p) ∧ (p < MIN m n ⇔ p < m ∧ p < n)
   |- ∀n m p.
        (p < MAX m n ⇔ p < m ∨ p < n) ∧ (MAX m n < p ⇔ m < p ∧ n < p)
   |- ∀m n. (MIN m n = MAX m n) ⇔ (m = n)
   |- ∀m n. MIN m n < MAX m n ⇔ m ≠ n
   |- ∀x y. 0 < y ⇒ ((x MOD y = x) ⇔ x < y)
   |- ∀n. 0 < n ⇒ (n DIV n = 1) ∧ (n MOD n = 0)
   |- ∀q. q DIV 1 = q
   |- ∀k. k MOD 1 = 0
   |- ∀n k. k < n ⇒ (k MOD n = k)
   |- ∀n. 0 < n ⇒ (0 MOD n = 0)
   |- ∀n. 0 < n ⇒ ∀k. k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT1 x) = 0)) ∧
      ((NUMERAL (BIT2 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT2 x) = 0))
   |- ∀m n. 0 < n ⇒ m MOD n < n
   |- ∀n d. 0 < n ∧ 1 < d ⇒ n DIV d < n

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER

Simplification set: ARITH_RWTS, OLD_ARITH_DP
Decision procedures:
   ARITH_REDUCER
Rewrite rules:
   |- ∀x. ((SUC x = 1) ⇔ (x = 0)) ∧ ((1 = SUC x) ⇔ (x = 0))
   |- ∀x. ((SUC x = 2) ⇔ (x = 1)) ∧ ((2 = SUC x) ⇔ (x = 1))
   |- ∀m. m + 0 = m
   |- ∀m. 0 + m = m
   |- ∀m n. (m + n = 0) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (0 = m + n) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (m + n = m) ⇔ (n = 0)
   |- ∀m n. (n + m = m) ⇔ (n = 0)
   |- ∀m n. (m * n = 0) ⇔ (m = 0) ∨ (n = 0)
   |- ∀m n. (0 = m * n) ⇔ (m = 0) ∨ (n = 0)
   |- ∀x y. (x * y = 1) ⇔ (x = 1) ∧ (y = 1)
   |- ∀x y. (1 = x * y) ⇔ (x = 1) ∧ (y = 1)
   |- ∀m. m * 0 = 0
   |- ∀m. 0 * m = 0
   |- ∀x y. (x * y = SUC 0) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀x y. (SUC 0 = x * y) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀m. m * 1 = m
   |- ∀m. 1 * m = m
   |- ∀c. c − c = 0
   |- ∀m. SUC m − 1 = m
   |- ∀m. (0 − m = 0) ∧ (m − 0 = m)
   |- ∀a c. a + c − c = a
   |- ∀a c. c + a − c = a
   |- ∀m n. (m − n = 0) ⇔ m ≤ n
   |- ∀m n. (0 = m − n) ⇔ m ≤ n
   |- ∀n m. n − m ≤ n
   |- ∀n m. SUC n − SUC m = n − m
   |- ∀m n p. m − n > p ⇔ m > n + p
   |- ∀m n p. m − n < p ⇔ m < n + p ∧ 0 < p
   |- ∀m n p. m − n ≥ p ⇔ m ≥ n + p ∨ 0 ≥ p
   |- ∀m n p. m − n ≤ p ⇔ m ≤ n + p
   |- (PRE 0 = 0) ∧ ∀m. PRE (SUC m) = m
   |- ∀n m. (n ** m = 0) ⇔ (n = 0) ∧ 0 < m
   |- ∀n. (1 ** n = 1) ∧ (n ** 1 = n)
   |- ∀n m. (n ** m = 1) ⇔ (n = 1) ∨ (m = 0)
   |- 0 < x ** y ⇔ 0 < x ∨ (y = 0)
   |- ∀b1 b2 x. (b1 ** x = b2 ** x) ⇔ (x = 0) ∨ (b1 = b2)
   |- ∀b. 1 < b ⇒ ∀n m. (b ** n = b ** m) ⇔ (n = m)
   |- ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n
   |- ∀b. 1 < b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n
   |- ∀a b. a ** n < b ** n ⇔ a < b ∧ 0 < n
   |- ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ (n = 0)
   |- ∀n. n ≤ 0 ⇔ (n = 0)
   |- ∀n. 0 < SUC n
   |- ∀m n. m ≤ m + n
   |- 0 ≤ x
   |- SUC x > 0
   |- x ≥ 0
   |- x < SUC x
   |- x ≤ SUC x
   |- x < x + c ⇔ 0 < c
   |- x < c + x ⇔ 0 < c
   |- x ≤ x + c ⇔ 0 ≤ c
   |- x ≤ c + x ⇔ 0 ≤ c
   |- ∀m. m ≤ m
   |- x ≥ x
   |- ∀m n p. m + p < n + p ⇔ m < n
   |- ∀m n p. p + m < p + n ⇔ m < n
   |- ∀m n p. m + n ≤ m + p ⇔ n ≤ p
   |- ∀m n p. n + m ≤ p + m ⇔ n ≤ p
   |- ∀m n p. (m + p = n + p) ⇔ (m = n)
   |- ∀m n p. (p + m = p + n) ⇔ (m = n)
   |- x + y < w + x ⇔ y < w
   |- y + x < x + w ⇔ y < w
   |- ∀m n. (SUC m = SUC n) ⇔ (m = n)
   |- ∀m n. SUC m < SUC n ⇔ m < n
   |- ∀n m. SUC n ≤ SUC m ⇔ n ≤ m
   |- ∀m i n. SUC n * m < SUC n * i ⇔ m < i
   |- ∀p m n. (n * SUC p = m * SUC p) ⇔ (n = m)
   |- ∀m i n. (SUC n * m = SUC n * i) ⇔ (m = i)
   |- ∀n m. ¬(SUC n ≤ m) ⇔ m ≤ n
   |- ∀p q n m. (n * SUC q ** p = m * SUC q ** p) ⇔ (n = m)
   |- ∀m n p. m * n ≤ m * p ⇔ (m = 0) ∨ n ≤ p
   |- ∀m n p. m * n ≤ p * n ⇔ (n = 0) ∨ m ≤ p
   |- ∀m n p. m * n < m * p ⇔ 0 < m ∧ n < p
   |- ∀m n p. m * n < p * n ⇔ 0 < n ∧ m < p
   |- (m < m * n ⇔ 0 < m ∧ 1 < n) ∧ (m < n * m ⇔ 0 < m ∧ 1 < n)
   |- (m * n < m ⇔ 0 < m ∧ (n = 0)) ∧ (m * n < n ⇔ 0 < n ∧ (m = 0))
   |- (m ≤ m * n ⇔ (m = 0) ∨ 0 < n) ∧ (m ≤ n * m ⇔ (m = 0) ∨ 0 < n)
   |- (m * n ≤ m ⇔ (m = 0) ∨ n ≤ 1) ∧ (m * n ≤ n ⇔ (n = 0) ∨ m ≤ 1)
   |- ∀m n. SUC n ** m ≠ 0
   |- ∀n m. SUC (n + n) ≠ m + m
   |- ∀m n. ¬(SUC (m + n) ≤ m)
   |- ∀n. ¬(SUC n ≤ 0)
   |- ∀n. ¬(n < 0)
   |- ∀n. ¬(n < n)
   |- ¬(x > x)
   |- ∀n. (MIN n 0 = 0) ∧ (MIN 0 n = 0)
   |- ∀n. (MAX n 0 = n) ∧ (MAX 0 n = n)
   |- ∀n. MIN n n = n
   |- ∀n. MAX n n = n
   |- ∀n m p.
        (MIN m n ≤ p ⇔ m ≤ p ∨ n ≤ p) ∧ (p ≤ MIN m n ⇔ p ≤ m ∧ p ≤ n)
   |- ∀n m p.
        (p ≤ MAX m n ⇔ p ≤ m ∨ p ≤ n) ∧ (MAX m n ≤ p ⇔ m ≤ p ∧ n ≤ p)
   |- ∀n m p.
        (MIN m n < p ⇔ m < p ∨ n < p) ∧ (p < MIN m n ⇔ p < m ∧ p < n)
   |- ∀n m p.
        (p < MAX m n ⇔ p < m ∨ p < n) ∧ (MAX m n < p ⇔ m < p ∧ n < p)
   |- ∀m n. (MIN m n = MAX m n) ⇔ (m = n)
   |- ∀m n. MIN m n < MAX m n ⇔ m ≠ n
   |- ∀x y. 0 < y ⇒ ((x MOD y = x) ⇔ x < y)
   |- ∀n. 0 < n ⇒ (n DIV n = 1) ∧ (n MOD n = 0)
   |- ∀q. q DIV 1 = q
   |- ∀k. k MOD 1 = 0
   |- ∀n k. k < n ⇒ (k MOD n = k)
   |- ∀n. 0 < n ⇒ (0 MOD n = 0)
   |- ∀n. 0 < n ⇒ ∀k. k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT1 x) = 0)) ∧
      ((NUMERAL (BIT2 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT2 x) = 0))
   |- ∀m n. 0 < n ⇒ m MOD n < n
   |- ∀n d. 0 < n ∧ 1 < d ⇒ n DIV d < n

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER
:
   simpset
val once_asm_rewrite_tac = fn: thm list -> tactic
val once_rewrite_tac = fn: thm list -> tactic
val op_U = fn: ('a -> 'a -> bool) -> 'a list list -> 'a list
val op_arity = fn: {Thy: string, Tyop: string} -> int option
val op_insert = fn: ('a -> 'a -> bool) -> 'a -> 'a list -> 'a list
val op_intersect = fn: ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val op_mem = fn: ('a -> 'a -> bool) -> 'a -> 'a list -> bool
val op_mk_set = fn: ('a -> 'a -> bool) -> 'a list -> 'a list
val op_set_diff = fn: ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val op_union = fn: ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val overload_info_for = fn: string -> unit
val overload_on = fn: string * term -> unit
val overload_on_by_nametype = fn:
   string -> {Name: string, Thy: string} -> unit
val pair = fn: 'a -> 'b -> 'a * 'b
val pair_compare = fn: 'a cmp * 'b cmp -> ('a * 'b) cmp
val pair_of_list = fn: 'a list -> 'a * 'a
val pairarg_tac = fn: tactic
val parents = fn: string -> string list
val parse_from_grammars = fn:
   type_grammar.grammar * term_grammar.grammar ->
     (hol_type frag list -> hol_type) * (term frag list -> term)
val parse_in_context = fn: term list -> term frag list -> term
val part_match_exists_tac = fn: (term -> term) -> term -> tactic
val partial = fn: exn -> ('a -> 'b option) -> 'a -> 'b
val partition = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
datatype pel = pAbs | pLeft | pRight
val pluck = fn: ('a -> bool) -> 'a list -> 'a * 'a list
val polymorphic = fn: hol_type -> bool
val pop_assum = fn: thm_tactic -> tactic
val post_process_term = ref fn: (term -> term) ref
eqtype pp_element
val pp_flags = {show_numeral_types = ref false, show_types = ref false}:
   {show_numeral_types: bool ref, show_types: bool ref}
val pp_rewrites = fn: ppstream -> rewrites -> unit
val pp_term = fn: ppstream -> term -> unit
val pp_term_without_overloads = fn:
   (string * term) list -> ppstream -> term -> unit
val pp_term_without_overloads_on = fn:
   string list -> ppstream -> term -> unit
val pp_theory = fn: ppstream -> theory -> unit
val pp_theory_as_html = fn: ppstream -> string -> unit
val pp_thm = fn: ppstream -> thm -> unit
val pp_type = fn: ppstream -> hol_type -> unit
val pp_type_without_abbrevs = fn: string list -> ppstream -> hol_type -> unit
val pp_with_bquotes = fn: (ppstream -> 'a -> unit) -> ppstream -> 'a -> unit
type ppstream
val ppstring = fn: (ppstream -> 'a -> unit) -> 'a -> string
type pred = term -> bool
val prefer_form_with_tok = fn: {term_name: string, tok: string} -> unit
val prim_delete_const = fn: KernelSig.kernelname -> unit
val prim_delete_type = fn: {Thy: string, Tyop: string} -> unit
val prim_irule = fn: thm -> tactic
val prim_mk_const = fn: {Name: string, Thy: string} -> term
val prim_new_const = fn: KernelSig.kernelname -> hol_type -> term
val prim_new_type = fn: {Thy: string, Tyop: string} -> int -> unit
val prim_specification = fn: string -> string list -> thm -> thm
val prim_type_definition = fn: {Thy: string, Tyop: string} * thm -> thm
val prim_variant = fn: term list -> term -> term
val prime = fn: string -> string
val priming = ref NONE: string option ref
val print_apropos = fn: term -> unit
val print_find = fn: string -> unit
val print_from_grammars = fn:
   type_grammar.grammar * term_grammar.grammar ->
     (ppstream -> hol_type -> unit) * (ppstream -> term -> unit)
val print_match = fn: string list -> term -> unit
val print_term = fn: term -> unit
val print_term_by_grammar = fn:
   type_grammar.grammar * term_grammar.grammar -> term -> unit
val print_term_grammar = fn: unit -> unit
val print_theory = fn: string -> unit
val print_theory_as_html = fn: string -> string -> unit
val print_theory_to_file = fn: string -> string -> unit
val print_theory_to_outstream = fn: string -> TextIO.outstream -> unit
val print_thm = fn: thm -> unit
val print_thy_loads = ref false: bool ref
val print_type = fn: hol_type -> unit
val print_with_style = fn: term_pp_types.pp_style list -> string -> unit
val prove = fn: term * tactic -> thm
val prove_abs_fn_one_one = fn: thm -> thm
val prove_abs_fn_onto = fn: thm -> thm
val prove_case_elim_thm = fn: {case_def: thm, nchotomy: thm} -> thm
val prove_case_eq_thm = fn: {case_def: thm, nchotomy: thm} -> thm
val prove_case_rand_thm = fn: {case_def: thm, nchotomy: thm} -> thm
val prove_cases_thm = fn: thm -> thm list
val prove_constructors_distinct = fn: thm -> thm option list
val prove_constructors_one_one = fn: thm -> thm option list
val prove_induction_thm = fn: thm -> thm
val prove_rec_fn_exists = fn: thm -> term -> thm
val prove_rep_fn_one_one = fn: thm -> thm
val prove_rep_fn_onto = fn: thm -> thm
val prove_tac = fn: thm list -> tactic
val pure_ss = Simplification set: PURE
: simpset
val qabbrev_tac = fn: term quotation -> tactic
val qexists_tac = fn: term quotation -> tactic
val qhdtm_assum = fn: term quotation -> thm_tactic -> tactic
val qhdtm_x_assum = fn: term quotation -> thm_tactic -> tactic
val qho_match_abbrev_tac = fn: term quotation -> tactic
val qid_spec_tac = fn: term quotation -> tactic
val qmatch_abbrev_tac = fn: term quotation -> tactic
val qmatch_asmsub_abbrev_tac = fn: term quotation -> tactic
val qmatch_asmsub_rename_tac = fn: term quotation -> tactic
val qmatch_assum_abbrev_tac = fn: term quotation -> tactic
val qmatch_assum_rename_tac = fn: term quotation -> tactic
val qmatch_goalsub_abbrev_tac = fn: term quotation -> tactic
val qmatch_goalsub_rename_tac = fn: term quotation -> tactic
val qmatch_rename_tac = fn: term quotation -> tactic
val qpat_abbrev_tac = fn: term quotation -> tactic
val qpat_assum = fn: term quotation -> thm_tactic -> tactic
val qpat_x_assum = fn: term quotation -> thm_tactic -> tactic
val qspec_tac = fn: term quotation * term quotation -> tactic
val qspec_then = fn: term quotation -> thm_tactic -> thm -> tactic
val qspecl_then = fn: term quotation list -> thm_tactic -> thm -> tactic
val qsuff_tac = fn: term quotation -> tactic
val quadruple = fn: 'a -> 'b -> 'c -> 'd -> 'a * 'b * 'c * 'd
val quadruple_of_list = fn: 'a list -> 'a * 'a * 'a * 'a
val quiet_messages = fn: ('a -> 'b) -> 'a -> 'b
val quiet_warnings = fn: ('a -> 'b) -> 'a -> 'b
val qunabbrev_tac = fn: term quotation -> tactic
type 'a quotation = 'a frag list
val quote = fn: string -> string
val quote_adjoin_to_theory = fn:
   string ?.HolKernel.Theory.quotation ->
     string ?.HolKernel.Theory.quotation -> unit
val qx_choose_then = fn: term quotation -> thm_tactic -> thm_tactic
val qx_choosel_then = fn: term quotation list -> thm_tactic -> thm_tactic
val qx_gen_tac = fn: term quotation -> tactic
val qx_genl_tac = fn: term quotation list -> tactic
val rand = fn: term -> term
val rator = fn: term -> term
val raw_match = fn:
   hol_type list ->
     term set ->
       term ->
         term ->
           (term, term) Term.subst * (hol_type, hol_type) Term.subst ->
             ((term, term) Term.subst * term set) *
             ((hol_type, hol_type) Term.subst * hol_type list)
val raw_match_type = fn:
   hol_type ->
     hol_type ->
       (hol_type, hol_type) Lib.subst * hol_type list ->
         (hol_type, hol_type) Lib.subst * hol_type list
val rawterm_pp = fn: ('a -> 'b) -> 'a -> 'b
val rdistrib_tm =
   “f (g y z) x = g (f y x) (f z x)”:
   term
val read_raw = fn: term vector -> string -> term
val real_time = fn: ('a -> 'b) -> 'a -> 'b
val recInduct = fn: thm -> tactic
val register_alias_trace = fn: {alias: string, original: string} -> unit
val register_btrace = fn: string * bool ref -> unit
val register_ftrace = fn:
   string * ((unit -> int) * (int -> unit)) * int -> unit
val register_hook = fn: string * (TheoryDelta.t -> unit) -> unit
val register_trace = fn: string * int ref * int -> unit
val release = "Kananaskis": string
val remove_numeral_form = fn: char -> unit
val remove_ovl_mapping = fn: string -> {Name: string, Thy: string} -> unit
val remove_rules_for_term = fn: string -> unit
val remove_termtok = fn: {term_name: string, tok: string} -> unit
val remove_type_abbrev = fn: string -> unit
val remove_user_printer = fn:
   string -> (term * term_grammar.userprinter) option
val rename = fn: term quotation list -> tactic
val rename1 = fn: term quotation -> tactic
val rename_bvar = fn: string -> term -> term
val repeat = fn: ('a -> 'a) -> 'a -> 'a
val res_abstract_tm =
   “RES_ABSTRACT”:
   term
val res_exists1_tm =
   “RES_EXISTS_UNIQUE”:
   term
val res_exists_tm =
   “RES_EXISTS”:
   term
val res_forall_tm =
   “RES_FORALL”:
   term
val res_select_tm =
   “RES_SELECT”:
   term
val res_tac = fn: tactic
val reset = fn: ('a, 'b) istream -> ('a, 'b) istream
val reset_trace = fn: string -> unit
val reset_traces = fn: unit -> unit
val respect_width_ref = fn:
   int ref -> (ppstream -> 'a -> unit) -> ppstream -> 'a -> unit
val restore_prover = fn: unit -> unit
val rev_assoc = fn: ''a -> ('b * ''a) list -> 'b
val rev_full_simp_tac = fn: simpset -> thm list -> tactic
val rev_itlist = fn: ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val rev_itlist2 = fn:
   ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val reveal = fn: string -> unit
val reverse = fn: tactic -> tactic
val rewrite_tac = fn: thm list -> tactic
type rewrites
val rewrites = fn: thm list -> ssfrag
val rfs = fn: thm list -> tactic
val rhs = fn: term -> term
val rpair = fn: 'a -> 'b -> 'b * 'a
val rpt = fn: tactic -> tactic
type rule = thm -> thm
val rule_assum_tac = fn: (thm -> thm) -> tactic
val rw = fn: thm list -> tactic
val rw_tac = fn: simpset -> thm list -> tactic
val same_const = fn: term -> term -> bool
val save_dep = fn: string -> thm -> thm
val save_thm = fn: string * thm -> thm
val save_thm_attrs = fn: string -> string * string list * thm -> thm
val say = fn: string -> unit
val saying = ref true: bool ref
val scrub = fn: unit -> unit
val sdest_binder = fn: string * string -> exn -> term -> term * term
val sdest_binop = fn: string * string -> exn -> term -> term * term
val sdest_monop = fn: string * string -> exn -> term -> term
val select = “$@”: term
val send_to_back_overload = fn: string -> {Name: string, Thy: string} -> unit
val separate = fn: 'a -> 'a list -> 'a list
type 'a set
val set_MLname = fn: string -> string -> unit
val set_diff = fn: ''a list -> ''a list -> ''a list
val set_eq = fn: ''a list -> ''a list -> bool
val set_fixity = fn: string -> fixity -> unit
val set_grammar_ancestry = fn: string list -> unit
val set_implicit_rewrites = fn: rewrites -> unit
val set_known_constants = fn: string list -> unit
val set_mapped_fixity = fn:
   {fixity: fixity, term_name: string, tok: string} -> unit
val set_prover = fn: (term * tactic -> thm) -> unit
val set_term_printer = fn:
   (ppstream -> term -> unit) -> ppstream -> term -> unit
val set_trace = fn: string -> int -> unit
val sg = fn: term quotation -> tactic
val show_assums = ref false: bool ref
val show_axioms = ref true: bool ref
val show_numeral_types = ref false: bool ref
val show_scrub = ref true: bool ref
val show_tags = ref false: bool ref
val show_types = ref false: bool ref
val show_types_verbosely = ref false: bool ref
val simp = fn: thm list -> tactic
val simp_tac = fn: simpset -> thm list -> tactic
type simpset
val singleton_of_list = fn: 'a list -> 'a
val snd = fn: 'a * 'b -> 'b
val sort = fn: ('a -> 'a -> bool) -> 'a list -> 'a list
val sort_vars = fn: string list -> term list -> term list
val spine_binop = fn: ('a -> ('a * 'a) option) -> 'a -> 'a list
val split = fn: ('a * 'b) list -> 'a list * 'b list
val split_after = fn: int -> 'a list -> 'a list * 'a list
val split_pair_case_tac = fn: tactic
val spose_not_then = fn: (thm -> tactic) -> tactic
val srw_ss = fn: unit -> simpset
val srw_tac = fn: ssfrag list -> thm list -> tactic
type ssfrag
val stamp = fn: string -> Time.time
val start_real_time = fn: unit -> Timer.real_timer
val start_time = fn: unit -> Timer.cpu_timer
val state = fn: ('a, 'b) istream -> 'b
val std_binder_precedence = 0: int
val std_ss =
   Simplification set: PURE

Simplification set: BOOL
Conversions:
   BETA_CONV (beta reduction), keyed on pattern  “(λx. y) z”
Congruence rules:
   |- (v = v') ⇒ (literal_case f v = literal_case f (I v'))
Rewrite rules:
   |- ∀x. (x = x) ⇔ T
   |- ∀t.
        ((T ⇔ t) ⇔ t) ∧ ((t ⇔ T) ⇔ t) ∧ ((F ⇔ t) ⇔ ¬t) ∧ ((t ⇔ F) ⇔ ¬t)
   |- (∀t. ¬ ¬t ⇔ t) ∧ (¬T ⇔ F) ∧ (¬F ⇔ T)
   |- ∀t.
        (T ∧ t ⇔ t) ∧ (t ∧ T ⇔ t) ∧ (F ∧ t ⇔ F) ∧ (t ∧ F ⇔ F) ∧
        (t ∧ t ⇔ t)
   |- ∀t.
        (T ∨ t ⇔ T) ∧ (t ∨ T ⇔ T) ∧ (F ∨ t ⇔ t) ∧ (t ∨ F ⇔ t) ∧
        (t ∨ t ⇔ t)
   |- ∀t.
        (T ⇒ t ⇔ t) ∧ (t ⇒ T ⇔ T) ∧ (F ⇒ t ⇔ T) ∧ (t ⇒ t ⇔ T) ∧
        (t ⇒ F ⇔ ¬t)
   |- ∀t1 t2.
        ((if T then t1 else t2) = t1) ∧ ((if F then t1 else t2) = t2)
   |- ∀t. (∀x. t) ⇔ t
   |- ∀t. (∃x. t) ⇔ t
   |- ∀b t. (if b then t else t) = t
   |- ∀a. ∃x. x = a
   |- ∀a. ∃x. a = x
   |- ∀a. ∃!x. x = a
   |- ∀a. ∃!x. a = x
   |- (∀b e. (if b then T else e) ⇔ b ∨ e) ∧
      (∀b t. (if b then t else T) ⇔ b ⇒ t) ∧
      (∀b e. (if b then F else e) ⇔ ¬b ∧ e) ∧
      ∀b t. (if b then t else F) ⇔ b ∧ t
   |- literal_case f (I x) = f x
   |- ∀t. t ∨ ¬t
   |- ∀t. ¬t ∨ t
   |- (∀t1 t2. (if T then t1 else t2) = t1) ∧
      ∀t1 t2. (if F then t1 else t2) = t2
   |- ¬(t ∧ ¬t)
   |- ∀x. (@y. y = x) = x
   |- ∀x. (@y. x = y) = x
   |- (∀x::P. T) ⇔ T
   |- (∃x::P. F) ⇔ F

Simplification set: NOT
Rewrite rules:
   |- ∀A B. ¬(A ⇒ B) ⇔ A ∧ ¬B
   |- ∀A B. (¬(A ∧ B) ⇔ ¬A ∨ ¬B) ∧ (¬(A ∨ B) ⇔ ¬A ∧ ¬B)
   |- ∀P. ¬(∀x. P x) ⇔ ∃x. ¬P x
   |- ∀P. ¬(∃x. P x) ⇔ ∀x. ¬P x
   |- (¬p ⇔ ¬q) ⇔ (p ⇔ q)

Simplification set: CONG
Congruence rules:
   |- ∀x x' y y'. (x ⇔ x') ⇒ (x' ⇒ (y ⇔ y')) ⇒ (x ⇒ y ⇔ x' ⇒ y')
   |- ∀P Q x x' y y'.
        (P ⇔ Q) ⇒
        (Q ⇒ (x = x')) ⇒
        (¬Q ⇒ (y = y')) ⇒
        ((if P then x else y) = if Q then x' else y')
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_FORALL P f ⇔ RES_FORALL Q g)
   |- (P = Q) ⇒
      (∀x. x ∈ Q ⇒ (f x ⇔ g x)) ⇒
      (RES_EXISTS P f ⇔ RES_EXISTS Q g)

Simplification set: UNWIND
Conversions:
   UNWIND_EXISTS_CONV, keyed on pattern  “∃x. P”
   UNWIND_FORALL_CONV, keyed on pattern  “∀x. P”

Simplification set: PAIR
Rewrite rules:
   |- ∀x. (FST x,SND x) = x
   |- ∀x y. FST (x,y) = x
   |- ∀x y. SND (x,y) = y
   |- ∀x y a b. ((x,y) = (a,b)) ⇔ (x = a) ∧ (y = b)
   |- ∀f. CURRY (UNCURRY f) = f
   |- ∀f. UNCURRY (CURRY f) = f
   |- (CURRY f = CURRY g) ⇔ (f = g)
   |- (UNCURRY f = UNCURRY g) ⇔ (f = g)
   |- ∀f x y. CURRY f x y = f (x,y)
   |- ∀f g x y. (f ## g) (x,y) = (f x,g y)
   |- ∀f x y. UNCURRY f (x,y) = f x y

Simplification set: option
Rewrite rules:
   |- ∀x y. (SOME x = SOME y) ⇔ (x = y)
   |- ∀x. option_CASE x x SOME = x
   |- (OPTION_JOIN NONE = NONE) ∧ ∀x. OPTION_JOIN (SOME x) = x
   |- (∀v f. option_CASE NONE v f = v) ∧
      ∀x v f. option_CASE (SOME x) v f = f x
   |- ∀x. THE (SOME x) = x
   |- ∀x. option_CASE x NONE SOME = x
   |- ∀x. ¬IS_SOME x ⇔ (x = NONE)
   |- ∀x. IS_NONE x ⇔ (x = NONE)
   |- (∀x. IS_SOME (SOME x) ⇔ T) ∧ (IS_SOME NONE ⇔ F)
   |- ((some x. x = y) = SOME y) ∧ ((some x. y = x) = SOME y)
   |- (∀P. OPTION_ALL P NONE ⇔ T) ∧ ∀P x. OPTION_ALL P (SOME x) ⇔ P x
   |- (some x. F) = NONE
   |- (∀x. R x x) ⇒ ∀x. OPTREL R x x
   |- ((OPTION_MAP f x = NONE) ⇔ (x = NONE)) ∧
      ((NONE = OPTION_MAP f x) ⇔ (x = NONE))
   |- (∀x. NONE <*> x = NONE) ∧ ∀f x. SOME f <*> x = OPTION_MAP f x
   |- OPTION_CHOICE m1 NONE = m1
   |- (∀m2. OPTION_CHOICE NONE m2 = m2) ∧
      ∀x m2. OPTION_CHOICE (SOME x) m2 = SOME x
   |- ((OPTION_GUARD b = SOME ()) ⇔ b) ∧ ((OPTION_GUARD b = NONE) ⇔ ¬b)
   |- (OPTION_GUARD T = SOME ()) ∧ (OPTION_GUARD F = NONE)
   |- ((OPTION_IGNORE_BIND m1 m2 = NONE) ⇔ (m1 = NONE) ∨ (m2 = NONE)) ∧
      ((OPTION_IGNORE_BIND m1 m2 = SOME y) ⇔
       ∃x. (m1 = SOME x) ∧ (m2 = SOME y))
   |- (OPTION_IGNORE_BIND NONE m = NONE) ∧
      (OPTION_IGNORE_BIND (SOME v) m = m)
   |- ((OPTION_BIND p f = NONE) ⇔
       (p = NONE) ∨ ∃x. (p = SOME x) ∧ (f x = NONE)) ∧
      ((OPTION_BIND p f = SOME y) ⇔ ∃x. (p = SOME x) ∧ (f x = SOME y))
   |- (∀f. OPTION_BIND NONE f = NONE) ∧
      ∀x f. OPTION_BIND (SOME x) f = f x
   |- (OPTION_MAP2 f o1 o2 = NONE) ⇔ (o1 = NONE) ∨ (o2 = NONE)
   |- (OPTION_MAP2 f o1 o2 = SOME v) ⇔
      ∃x1 x2. (o1 = SOME x1) ∧ (o2 = SOME x2) ∧ (v = f x1 x2)
   |- ∀f x y. (OPTION_MAP f x = SOME y) ⇔ ∃z. (x = SOME z) ∧ (y = f z)
   |- (((if P then SOME x else NONE) = NONE) ⇔ ¬P) ∧
      (((if P then NONE else SOME x) = NONE) ⇔ P) ∧
      (((if P then SOME x else NONE) = SOME y) ⇔ P ∧ (x = y)) ∧
      (((if P then NONE else SOME x) = SOME y) ⇔ ¬P ∧ (x = y))
   |- (((if P then X else NONE) = NONE) ⇔ P ⇒ IS_NONE X) ∧
      (((if P then NONE else X) = NONE) ⇔ IS_SOME X ⇒ P) ∧
      (((if P then X else NONE) = SOME x) ⇔ P ∧ (X = SOME x)) ∧
      (((if P then NONE else X) = SOME x) ⇔ ¬P ∧ (X = SOME x))
   |- ∀x. NONE ≠ SOME x
   |- (OPTION_MAP2 f (SOME x) (SOME y) = SOME (f x y)) ∧
      (OPTION_MAP2 f (SOME x) NONE = NONE) ∧
      (OPTION_MAP2 f NONE (SOME y) = NONE) ∧
      (OPTION_MAP2 f NONE NONE = NONE)
   |- (∀f x. OPTION_MAP f (SOME x) = SOME (f x)) ∧
      ∀f. OPTION_MAP f NONE = NONE

Simplification set: REDUCE
Conversions:
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “EVEN x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “ODD x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “PRE x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “SUC x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “DIV2 x”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x * y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x + y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x − y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x DIV y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x MOD y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ** y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x < y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ≤ y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x > y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x ≥ y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “MIN x y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “MAX x y”
   REDUCE_CONV (arithmetic reduction), keyed on pattern  “x = y”

Simplification set: sum
Rewrite rules:
   |- (∀y x. (INL x = INL y) ⇔ (x = y)) ∧
      ∀y x. (INR x = INR y) ⇔ (x = y)
   |- (∀P Q x. SUM_ALL P Q (INL x) ⇔ P x) ∧
      ∀P Q y. SUM_ALL P Q (INR y) ⇔ Q y
   |- (∀f g a. (f ++ g) (INL a) = INL (f a)) ∧
      ∀f g b. (f ++ g) (INR b) = INR (g b)
   |- ∀x. ¬ISR x ⇔ ISL x
   |- ∀x. ¬ISL x ⇔ ISR x
   |- (∀x y z. ((if P then INR x else INL y) = INR z) ⇔ P ∧ (z = x)) ∧
      (∀x y z. ((if P then INR x else INL y) = INL z) ⇔ ¬P ∧ (z = y)) ∧
      (∀x y z. ((if P then INL x else INR y) = INL z) ⇔ P ∧ (z = x)) ∧
      ∀x y z. ((if P then INL x else INR y) = INR z) ⇔ ¬P ∧ (z = y)
   |- (∀x f f1. sum_CASE (INL x) f f1 = f x) ∧
      ∀y f f1. sum_CASE (INR y) f f1 = f1 y
   |- ∀x. OUTL (INL x) = x
   |- ∀x. ISR x ⇒ (INR (OUTR x) = x)
   |- ∀x. ISL x ⇒ (INL (OUTL x) = x)
   |- ∀x. OUTR (INR x) = x
   |- (∀x. ISL (INL x)) ∧ ∀y. ¬ISL (INR y)
   |- (∀x. ISR (INR x)) ∧ ∀y. ¬ISR (INL y)
   |- ∀x y. INL x ≠ INR y

Simplification set: COMBIN
Rewrite rules:
   |- ∀x. I x = x
   |- ∀f. (I ∘ f = f) ∧ (f ∘ I = f)
   |- ∀x y. K x y = x
   |- ∀f g x. S f g x = f x (g x)
   |- ∀f g h. (f ∘ g) ∘ h = f ∘ g ∘ h
   |- ∀f g x. (f ∘ g) x = f (g x)
   |- ∀f x. W f x = f x x
   |- ∀f x y. combin$C f x y = f y x
   |- (∀f v. K v ∘ f = K v) ∧ ∀f v. f ∘ K v = K (f v)

Simplification set: ARITH_RWTS
Rewrite rules:
   |- ∀x. ((SUC x = 1) ⇔ (x = 0)) ∧ ((1 = SUC x) ⇔ (x = 0))
   |- ∀x. ((SUC x = 2) ⇔ (x = 1)) ∧ ((2 = SUC x) ⇔ (x = 1))
   |- ∀m. m + 0 = m
   |- ∀m. 0 + m = m
   |- ∀m n. (m + n = 0) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (0 = m + n) ⇔ (m = 0) ∧ (n = 0)
   |- ∀m n. (m + n = m) ⇔ (n = 0)
   |- ∀m n. (n + m = m) ⇔ (n = 0)
   |- ∀m n. (m * n = 0) ⇔ (m = 0) ∨ (n = 0)
   |- ∀m n. (0 = m * n) ⇔ (m = 0) ∨ (n = 0)
   |- ∀x y. (x * y = 1) ⇔ (x = 1) ∧ (y = 1)
   |- ∀x y. (1 = x * y) ⇔ (x = 1) ∧ (y = 1)
   |- ∀m. m * 0 = 0
   |- ∀m. 0 * m = 0
   |- ∀x y. (x * y = SUC 0) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀x y. (SUC 0 = x * y) ⇔ (x = SUC 0) ∧ (y = SUC 0)
   |- ∀m. m * 1 = m
   |- ∀m. 1 * m = m
   |- ∀c. c − c = 0
   |- ∀m. SUC m − 1 = m
   |- ∀m. (0 − m = 0) ∧ (m − 0 = m)
   |- ∀a c. a + c − c = a
   |- ∀a c. c + a − c = a
   |- ∀m n. (m − n = 0) ⇔ m ≤ n
   |- ∀m n. (0 = m − n) ⇔ m ≤ n
   |- ∀n m. n − m ≤ n
   |- ∀n m. SUC n − SUC m = n − m
   |- ∀m n p. m − n > p ⇔ m > n + p
   |- ∀m n p. m − n < p ⇔ m < n + p ∧ 0 < p
   |- ∀m n p. m − n ≥ p ⇔ m ≥ n + p ∨ 0 ≥ p
   |- ∀m n p. m − n ≤ p ⇔ m ≤ n + p
   |- (PRE 0 = 0) ∧ ∀m. PRE (SUC m) = m
   |- ∀n m. (n ** m = 0) ⇔ (n = 0) ∧ 0 < m
   |- ∀n. (1 ** n = 1) ∧ (n ** 1 = n)
   |- ∀n m. (n ** m = 1) ⇔ (n = 1) ∨ (m = 0)
   |- 0 < x ** y ⇔ 0 < x ∨ (y = 0)
   |- ∀b1 b2 x. (b1 ** x = b2 ** x) ⇔ (x = 0) ∨ (b1 = b2)
   |- ∀b. 1 < b ⇒ ∀n m. (b ** n = b ** m) ⇔ (n = m)
   |- ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n
   |- ∀b. 1 < b ⇒ ∀n m. b ** m ≤ b ** n ⇔ m ≤ n
   |- ∀a b. a ** n < b ** n ⇔ a < b ∧ 0 < n
   |- ∀a b. a ** n ≤ b ** n ⇔ a ≤ b ∨ (n = 0)
   |- ∀n. n ≤ 0 ⇔ (n = 0)
   |- ∀n. 0 < SUC n
   |- ∀m n. m ≤ m + n
   |- 0 ≤ x
   |- SUC x > 0
   |- x ≥ 0
   |- x < SUC x
   |- x ≤ SUC x
   |- x < x + c ⇔ 0 < c
   |- x < c + x ⇔ 0 < c
   |- x ≤ x + c ⇔ 0 ≤ c
   |- x ≤ c + x ⇔ 0 ≤ c
   |- ∀m. m ≤ m
   |- x ≥ x
   |- ∀m n p. m + p < n + p ⇔ m < n
   |- ∀m n p. p + m < p + n ⇔ m < n
   |- ∀m n p. m + n ≤ m + p ⇔ n ≤ p
   |- ∀m n p. n + m ≤ p + m ⇔ n ≤ p
   |- ∀m n p. (m + p = n + p) ⇔ (m = n)
   |- ∀m n p. (p + m = p + n) ⇔ (m = n)
   |- x + y < w + x ⇔ y < w
   |- y + x < x + w ⇔ y < w
   |- ∀m n. (SUC m = SUC n) ⇔ (m = n)
   |- ∀m n. SUC m < SUC n ⇔ m < n
   |- ∀n m. SUC n ≤ SUC m ⇔ n ≤ m
   |- ∀m i n. SUC n * m < SUC n * i ⇔ m < i
   |- ∀p m n. (n * SUC p = m * SUC p) ⇔ (n = m)
   |- ∀m i n. (SUC n * m = SUC n * i) ⇔ (m = i)
   |- ∀n m. ¬(SUC n ≤ m) ⇔ m ≤ n
   |- ∀p q n m. (n * SUC q ** p = m * SUC q ** p) ⇔ (n = m)
   |- ∀m n p. m * n ≤ m * p ⇔ (m = 0) ∨ n ≤ p
   |- ∀m n p. m * n ≤ p * n ⇔ (n = 0) ∨ m ≤ p
   |- ∀m n p. m * n < m * p ⇔ 0 < m ∧ n < p
   |- ∀m n p. m * n < p * n ⇔ 0 < n ∧ m < p
   |- (m < m * n ⇔ 0 < m ∧ 1 < n) ∧ (m < n * m ⇔ 0 < m ∧ 1 < n)
   |- (m * n < m ⇔ 0 < m ∧ (n = 0)) ∧ (m * n < n ⇔ 0 < n ∧ (m = 0))
   |- (m ≤ m * n ⇔ (m = 0) ∨ 0 < n) ∧ (m ≤ n * m ⇔ (m = 0) ∨ 0 < n)
   |- (m * n ≤ m ⇔ (m = 0) ∨ n ≤ 1) ∧ (m * n ≤ n ⇔ (n = 0) ∨ m ≤ 1)
   |- ∀m n. SUC n ** m ≠ 0
   |- ∀n m. SUC (n + n) ≠ m + m
   |- ∀m n. ¬(SUC (m + n) ≤ m)
   |- ∀n. ¬(SUC n ≤ 0)
   |- ∀n. ¬(n < 0)
   |- ∀n. ¬(n < n)
   |- ¬(x > x)
   |- ∀n. (MIN n 0 = 0) ∧ (MIN 0 n = 0)
   |- ∀n. (MAX n 0 = n) ∧ (MAX 0 n = n)
   |- ∀n. MIN n n = n
   |- ∀n. MAX n n = n
   |- ∀n m p.
        (MIN m n ≤ p ⇔ m ≤ p ∨ n ≤ p) ∧ (p ≤ MIN m n ⇔ p ≤ m ∧ p ≤ n)
   |- ∀n m p.
        (p ≤ MAX m n ⇔ p ≤ m ∨ p ≤ n) ∧ (MAX m n ≤ p ⇔ m ≤ p ∧ n ≤ p)
   |- ∀n m p.
        (MIN m n < p ⇔ m < p ∨ n < p) ∧ (p < MIN m n ⇔ p < m ∧ p < n)
   |- ∀n m p.
        (p < MAX m n ⇔ p < m ∨ p < n) ∧ (MAX m n < p ⇔ m < p ∧ n < p)
   |- ∀m n. (MIN m n = MAX m n) ⇔ (m = n)
   |- ∀m n. MIN m n < MAX m n ⇔ m ≠ n
   |- ∀x y. 0 < y ⇒ ((x MOD y = x) ⇔ x < y)
   |- ∀n. 0 < n ⇒ (n DIV n = 1) ∧ (n MOD n = 0)
   |- ∀q. q DIV 1 = q
   |- ∀k. k MOD 1 = 0
   |- ∀n k. k < n ⇒ (k MOD n = k)
   |- ∀n. 0 < n ⇒ (0 MOD n = 0)
   |- ∀n. 0 < n ⇒ ∀k. k MOD n MOD n = k MOD n
   |- ((NUMERAL (BIT1 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT1 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT1 x) = 0)) ∧
      ((NUMERAL (BIT2 x) * y = NUMERAL z) ⇔
       (y = NUMERAL z DIV NUMERAL (BIT2 x)) ∧
       (NUMERAL z MOD NUMERAL (BIT2 x) = 0))
   |- ∀m n. 0 < n ⇒ m MOD n < n
   |- ∀n d. 0 < n ∧ 1 < d ⇒ n DIV d < n

Simplification set: patternMatchesSimp
Decision procedures:
   PMATCH_SIMP_REDUCER
:
   simpset
val stdprinters = SOME (fn, fn):
   ((term -> string) * (hol_type -> string)) option
val store_attribute = fn: {attribute: string, thm_name: string} -> unit
val store_definition = fn: string * thm -> thm
val store_thm = fn: string * term * tactic -> thm
val str_all = fn: (char -> bool) -> string -> bool
val strcat = fn: string -> string -> string
val string_to_int = fn: string -> int
val strip_abs = fn: term -> term list * term
val strip_assume_tac = fn: thm_tactic
val strip_binder = fn: term option -> term -> term list * term
val strip_binop = fn: ('a -> ('a * 'a) option) -> 'a -> 'a list
val strip_comb = fn: term -> term * term list
val strip_conj = fn: term -> term list
val strip_disj = fn: term -> term list
val strip_exists = fn: term -> term list * term
val strip_forall = fn: term -> term list * term
val strip_fun = fn: hol_type -> hol_type list * hol_type
val strip_gen_left = fn: ('a -> 'b * 'a) -> 'a -> 'b list * 'a
val strip_gen_left_opt = fn: ('a -> ('b * 'a) option) -> 'a -> 'b list * 'a
val strip_gen_right = fn: ('a -> 'a * 'b) -> 'a -> 'a * 'b list
val strip_gen_right_opt = fn: ('a -> ('a * 'b) option) -> 'a -> 'a * 'b list
val strip_imp = fn: term -> term list * term
val strip_imp_only = fn: term -> term list * term
val strip_neg = fn: term -> term * int
val strip_res_exists = fn: term -> (term * term) list * term
val strip_res_forall = fn: term -> (term * term) list * term
val strip_tac = fn: tactic
val subgoal = fn: term quotation -> tactic
type ('a, 'b) subst = ('a, 'b) Lib.subst
val subst = fn: (term, term) Term.subst -> term -> term
val subst_assoc = fn: ('a -> bool) -> ('a, 'b) Lib.subst -> 'b option
val subst_occs = fn:
   int list list -> {redex: term, residue: term} list -> term -> term
val subtract = fn: ''a list -> ''a list -> ''a list
val suff_tac = fn: term -> tactic
val suffices_by = fn: term quotation * tactic -> tactic
val swap = fn: 'a * 'b -> 'b * 'a
val syntax_fns = fn:
   {dest: term -> exn -> term -> 'a, make: term -> 'b -> term, n: int} ->
     string -> string -> term * ('b -> term) * (term -> 'a) * (term -> bool)
val syntax_fns1 = fn:
   string ->
     string -> term * (term -> term) * (term -> term) * (term -> bool)
val syntax_fns2 = fn:
   string ->
     string ->
       term * (term * term -> term) * (term -> term * term) * (term -> bool)
val syntax_fns3 = fn:
   string ->
     string ->
       term * (term * term * term -> term) * (term -> term * term * term) *
       (term -> bool)
val syntax_fns4 = fn:
   string ->
     string ->
       term * (term * term * term * term -> term) *
       (term -> term * term * term * term) * (term -> bool)
val tDefine = fn: string -> term quotation -> tactic -> thm
type tactic = goal -> goal list * validation
type tag
val tag = fn: thm -> tag
val temp_TeX_notation = fn: {TeX: string * int, hol: string} -> unit
val temp_add_absyn_postprocessor = fn:
   string * term_grammar.absyn_postprocessor -> unit
val temp_add_bare_numeral_form = fn: char * string option -> unit
val temp_add_infix = fn: string * int * associativity -> unit
val temp_add_infix_type = fn:
   {Assoc: associativity, Name: string, ParseName: string option, Prec: int}
     -> unit
val temp_add_listform = fn:
   {block_info: block_info,
     cons: string,
     leftdelim: pp_element list,
     nilstr: string, rightdelim: pp_element list, separator: pp_element list}
     -> unit
val temp_add_numeral_form = fn: char * string option -> unit
val temp_add_preterm_processor = fn:
   string * int -> term_grammar.preterm_processor -> unit
val temp_add_qtype = fn: {Name: string, Thy: string} -> unit
val temp_add_record_field = fn: string * term -> unit
val temp_add_record_fupdate = fn: string * term -> unit
val temp_add_rule = fn:
   {block_style: PhraseBlockStyle * block_info,
     fixity: fixity,
     paren_style: ParenStyle, pp_elements: pp_element list, term_name: string}
     -> unit
val temp_add_type = fn: string -> unit
val temp_add_user_printer = fn:
   string * term * term_grammar.userprinter -> unit
val temp_associate_restriction = fn: string * string -> unit
val temp_binding = fn: string -> string
val temp_bring_to_front_overload = fn:
   string -> {Name: string, Thy: string} -> unit
val temp_clear_overloads_on = fn: string -> unit
val temp_disable_tyabbrev_printing = fn: string -> unit
val temp_gen_remove_ovl_mapping = fn: string -> term -> unit
val temp_give_num_priority = fn: char -> unit
val temp_inferior_overload_on = fn: string * term -> unit
val temp_loose_equality = fn: unit -> unit
val temp_overload_on = fn: string * term -> unit
val temp_overload_on_by_nametype = fn:
   string -> {Name: string, Thy: string} -> unit
val temp_prefer_form_with_tok = fn: {term_name: string, tok: string} -> unit
val temp_remove_absyn_postprocessor = fn:
   string -> term_grammar.absyn_postprocessor option
val temp_remove_numeral_form = fn: char -> unit
val temp_remove_ovl_mapping = fn:
   string -> {Name: string, Thy: string} -> unit
val temp_remove_preterm_processor = fn:
   string * int -> term_grammar.preterm_processor option
val temp_remove_rules_for_term = fn: string -> unit
val temp_remove_termtok = fn: {term_name: string, tok: string} -> unit
val temp_remove_type_abbrev = fn: string -> unit
val temp_remove_user_printer = fn:
   string -> (term * term_grammar.userprinter) option
val temp_send_to_back_overload = fn:
   string -> {Name: string, Thy: string} -> unit
val temp_set_associativity = fn: int * associativity -> unit
val temp_set_fixity = fn: string -> fixity -> unit
val temp_set_grammars = fn:
   type_grammar.grammar * term_grammar.grammar -> unit
val temp_set_mapped_fixity = fn:
   {fixity: fixity, term_name: string, tok: string} -> unit
val temp_thytype_abbrev = fn: KernelSig.kernelname * hol_type -> unit
val temp_tight_equality = fn: unit -> unit
val temp_type_abbrev = fn: string * hol_type -> unit
eqtype term
val term_diff = fn: term -> term -> (pel list * term * term) list
val term_eq = fn: term -> term -> bool
val term_grammar = fn: unit -> term_grammar.grammar
val term_pp_prefix = ref "\226\128\156": string ref
val term_pp_suffix = ref "\226\128\157": string ref
val term_pp_with_delimiters = fn:
   (ppstream -> term -> unit) -> ppstream -> term -> unit
val term_size = fn: term -> int
val term_to_string = fn: term -> string
val the_map = fn: unit -> (string, string * int) Binarymap.dict
val the_value = “(:α)”: term
val theorem = fn: string -> thm
val theorems = fn: string -> (string * thm) list
type theory
val theory_data = fn: {settype: string, thy: string} -> (string * thm) list
type thm
val thm_frees = fn: thm -> term list
type thm_tactic = thm -> tactic
type thm_tactical = thm_tactic -> thm_tactic
val thm_to_string = fn: thm -> string
val thms = fn: string -> (string * thm) list
val thy = fn: string -> DB.data list
type thy_addon =
   {sig_ps: (ppstream -> unit) option, struct_ps: (ppstream -> unit) option}
val thy_consts = fn: string -> term list
val thy_types = fn: string -> (string * int) list
val thytype_abbrev = fn: KernelSig.kernelname * hol_type -> unit
val tight_equality = fn: unit -> unit
val time = fn: ('a -> 'b) -> 'a -> 'b
val time_to_string = fn: Time.time -> string
val topsort = fn: ('a -> 'a -> bool) -> 'a list -> 'a list
val total = fn: ('a -> 'b) -> 'a -> 'b option
val trace = fn: string * int -> ('a -> 'b) -> 'a -> 'b
val traces = fn:
   unit ->
     {aliases: string list,
       default: int, max: int, name: string, trace_level: int} list
val triple = fn: 'a -> 'b -> 'c -> 'a * 'b * 'c
val triple_of_list = fn: 'a list -> 'a * 'a * 'a
val try = fn: ('a -> 'b) -> 'a -> 'b
val try_grammar_extension = fn: ('a -> 'b) -> 'a -> 'b
val try_theory_extension = fn: ('a -> 'b) -> 'a -> 'b
val trye = fn: ('a -> 'b) -> 'a -> 'b
val tryfind = fn: ('a -> 'b) -> 'a list -> 'b
val trypluck = fn: ('a -> 'b) -> 'a list -> 'b * 'a list
val trypluck' = fn: ('a -> 'b option) -> 'a list -> 'b option * 'a list
val ty_antiq = fn: hol_type -> term
val ty_sub = fn: (hol_type, hol_type) Lib.subst -> hol_type -> hol_type delta
val type_abbrev = fn: string * hol_type -> unit
val type_constructors = fn: thm -> string -> term list
val type_constructors_with_args = fn: thm -> string -> term list
val type_grammar = fn: unit -> type_grammar.grammar
val type_of = fn: term -> hol_type
val type_pp_prefix = ref "\226\128\156": string ref
val type_pp_suffix = ref "\226\128\157": string ref
val type_pp_with_delimiters = fn:
   (ppstream -> hol_type -> unit) -> ppstream -> hol_type -> unit
val type_rws = fn: hol_type -> thm list
val type_size = fn: hol_type -> int
val type_subst = fn: (hol_type, hol_type) Lib.subst -> hol_type -> hol_type
val type_to_string = fn: hol_type -> string
val type_var_in = fn: hol_type -> hol_type -> bool
val type_vars = fn: hol_type -> hol_type list
val type_vars_in_term = fn: term -> hol_type list
val type_varsl = fn: hol_type list -> hol_type list
val typedTerm = fn: term frag list -> hol_type -> term
val typed_parse_in_context = fn:
   hol_type -> term list -> term frag list -> term
val types = fn: string -> (string * int) list
val unabbrev_all_tac = fn: tactic
val uncurry = fn: ('a -> 'b -> 'c) -> 'a * 'b -> 'c
val union = fn: ''a list -> ''a list -> ''a list
val universal = “$!”: term
val unprefix = fn: string -> string -> string
val unprime = fn: string -> string
val unzip = fn: ('a * 'b) list -> 'a list * 'b list
val update_overload_maps = fn:
   string ->
     {Name: string, Thy: string} list * {Name: string, Thy: string} list ->
       unit
val upto = fn: int -> int -> int list
val uptodate_term = fn: term -> bool
val uptodate_thm = fn: thm -> bool
val uptodate_type = fn: hol_type -> bool
type validation = thm list -> thm
val var_compare = fn: term * term -> order
val var_occurs = fn: term -> term -> bool
val variant = fn: term list -> term -> term
val variant_of_term = fn:
   term list -> term -> term * {redex: term, residue: term} list
val vector_topsort = fn: int list vector -> int list
datatype ('a, 'b) verdict = FAIL of 'b | PASS of 'a
val verdict = fn: ('a -> 'b) -> ('a -> 'c) -> 'a -> ('b, 'c * exn) verdict
val version = 11: int
val via = fn: term * tactic -> tactic
val with_exn = fn: ('a -> 'b) -> 'a -> exn -> 'b
val with_flag = fn: 'a ref * 'a -> ('b -> 'c) -> 'b -> 'c
val words2 = fn: string -> string -> string list
val wrap_exn = fn: string -> string -> exn -> exn
val wrap_exn_loc = fn: string -> string -> locn.locn -> exn -> exn
val write_raw = fn: (term -> int) -> term -> string
val xDefine = fn: string -> term quotation -> thm
val xHol_coreln = fn: string -> term quotation -> thm * thm * thm
val xHol_reln = fn: string -> term quotation -> thm * thm * thm
val zDefine = fn: term quotation -> thm
val zip = fn: 'a list -> 'b list -> ('a * 'b) list
val |-> = fn: 'a * 'b -> {redex: 'a, residue: 'b}
val |> = fn: 'a * ('a -> 'b) -> 'b
> val ALL_DISTINCT =
   |- (ALL_DISTINCT [] ⇔ T) ∧
   ∀h t. ALL_DISTINCT (h::t) ⇔ ¬MEM h t ∧ ALL_DISTINCT t:
   thm
val ALL_DISTINCT_APPEND =
   |- ∀l1 l2.
     ALL_DISTINCT (l1 ++ l2) ⇔
     ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀e. MEM e l1 ⇒ ¬MEM e l2:
   thm
val ALL_DISTINCT_CARD_LIST_TO_SET =
   |- ∀ls. ALL_DISTINCT ls ⇒ (CARD (set ls) = LENGTH ls):
   thm
val ALL_DISTINCT_DROP =
   |- ∀ls n. ALL_DISTINCT ls ⇒ ALL_DISTINCT (DROP n ls):
   thm
val ALL_DISTINCT_EL_IMP =
   |- ∀l n1 n2.
     ALL_DISTINCT l ∧ n1 < LENGTH l ∧ n2 < LENGTH l ⇒
     ((EL n1 l = EL n2 l) ⇔ (n1 = n2)):
   thm
val ALL_DISTINCT_FILTER =
   |- ∀l. ALL_DISTINCT l ⇔ ∀x. MEM x l ⇒ (FILTER ($= x) l = [x]):
   thm
val ALL_DISTINCT_FILTER_EL_IMP =
   |- ∀P l n1 n2.
     ALL_DISTINCT (FILTER P l) ∧ n1 < LENGTH l ∧ n2 < LENGTH l ∧
     P (EL n1 l) ∧ (EL n1 l = EL n2 l) ⇒
     (n1 = n2):
   thm
val ALL_DISTINCT_FLAT_REVERSE =
   |- ∀xs. ALL_DISTINCT (FLAT (REVERSE xs)) ⇔ ALL_DISTINCT (FLAT xs):
   thm
val ALL_DISTINCT_GENLIST =
   |- ALL_DISTINCT (GENLIST f n) ⇔
   ∀m1 m2. m1 < n ∧ m2 < n ∧ (f m1 = f m2) ⇒ (m1 = m2):
   thm
val ALL_DISTINCT_MAP =
   |- ∀f ls. ALL_DISTINCT (MAP f ls) ⇒ ALL_DISTINCT ls:
   thm
val ALL_DISTINCT_MAP_INJ =
   |- ∀ls f.
     (∀x y. MEM x ls ∧ MEM y ls ∧ (f x = f y) ⇒ (x = y)) ∧
     ALL_DISTINCT ls ⇒
     ALL_DISTINCT (MAP f ls):
   thm
val ALL_DISTINCT_REVERSE =
   |- ∀l. ALL_DISTINCT (REVERSE l) ⇔ ALL_DISTINCT l:
   thm
val ALL_DISTINCT_SET_TO_LIST =
   |- ∀s. FINITE s ⇒ ALL_DISTINCT (SET_TO_LIST s):
   thm
val ALL_DISTINCT_SING =
   |- ∀x. ALL_DISTINCT [x]:
   thm
val ALL_DISTINCT_SNOC =
   |- ∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l:
   thm
val ALL_DISTINCT_ZIP =
   |- ∀l1 l2.
     ALL_DISTINCT l1 ∧ (LENGTH l1 = LENGTH l2) ⇒
     ALL_DISTINCT (ZIP (l1,l2)):
   thm
val ALL_DISTINCT_ZIP_SWAP =
   |- ∀l1 l2.
     ALL_DISTINCT (ZIP (l1,l2)) ∧ (LENGTH l1 = LENGTH l2) ⇒
     ALL_DISTINCT (ZIP (l2,l1)):
   thm
val APPEND =
   |- (∀l. [] ++ l = l) ∧ ∀l1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2):
   thm
val APPEND_11 =
   |- (∀l1 l2 l3. (l1 ++ l2 = l1 ++ l3) ⇔ (l2 = l3)) ∧
   ∀l1 l2 l3. (l2 ++ l1 = l3 ++ l1) ⇔ (l2 = l3):
   thm
val APPEND_11_LENGTH =
   |- (∀l1 l2 l1' l2'.
      (LENGTH l1 = LENGTH l1') ⇒
      ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2'))) ∧
   ∀l1 l2 l1' l2'.
     (LENGTH l2 = LENGTH l2') ⇒
     ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2')):
   thm
val APPEND_ASSOC =
   |- ∀l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3:
   thm
val APPEND_EQ_APPEND =
   |- (l1 ++ l2 = m1 ++ m2) ⇔
   (∃l. (l1 = m1 ++ l) ∧ (m2 = l ++ l2)) ∨
   ∃l. (m1 = l1 ++ l) ∧ (l2 = l ++ m2):
   thm
val APPEND_EQ_APPEND_MID =
   |- (l1 ++ [e] ++ l2 = m1 ++ m2) ⇔
   (∃l. (m1 = l1 ++ [e] ++ l) ∧ (l2 = l ++ m2)) ∨
   ∃l. (l1 = m1 ++ l) ∧ (m2 = l ++ [e] ++ l2):
   thm
val APPEND_EQ_CONS =
   |- (l1 ++ l2 = h::t) ⇔
   (l1 = []) ∧ (l2 = h::t) ∨ ∃ $lt. (l1 = h:: $lt) ∧ (t = $lt ++ l2):
   thm
val APPEND_EQ_SELF =
   |- (∀l1 l2. (l1 ++ l2 = l1) ⇔ (l2 = [])) ∧
   (∀l1 l2. (l1 ++ l2 = l2) ⇔ (l1 = [])) ∧
   (∀l1 l2. (l1 = l1 ++ l2) ⇔ (l2 = [])) ∧
   ∀l1 l2. (l2 = l1 ++ l2) ⇔ (l1 = []):
   thm
val APPEND_EQ_SING =
   |- (l1 ++ l2 = [e]) ⇔ (l1 = [e]) ∧ (l2 = []) ∨ (l1 = []) ∧ (l2 = [e]):
   thm
val APPEND_FRONT_LAST =
   |- ∀l. l ≠ [] ⇒ (FRONT l ++ [LAST l] = l):
   thm
val APPEND_LENGTH_EQ =
   |- ∀l1 l1'.
     (LENGTH l1 = LENGTH l1') ⇒
     ∀l2 l2'.
       (LENGTH l2 = LENGTH l2') ⇒
       ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2')):
   thm
val APPEND_NIL =
   |- ∀l. l ++ [] = l:
   thm
val APPEND_SNOC =
   |- ∀l1 x l2. l1 ++ SNOC x l2 = SNOC x (l1 ++ l2):
   thm
val APPEND_eq_NIL =
   |- (∀l1 l2. ([] = l1 ++ l2) ⇔ (l1 = []) ∧ (l2 = [])) ∧
   ∀l1 l2. (l1 ++ l2 = []) ⇔ (l1 = []) ∧ (l2 = []):
   thm
val BIGUNION_IMAGE_set_SUBSET =
   |- BIGUNION (IMAGE f (set ls)) ⊆ s ⇔ ∀x. MEM x ls ⇒ f x ⊆ s:
   thm
val CARD_LIST_TO_SET =
   |- CARD (set ls) ≤ LENGTH ls:
   thm
val CARD_LIST_TO_SET_ALL_DISTINCT =
   |- ∀ls. (CARD (set ls) = LENGTH ls) ⇒ ALL_DISTINCT ls:
   thm
val CFG2Interpret_def =
   |- CFG2Interpret (M,Oi,Os)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream) ⇔
   (M,Oi,Os) satList MAP certInterpret certs ∧
   (M,Oi,Os) sat inputInterpret x ∧ (M,Oi,Os) sat stateInterpret state:
   thm
val CFG2Interpret_ind =
   |- ∀P.
     (∀M Oi Os inputInterpret certInterpret inputTest certs
         stateInterpret x ins state outStream.
        P (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)) ∧
     (∀v19 v12 v13 v14 v15 v16 v17 v18.
        P v19 (CFG2 v12 v13 v14 v15 v16 [] v17 v18)) ⇒
     ∀v v1 v2 v3. P (v,v1,v2) v3:
   thm
val CFGInterpret_def =
   |- CFGInterpret (M,Oi,Os)
     (CFG inputTest stateInterp context (x::ins) state outStream) ⇔
   (M,Oi,Os) satList context ∧ (M,Oi,Os) sat x ∧
   (M,Oi,Os) sat stateInterp state:
   thm
val CFGInterpret_ind =
   |- ∀P.
     (∀M Oi Os inputTest stateInterp context x ins state outStream.
        P (M,Oi,Os)
          (CFG inputTest stateInterp context (x::ins) state
             outStream)) ∧
     (∀v15 v10 v11 v12 v13 v14. P v15 (CFG v10 v11 v12 [] v13 v14)) ⇒
     ∀v v1 v2 v3. P (v,v1,v2) v3:
   thm
val CONS =
   |- ∀l. ¬NULL l ⇒ (HD l::TL l = l):
   thm
val CONS_11 =
   |- ∀a0 a1 a0' a1'. (a0::a1 = a0'::a1') ⇔ (a0 = a0') ∧ (a1 = a1'):
   thm
val CONS_ACYCLIC =
   |- ∀l x. l ≠ x::l ∧ x::l ≠ l:
   thm
val DISJOINT_GENLIST_PLUS =
   |- DISJOINT x (set (GENLIST ($+ n) (a + b))) ⇒
   DISJOINT x (set (GENLIST ($+ n) a)) ∧
   DISJOINT x (set (GENLIST ($+ (n + a)) b)):
   thm
val DROP_0 =
   |- DROP 0 l = l:
   thm
val DROP_LENGTH_TOO_LONG =
   |- ∀l n. LENGTH l ≤ n ⇒ (DROP n l = []):
   thm
val DROP_NIL =
   |- ∀ls n. (DROP n ls = []) ⇔ n ≥ LENGTH ls:
   thm
val DROP_compute =
   |- (∀l. DROP 0 l = l) ∧ (∀n. DROP (NUMERAL (BIT1 n)) [] = []) ∧
   (∀n. DROP (NUMERAL (BIT2 n)) [] = []) ∧
   (∀n h t.
      DROP (NUMERAL (BIT1 n)) (h::t) = DROP (NUMERAL (BIT1 n) − 1) t) ∧
   ∀n h t. DROP (NUMERAL (BIT2 n)) (h::t) = DROP (NUMERAL (BIT1 n)) t:
   thm
val DROP_cons =
   |- 0 < n ⇒ (DROP n (x::xs) = DROP (n − 1) xs):
   thm
val DROP_def =
   |- (∀n. DROP n [] = []) ∧
   ∀n x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n − 1) xs:
   thm
val DROP_nil =
   |- ∀n. DROP n [] = []:
   thm
val DROP_splitAtPki =
   |- DROP n l = splitAtPki (K ∘ $= n) (K I) l:
   thm
val EL =
   |- (∀l. EL 0 l = HD l) ∧ ∀l n. EL (SUC n) l = EL n (TL l):
   thm
val EL_ALL_DISTINCT_EL_EQ =
   |- ∀l.
     ALL_DISTINCT l ⇔
     ∀n1 n2.
       n1 < LENGTH l ∧ n2 < LENGTH l ⇒ ((EL n1 l = EL n2 l) ⇔ (n1 = n2)):
   thm
val EL_APPEND_EQN =
   |- ∀l1 l2 n.
     EL n (l1 ++ l2) =
     if n < LENGTH l1 then EL n l1 else EL (n − LENGTH l1) l2:
   thm
val EL_GENLIST =
   |- ∀f n x. x < n ⇒ (EL x (GENLIST f n) = f x):
   thm
val EL_LENGTH_SNOC =
   |- ∀l x. EL (LENGTH l) (SNOC x l) = x:
   thm
val EL_LENGTH_dropWhile_REVERSE =
   |- ∀P ls k.
     LENGTH (dropWhile P (REVERSE ls)) ≤ k ∧ k < LENGTH ls ⇒ P (EL k ls):
   thm
val EL_LUPDATE =
   |- ∀ys x i k.
     EL i (LUPDATE x k ys) =
     if (i = k) ∧ k < LENGTH ys then x else EL i ys:
   thm
val EL_MAP =
   |- ∀n l. n < LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l):
   thm
val EL_REVERSE =
   |- ∀n l. n < LENGTH l ⇒ (EL n (REVERSE l) = EL (PRE (LENGTH l − n)) l):
   thm
val EL_SNOC =
   |- ∀n l. n < LENGTH l ⇒ ∀x. EL n (SNOC x l) = EL n l:
   thm
val EL_ZIP =
   |- ∀l1 l2 n.
     (LENGTH l1 = LENGTH l2) ∧ n < LENGTH l1 ⇒
     (EL n (ZIP (l1,l2)) = (EL n l1,EL n l2)):
   thm
val EL_compute =
   |- ∀n. EL n l = if n = 0 then HD l else EL (PRE n) (TL l):
   thm
val EL_restricted =
   |- (EL 0 = HD) ∧ (EL (SUC n) (l::ls) = EL n ls):
   thm
val EL_simp =
   |- (EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l)) ∧
   (EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l)):
   thm
val EL_simp_restricted =
   |- (EL (NUMERAL (BIT1 n)) (l::ls) = EL (PRE (NUMERAL (BIT1 n))) ls) ∧
   (EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls):
   thm
val EQ_LIST =
   |- ∀h1 h2. (h1 = h2) ⇒ ∀l1 l2. (l1 = l2) ⇒ (h1::l1 = h2::l2):
   thm
val EVERY2_EVERY =
   |- ∀l1 l2 f.
     LIST_REL f l1 l2 ⇔
     (LENGTH l1 = LENGTH l2) ∧ EVERY (UNCURRY f) (ZIP (l1,l2)):
   thm
val EVERY2_LENGTH =
   |- ∀P l1 l2. LIST_REL P l1 l2 ⇒ (LENGTH l1 = LENGTH l2):
   thm
val EVERY2_LUPDATE_same =
   |- ∀P l1 l2 v1 v2 n.
     P v1 v2 ∧ LIST_REL P l1 l2 ⇒
     LIST_REL P (LUPDATE v1 n l1) (LUPDATE v2 n l2):
   thm
val EVERY2_MAP =
   |- (LIST_REL P (MAP f l1) l2 ⇔ LIST_REL (λx y. P (f x) y) l1 l2) ∧
   (LIST_REL Q l1 (MAP g l2) ⇔ LIST_REL (λx y. Q x (g y)) l1 l2):
   thm
val EVERY2_MEM_MONO =
   |- ∀P Q l1 l2.
     (∀x. MEM x (ZIP (l1,l2)) ∧ UNCURRY P x ⇒ UNCURRY Q x) ∧
     LIST_REL P l1 l2 ⇒
     LIST_REL Q l1 l2:
   thm
val EVERY2_REVERSE =
   |- ∀R l1 l2. LIST_REL R l1 l2 ⇒ LIST_REL R (REVERSE l1) (REVERSE l2):
   thm
val EVERY2_THM =
   |- (∀P ys. LIST_REL P [] ys ⇔ (ys = [])) ∧
   (∀P yys x xs.
      LIST_REL P (x::xs) yys ⇔
      ∃y ys. (yys = y::ys) ∧ P x y ∧ LIST_REL P xs ys) ∧
   (∀P xs. LIST_REL P xs [] ⇔ (xs = [])) ∧
   ∀P xxs y ys.
     LIST_REL P xxs (y::ys) ⇔
     ∃x xs. (xxs = x::xs) ∧ P x y ∧ LIST_REL P xs ys:
   thm
val EVERY2_cong =
   |- ∀l1 l1' l2 l2' P P'.
     (l1 = l1') ∧ (l2 = l2') ∧
     (∀x y. MEM x l1' ∧ MEM y l2' ⇒ (P x y ⇔ P' x y)) ⇒
     (LIST_REL P l1 l2 ⇔ LIST_REL P' l1' l2'):
   thm
val EVERY2_mono =
   |- (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2:
   thm
val EVERY2_refl =
   |- (∀x. MEM x ls ⇒ R x x) ⇒ LIST_REL R ls ls:
   thm
val EVERY2_sym =
   |- (∀x y. R1 x y ⇒ R2 y x) ⇒ ∀x y. LIST_REL R1 x y ⇒ LIST_REL R2 y x:
   thm
val EVERY2_trans =
   |- (∀x y z. R x y ∧ R y z ⇒ R x z) ⇒
   ∀x y z. LIST_REL R x y ∧ LIST_REL R y z ⇒ LIST_REL R x z:
   thm
val EVERY_APPEND =
   |- ∀P l1 l2. EVERY P (l1 ++ l2) ⇔ EVERY P l1 ∧ EVERY P l2:
   thm
val EVERY_CONG =
   |- ∀l1 l2 P P'.
     (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒
     (EVERY P l1 ⇔ EVERY P' l2):
   thm
val EVERY_CONJ =
   |- ∀P Q l. EVERY (λx. P x ∧ Q x) l ⇔ EVERY P l ∧ EVERY Q l:
   thm
val EVERY_DEF =
   |- (∀P. EVERY P [] ⇔ T) ∧ ∀P h t. EVERY P (h::t) ⇔ P h ∧ EVERY P t:
   thm
val EVERY_EL =
   |- ∀l P. EVERY P l ⇔ ∀n. n < LENGTH l ⇒ P (EL n l):
   thm
val EVERY_FILTER =
   |- ∀P1 P2 l. EVERY P1 (FILTER P2 l) ⇔ EVERY (λx. P2 x ⇒ P1 x) l:
   thm
val EVERY_FILTER_IMP =
   |- ∀P1 P2 l. EVERY P1 l ⇒ EVERY P1 (FILTER P2 l):
   thm
val EVERY_GENLIST =
   |- ∀n. EVERY P (GENLIST f n) ⇔ ∀i. i < n ⇒ P (f i):
   thm
val EVERY_MAP =
   |- ∀P f l. EVERY P (MAP f l) ⇔ EVERY (λx. P (f x)) l:
   thm
val EVERY_MEM =
   |- ∀P l. EVERY P l ⇔ ∀e. MEM e l ⇒ P e:
   thm
val EVERY_MEM_MONO =
   |- ∀P Q l. (∀x. MEM x l ∧ P x ⇒ Q x) ∧ EVERY P l ⇒ EVERY Q l:
   thm
val EVERY_MONOTONIC =
   |- ∀P Q. (∀x. P x ⇒ Q x) ⇒ ∀l. EVERY P l ⇒ EVERY Q l:
   thm
val EVERY_NOT_EXISTS =
   |- ∀P l. EVERY P l ⇔ ¬EXISTS (λx. ¬P x) l:
   thm
val EVERY_SIMP =
   |- ∀c l. EVERY (λx. c) l ⇔ (l = []) ∨ c:
   thm
val EVERY_SNOC =
   |- ∀P x l. EVERY P (SNOC x l) ⇔ EVERY P l ∧ P x:
   thm
val EVERYi_def =
   |- (∀P. EVERYi P [] ⇔ T) ∧
   ∀P h t. EVERYi P (h::t) ⇔ P 0 h ∧ EVERYi (P ∘ SUC) t:
   thm
val EXISTS_APPEND =
   |- ∀P l1 l2. EXISTS P (l1 ++ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2:
   thm
val EXISTS_CONG =
   |- ∀l1 l2 P P'.
     (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒
     (EXISTS P l1 ⇔ EXISTS P' l2):
   thm
val EXISTS_DEF =
   |- (∀P. EXISTS P [] ⇔ F) ∧ ∀P h t. EXISTS P (h::t) ⇔ P h ∨ EXISTS P t:
   thm
val EXISTS_GENLIST =
   |- ∀n. EXISTS P (GENLIST f n) ⇔ ∃i. i < n ∧ P (f i):
   thm
val EXISTS_LIST =
   |- (∃l. P l) ⇔ P [] ∨ ∃h t. P (h::t):
   thm
val EXISTS_LIST_EQ_MAP =
   |- ∀ls f. EVERY (λx. ∃y. x = f y) ls ⇒ ∃l. ls = MAP f l:
   thm
val EXISTS_MAP =
   |- ∀P f l. EXISTS P (MAP f l) ⇔ EXISTS (λx. P (f x)) l:
   thm
val EXISTS_MEM =
   |- ∀P l. EXISTS P l ⇔ ∃e. MEM e l ∧ P e:
   thm
val EXISTS_NOT_EVERY =
   |- ∀P l. EXISTS P l ⇔ ¬EVERY (λx. ¬P x) l:
   thm
val EXISTS_SIMP =
   |- ∀c l. EXISTS (λx. c) l ⇔ l ≠ [] ∧ c:
   thm
val EXISTS_SNOC =
   |- ∀P x l. EXISTS P (SNOC x l) ⇔ P x ∨ EXISTS P l:
   thm
val FILTER =
   |- (∀P. FILTER P [] = []) ∧
   ∀P h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t:
   thm
val FILTER_ALL_DISTINCT =
   |- ∀P l. ALL_DISTINCT l ⇒ ALL_DISTINCT (FILTER P l):
   thm
val FILTER_APPEND_DISTRIB =
   |- ∀P L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M:
   thm
val FILTER_COND_REWRITE =
   |- (FILTER P [] = []) ∧ (∀h. P h ⇒ (FILTER P (h::l) = h::FILTER P l)) ∧
   ∀h. ¬P h ⇒ (FILTER P (h::l) = FILTER P l):
   thm
val FILTER_EQ_APPEND =
   |- ∀P l l1 l2.
     (FILTER P l = l1 ++ l2) ⇔
     ∃l3 l4. (l = l3 ++ l4) ∧ (FILTER P l3 = l1) ∧ (FILTER P l4 = l2):
   thm
val FILTER_EQ_CONS =
   |- ∀P l h lr.
     (FILTER P l = h::lr) ⇔
     ∃l1 l2.
       (l = l1 ++ [h] ++ l2) ∧ (FILTER P l1 = []) ∧ (FILTER P l2 = lr) ∧
       P h:
   thm
val FILTER_EQ_ID =
   |- ∀P l. (FILTER P l = l) ⇔ EVERY P l:
   thm
val FILTER_EQ_NIL =
   |- ∀P l. (FILTER P l = []) ⇔ EVERY (λx. ¬P x) l:
   thm
val FILTER_NEQ_ID =
   |- ∀P l. FILTER P l ≠ l ⇔ ∃x. MEM x l ∧ ¬P x:
   thm
val FILTER_NEQ_NIL =
   |- ∀P l. FILTER P l ≠ [] ⇔ ∃x. MEM x l ∧ P x:
   thm
val FILTER_REVERSE =
   |- ∀l P. FILTER P (REVERSE l) = REVERSE (FILTER P l):
   thm
val FIND_def =
   |- ∀P. FIND P = OPTION_MAP SND ∘ INDEX_FIND 0 P:
   thm
val FINITE_LIST_TO_SET =
   |- ∀l. FINITE (set l):
   thm
val FLAT =
   |- (FLAT [] = []) ∧ ∀h t. FLAT (h::t) = h ++ FLAT t:
   thm
val FLAT_APPEND =
   |- ∀l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2:
   thm
val FLAT_EQ_NIL =
   |- ∀ls. (FLAT ls = []) ⇔ EVERY ($= []) ls:
   thm
val FLAT_compute =
   |- (FLAT [] = []) ∧ (FLAT ([]::t) = FLAT t) ∧
   (FLAT ((h::t1)::t2) = h::FLAT (t1::t2)):
   thm
val FOLDL =
   |- (∀f e. FOLDL f e [] = e) ∧
   ∀f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l:
   thm
val FOLDL2_FOLDL =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ∀f a. FOLDL2 f a l1 l2 = FOLDL (λa. UNCURRY (f a)) a (ZIP (l1,l2)):
   thm
val FOLDL2_cong =
   |- ∀l1 l1' l2 l2' a a' f f'.
     (l1 = l1') ∧ (l2 = l2') ∧ (a = a') ∧
     (∀z b c. MEM b l1' ∧ MEM c l2' ⇒ (f z b c = f' z b c)) ⇒
     (FOLDL2 f a l1 l2 = FOLDL2 f' a' l1' l2'):
   thm
val FOLDL2_def =
   |- (∀f cs c bs b a.
      FOLDL2 f a (b::bs) (c::cs) = FOLDL2 f (f a b c) bs cs) ∧
   (∀f cs a. FOLDL2 f a [] cs = a) ∧
   ∀v7 v6 f a. FOLDL2 f a (v6::v7) [] = a:
   thm
val FOLDL2_ind =
   |- ∀P.
     (∀f a b bs c cs. P f (f a b c) bs cs ⇒ P f a (b::bs) (c::cs)) ∧
     (∀f a cs. P f a [] cs) ∧ (∀f a v6 v7. P f a (v6::v7) []) ⇒
     ∀v v1 v2 v3. P v v1 v2 v3:
   thm
val FOLDL_CONG =
   |- ∀l l' b b' f f'.
     (l = l') ∧ (b = b') ∧ (∀x a. MEM x l' ⇒ (f a x = f' a x)) ⇒
     (FOLDL f b l = FOLDL f' b' l'):
   thm
val FOLDL_EQ_FOLDR =
   |- ∀f l e. ASSOC f ∧ COMM f ⇒ (FOLDL f e l = FOLDR f e l):
   thm
val FOLDL_SNOC =
   |- ∀f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x:
   thm
val FOLDL_UNION_BIGUNION =
   |- ∀f ls s. FOLDL (λs x. s ∪ f x) s ls = s ∪ BIGUNION (IMAGE f (set ls)):
   thm
val FOLDL_UNION_BIGUNION_paired =
   |- ∀f ls s.
     FOLDL (λs (x,y). s ∪ f x y) s ls =
     s ∪ BIGUNION (IMAGE (UNCURRY f) (set ls)):
   thm
val FOLDL_ZIP_SAME =
   |- ∀ls f e. FOLDL f e (ZIP (ls,ls)) = FOLDL (λx y. f x (y,y)) e ls:
   thm
val FOLDR =
   |- (∀f e. FOLDR f e [] = e) ∧
   ∀f e x l. FOLDR f e (x::l) = f x (FOLDR f e l):
   thm
val FOLDR_CONG =
   |- ∀l l' b b' f f'.
     (l = l') ∧ (b = b') ∧ (∀x a. MEM x l' ⇒ (f x a = f' x a)) ⇒
     (FOLDR f b l = FOLDR f' b' l'):
   thm
val FOLDR_CONS =
   |- ∀f ls a. FOLDR (λx y. f x::y) a ls = MAP f ls ++ a:
   thm
val FORALL_LIST =
   |- (∀l. P l) ⇔ P [] ∧ ∀h t. P (h::t):
   thm
val FRONT_CONS =
   |- (∀x. FRONT [x] = []) ∧ ∀x y z. FRONT (x::y::z) = x::FRONT (y::z):
   thm
val FRONT_CONS_EQ_NIL =
   |- (∀x xs. (FRONT (x::xs) = []) ⇔ (xs = [])) ∧
   (∀x xs. ([] = FRONT (x::xs)) ⇔ (xs = [])) ∧
   ∀x xs. NULL (FRONT (x::xs)) ⇔ NULL xs:
   thm
val FRONT_DEF =
   |- ∀h t. FRONT (h::t) = if t = [] then [] else h::FRONT t:
   thm
val FRONT_SNOC =
   |- ∀x l. FRONT (SNOC x l) = l:
   thm
val GENLIST =
   |- (∀f. GENLIST f 0 = []) ∧
   ∀f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n):
   thm
val GENLIST_APPEND =
   |- ∀f a b. GENLIST f (a + b) = GENLIST f b ++ GENLIST (λt. f (t + b)) a:
   thm
val GENLIST_AUX =
   |- (∀f l. GENLIST_AUX f 0 l = l) ∧
   ∀f n l. GENLIST_AUX f (SUC n) l = GENLIST_AUX f n (f n::l):
   thm
val GENLIST_AUX_compute =
   |- (∀f l. GENLIST_AUX f 0 l = l) ∧
   (∀f n l.
      GENLIST_AUX f (NUMERAL (BIT1 n)) l =
      GENLIST_AUX f (NUMERAL (BIT1 n) − 1)
        (f (NUMERAL (BIT1 n) − 1)::l)) ∧
   ∀f n l.
     GENLIST_AUX f (NUMERAL (BIT2 n)) l =
     GENLIST_AUX f (NUMERAL (BIT1 n)) (f (NUMERAL (BIT1 n))::l):
   thm
val GENLIST_CONS =
   |- GENLIST f (SUC n) = f 0::GENLIST (f ∘ SUC) n:
   thm
val GENLIST_EL =
   |- ∀ls f n.
     (n = LENGTH ls) ∧ (∀i. i < n ⇒ (f i = EL i ls)) ⇒
     (GENLIST f n = ls):
   thm
val GENLIST_EL_MAP =
   |- ∀f ls. GENLIST (λn. f (EL n ls)) (LENGTH ls) = MAP f ls:
   thm
val GENLIST_FUN_EQ =
   |- ∀n f g. (GENLIST f n = GENLIST g n) ⇔ ∀x. x < n ⇒ (f x = g x):
   thm
val GENLIST_GENLIST_AUX =
   |- ∀n. GENLIST f n = GENLIST_AUX f n []:
   thm
val GENLIST_NUMERALS =
   |- (GENLIST f 0 = []) ∧
   (GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []):
   thm
val GENLIST_PLUS_APPEND =
   |- GENLIST ($+ a) n1 ++ GENLIST ($+ (n1 + a)) n2 =
   GENLIST ($+ a) (n1 + n2):
   thm
val HD =
   |- ∀h t. HD (h::t) = h:
   thm
val HD_GENLIST =
   |- HD (GENLIST f (SUC n)) = f 0:
   thm
val HD_GENLIST_COR =
   |- ∀n f. 0 < n ⇒ (HD (GENLIST f n) = f 0):
   thm
val HD_REVERSE =
   |- ∀x. x ≠ [] ⇒ (HD (REVERSE x) = LAST x):
   thm
val HD_dropWhile =
   |- ∀P ls. EXISTS ($~ ∘ P) ls ⇒ ¬P (HD (dropWhile P ls)):
   thm
val IMAGE_EL_count_LENGTH =
   |- ∀f ls. IMAGE (λn. f (EL n ls)) (count (LENGTH ls)) = IMAGE f (set ls):
   thm
val IMP_EVERY_LUPDATE =
   |- ∀xs h i. P h ∧ EVERY P xs ⇒ EVERY P (LUPDATE h i xs):
   thm
val INDEX_FIND_def =
   |- (∀i P. INDEX_FIND i P [] = NONE) ∧
   ∀i P h t.
     INDEX_FIND i P (h::t) =
     if P h then SOME (i,h) else INDEX_FIND (SUC i) P t:
   thm
val INDEX_OF_def =
   |- ∀x. INDEX_OF x = OPTION_MAP FST ∘ INDEX_FIND 0 ($= x):
   thm
val INFINITE_LIST_UNIV =
   |- INFINITE 𝕌(:α list):
   thm
val INJ_MAP_EQ =
   |- ∀f l1 l2.
     INJ f (set l1 ∪ set l2) 𝕌(:β) ∧ (MAP f l1 = MAP f l2) ⇒ (l1 = l2):
   thm
val INJ_MAP_EQ_IFF =
   |- ∀f l1 l2.
     INJ f (set l1 ∪ set l2) 𝕌(:β) ⇒ ((MAP f l1 = MAP f l2) ⇔ (l1 = l2)):
   thm
val ITSET_eq_FOLDL_SET_TO_LIST =
   |- ∀s.
     FINITE s ⇒ ∀f a. ITSET f s a = FOLDL (combin$C f) a (SET_TO_LIST s):
   thm
val LAST_APPEND_CONS =
   |- ∀h l1 l2. LAST (l1 ++ h::l2) = LAST (h::l2):
   thm
val LAST_CONS =
   |- (∀x. LAST [x] = x) ∧ ∀x y z. LAST (x::y::z) = LAST (y::z):
   thm
val LAST_CONS_cond =
   |- LAST (h::t) = if t = [] then h else LAST t:
   thm
val LAST_DEF =
   |- ∀h t. LAST (h::t) = if t = [] then h else LAST t:
   thm
val LAST_EL =
   |- ∀ls. ls ≠ [] ⇒ (LAST ls = EL (PRE (LENGTH ls)) ls):
   thm
val LAST_MAP =
   |- ∀l f. l ≠ [] ⇒ (LAST (MAP f l) = f (LAST l)):
   thm
val LAST_REVERSE =
   |- ∀ls. ls ≠ [] ⇒ (LAST (REVERSE ls) = HD ls):
   thm
val LAST_SNOC =
   |- ∀x l. LAST (SNOC x l) = x:
   thm
val LAST_compute =
   |- (∀x. LAST [x] = x) ∧ ∀h1 h2 t. LAST (h1::h2::t) = LAST (h2::t):
   thm
val LENGTH =
   |- (LENGTH [] = 0) ∧ ∀h t. LENGTH (h::t) = SUC (LENGTH t):
   thm
val LENGTH_APPEND =
   |- ∀l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2:
   thm
val LENGTH_CONS =
   |- ∀l n. (LENGTH l = SUC n) ⇔ ∃h l'. (LENGTH l' = n) ∧ (l = h::l'):
   thm
val LENGTH_DROP =
   |- ∀n l. LENGTH (DROP n l) = LENGTH l − n:
   thm
val LENGTH_EQ_CONS =
   |- ∀P n.
     (∀l. (LENGTH l = SUC n) ⇒ P l) ⇔
     ∀l. (LENGTH l = n) ⇒ (λl. ∀x. P (x::l)) l:
   thm
val LENGTH_EQ_NIL =
   |- ∀P. (∀l. (LENGTH l = 0) ⇒ P l) ⇔ P []:
   thm
val LENGTH_EQ_NUM =
   |- (∀l. (LENGTH l = 0) ⇔ (l = [])) ∧
   (∀l n. (LENGTH l = SUC n) ⇔ ∃h l'. (LENGTH l' = n) ∧ (l = h::l')) ∧
   ∀l n1 n2.
     (LENGTH l = n1 + n2) ⇔
     ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2):
   thm
val LENGTH_EQ_NUM_compute =
   |- (∀l. (LENGTH l = 0) ⇔ (l = [])) ∧
   (∀l n.
      (LENGTH l = NUMERAL (BIT1 n)) ⇔
      ∃h l'. (LENGTH l' = NUMERAL (BIT1 n) − 1) ∧ (l = h::l')) ∧
   (∀l n.
      (LENGTH l = NUMERAL (BIT2 n)) ⇔
      ∃h l'. (LENGTH l' = NUMERAL (BIT1 n)) ∧ (l = h::l')) ∧
   ∀l n1 n2.
     (LENGTH l = n1 + n2) ⇔
     ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2):
   thm
val LENGTH_EQ_SUM =
   |- ∀l n1 n2.
     (LENGTH l = n1 + n2) ⇔
     ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2):
   thm
val LENGTH_FILTER_LEQ_MONO =
   |- ∀P Q.
     (∀x. P x ⇒ Q x) ⇒ ∀ls. LENGTH (FILTER P ls) ≤ LENGTH (FILTER Q ls):
   thm
val LENGTH_FRONT_CONS =
   |- ∀x xs. LENGTH (FRONT (x::xs)) = LENGTH xs:
   thm
val LENGTH_GENLIST =
   |- ∀f n. LENGTH (GENLIST f n) = n:
   thm
val LENGTH_LEN =
   |- ∀L. LENGTH L = LEN L 0:
   thm
val LENGTH_LUPDATE =
   |- ∀x n ys. LENGTH (LUPDATE x n ys) = LENGTH ys:
   thm
val LENGTH_MAP =
   |- ∀l f. LENGTH (MAP f l) = LENGTH l:
   thm
val LENGTH_NIL =
   |- ∀l. (LENGTH l = 0) ⇔ (l = []):
   thm
val LENGTH_NIL_SYM =
   |- (0 = LENGTH l) ⇔ (l = []):
   thm
val LENGTH_REVERSE =
   |- ∀l. LENGTH (REVERSE l) = LENGTH l:
   thm
val LENGTH_SNOC =
   |- ∀x l. LENGTH (SNOC x l) = SUC (LENGTH l):
   thm
val LENGTH_TAKE =
   |- ∀n l. n ≤ LENGTH l ⇒ (LENGTH (TAKE n l) = n):
   thm
val LENGTH_TAKE_EQ =
   |- LENGTH (TAKE n xs) = if n ≤ LENGTH xs then n else LENGTH xs:
   thm
val LENGTH_TL =
   |- ∀l. 0 < LENGTH l ⇒ (LENGTH (TL l) = LENGTH l − 1):
   thm
val LENGTH_UNZIP =
   |- ∀pl.
     (LENGTH (FST (UNZIP pl)) = LENGTH pl) ∧
     (LENGTH (SND (UNZIP pl)) = LENGTH pl):
   thm
val LENGTH_ZIP =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     (LENGTH (ZIP (l1,l2)) = LENGTH l1) ∧
     (LENGTH (ZIP (l1,l2)) = LENGTH l2):
   thm
val LENGTH_dropWhile_LESS_EQ =
   |- ∀P ls. LENGTH (dropWhile P ls) ≤ LENGTH ls:
   thm
val LENGTH_o_REVERSE =
   |- (LENGTH ∘ REVERSE = LENGTH) ∧ (LENGTH ∘ REVERSE ∘ f = LENGTH ∘ f):
   thm
val LEN_DEF =
   |- (∀n. LEN [] n = n) ∧ ∀h t n. LEN (h::t) n = LEN t (n + 1):
   thm
val LEN_LENGTH_LEM =
   |- ∀L n. LEN L n = LENGTH L + n:
   thm
val LIST_APPLY_def =
   |- ∀fs xs. fs <*> xs = LIST_BIND fs (combin$C MAP xs):
   thm
val LIST_APPLY_o =
   |- [$o] <*> fs <*> gs <*> xs = fs <*> (gs <*> xs):
   thm
val LIST_BIND_APPEND =
   |- LIST_BIND (l1 ++ l2) f = LIST_BIND l1 f ++ LIST_BIND l2 f:
   thm
val LIST_BIND_ID =
   |- (LIST_BIND l (λx. x) = FLAT l) ∧ (LIST_BIND l I = FLAT l):
   thm
val LIST_BIND_LIST_BIND =
   |- LIST_BIND (LIST_BIND l g) f = LIST_BIND l (combin$C LIST_BIND f ∘ g):
   thm
val LIST_BIND_MAP =
   |- LIST_BIND (MAP f l) g = LIST_BIND l (g ∘ f):
   thm
val LIST_BIND_THM =
   |- (LIST_BIND [] f = []) ∧ (LIST_BIND (h::t) f = f h ++ LIST_BIND t f):
   thm
val LIST_BIND_def =
   |- ∀l f. LIST_BIND l f = FLAT (MAP f l):
   thm
val LIST_EQ =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ∧
     (∀x. x < LENGTH l1 ⇒ (EL x l1 = EL x l2)) ⇒
     (l1 = l2):
   thm
val LIST_EQ_MAP_PAIR =
   |- ∀l1 l2.
     (MAP FST l1 = MAP FST l2) ∧ (MAP SND l1 = MAP SND l2) ⇒ (l1 = l2):
   thm
val LIST_EQ_REWRITE =
   |- ∀l1 l2.
     (l1 = l2) ⇔
     (LENGTH l1 = LENGTH l2) ∧ ∀x. x < LENGTH l1 ⇒ (EL x l1 = EL x l2):
   thm
val LIST_IGNORE_BIND_def =
   |- ∀m1 m2. LIST_IGNORE_BIND m1 m2 = LIST_BIND m1 (K m2):
   thm
val LIST_LIFT2_def =
   |- ∀f xs ys. LIST_LIFT2 f xs ys = MAP f xs <*> ys:
   thm
val LIST_NOT_EQ =
   |- ∀l1 l2. l1 ≠ l2 ⇒ ∀h1 h2. h1::l1 ≠ h2::l2:
   thm
val LIST_REL_CONJ =
   |- LIST_REL (λa b. P a b ∧ Q a b) l1 l2 ⇔
   LIST_REL (λa b. P a b) l1 l2 ∧ LIST_REL (λa b. Q a b) l1 l2:
   thm
val LIST_REL_CONS1 =
   |- LIST_REL R (h::t) xs ⇔
   ∃h' t'. (xs = h'::t') ∧ R h h' ∧ LIST_REL R t t':
   thm
val LIST_REL_CONS2 =
   |- LIST_REL R xs (h::t) ⇔
   ∃h' t'. (xs = h'::t') ∧ R h' h ∧ LIST_REL R t' t:
   thm
val LIST_REL_EL_EQN =
   |- ∀R l1 l2.
     LIST_REL R l1 l2 ⇔
     (LENGTH l1 = LENGTH l2) ∧ ∀n. n < LENGTH l1 ⇒ R (EL n l1) (EL n l2):
   thm
val LIST_REL_EVERY_ZIP =
   |- ∀R l1 l2.
     LIST_REL R l1 l2 ⇔
     (LENGTH l1 = LENGTH l2) ∧ EVERY (UNCURRY R) (ZIP (l1,l2)):
   thm
val LIST_REL_LENGTH =
   |- ∀x y. LIST_REL R x y ⇒ (LENGTH x = LENGTH y):
   thm
val LIST_REL_MAP1 =
   |- LIST_REL R (MAP f l1) l2 ⇔ LIST_REL (R ∘ f) l1 l2:
   thm
val LIST_REL_MAP2 =
   |- LIST_REL (λa b. R a b) l1 (MAP f l2) ⇔
   LIST_REL (λa b. R a (f b)) l1 l2:
   thm
val LIST_REL_NIL =
   |- (LIST_REL R [] x ⇔ (x = [])) ∧ (LIST_REL R [] y ⇔ (y = [])):
   thm
val LIST_REL_cases =
   |- ∀R a0 a1.
     LIST_REL R a0 a1 ⇔
     (a0 = []) ∧ (a1 = []) ∨
     ∃h1 h2 t1 t2.
       (a0 = h1::t1) ∧ (a1 = h2::t2) ∧ R h1 h2 ∧ LIST_REL R t1 t2:
   thm
val LIST_REL_def =
   |- (LIST_REL R [] [] ⇔ T) ∧ (LIST_REL R (a::as) [] ⇔ F) ∧
   (LIST_REL R [] (b::bs) ⇔ F) ∧
   (LIST_REL R (a::as) (b::bs) ⇔ R a b ∧ LIST_REL R as bs):
   thm
val LIST_REL_ind =
   |- ∀R LIST_REL'.
     LIST_REL' [] [] ∧
     (∀h1 h2 t1 t2.
        R h1 h2 ∧ LIST_REL' t1 t2 ⇒ LIST_REL' (h1::t1) (h2::t2)) ⇒
     ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1:
   thm
val LIST_REL_mono =
   |- (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2:
   thm
val LIST_REL_rules =
   |- ∀R.
     LIST_REL R [] [] ∧
     ∀h1 h2 t1 t2.
       R h1 h2 ∧ LIST_REL R t1 t2 ⇒ LIST_REL R (h1::t1) (h2::t2):
   thm
val LIST_REL_strongind =
   |- ∀R LIST_REL'.
     LIST_REL' [] [] ∧
     (∀h1 h2 t1 t2.
        R h1 h2 ∧ LIST_REL R t1 t2 ∧ LIST_REL' t1 t2 ⇒
        LIST_REL' (h1::t1) (h2::t2)) ⇒
     ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1:
   thm
val LIST_REL_trans =
   |- ∀l1 l2 l3.
     (∀n.
        n < LENGTH l1 ∧ R (EL n l1) (EL n l2) ∧ R (EL n l2) (EL n l3) ⇒
        R (EL n l1) (EL n l3)) ∧ LIST_REL R l1 l2 ∧ LIST_REL R l2 l3 ⇒
     LIST_REL R l1 l3:
   thm
val LIST_TO_SET =
   |- (set [] = ∅) ∧ (set (h::t) = h INSERT set t):
   thm
val LIST_TO_SET_APPEND =
   |- ∀l1 l2. set (l1 ++ l2) = set l1 ∪ set l2:
   thm
val LIST_TO_SET_DEF =
   |- (∀x. set [] x ⇔ F) ∧ ∀h t x. set (h::t) x ⇔ (x = h) ∨ set t x:
   thm
val LIST_TO_SET_EQ_EMPTY =
   |- ((set l = ∅) ⇔ (l = [])) ∧ ((∅ = set l) ⇔ (l = [])):
   thm
val LIST_TO_SET_FILTER =
   |- set (FILTER P l) = {x | P x} ∩ set l:
   thm
val LIST_TO_SET_FLAT =
   |- ∀ls. set (FLAT ls) = BIGUNION (set (MAP set ls)):
   thm
val LIST_TO_SET_GENLIST =
   |- ∀f n. set (GENLIST f n) = IMAGE f (count n):
   thm
val LIST_TO_SET_MAP =
   |- ∀f l. set (MAP f l) = IMAGE f (set l):
   thm
val LIST_TO_SET_REVERSE =
   |- ∀ls. set (REVERSE ls) = set ls:
   thm
val LIST_TO_SET_SNOC =
   |- set (SNOC x ls) = x INSERT set ls:
   thm
val LIST_TO_SET_THM =
   |- (set [] = ∅) ∧ (set (h::t) = h INSERT set t):
   thm
val LLEX_CONG =
   |- ∀R l1 l2 R' l1' l2'.
     (l1 = l1') ∧ (l2 = l2') ∧
     (∀a b. MEM a l1' ∧ MEM b l2' ⇒ (R a b ⇔ R' a b)) ⇒
     (LLEX R l1 l2 ⇔ LLEX R' l1' l2'):
   thm
val LLEX_EL_THM =
   |- ∀R l1 l2.
     LLEX R l1 l2 ⇔
     ∃n.
       n ≤ LENGTH l1 ∧ n < LENGTH l2 ∧ (TAKE n l1 = TAKE n l2) ∧
       (n < LENGTH l1 ⇒ R (EL n l1) (EL n l2)):
   thm
val LLEX_MONO =
   |- (∀x y. R1 x y ⇒ R2 x y) ⇒ LLEX R1 x y ⇒ LLEX R2 x y:
   thm
val LLEX_NIL2 =
   |- ¬LLEX R l []:
   thm
val LLEX_THM =
   |- (¬LLEX R [] [] ∧ ¬LLEX R (h1::t1) []) ∧ LLEX R [] (h2::t2) ∧
   (LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ (h1 = h2) ∧ LLEX R t1 t2):
   thm
val LLEX_def =
   |- (∀R l2. LLEX R [] l2 ⇔ l2 ≠ []) ∧
   ∀R h1 t1 l2.
     LLEX R (h1::t1) l2 ⇔
     case l2 of
       [] => F
     | h2::t2 =>
         if R h1 h2 then T else if h1 = h2 then LLEX R t1 t2 else F:
   thm
val LLEX_not_WF =
   |- (∃a b. R a b) ⇒ ¬WF (LLEX R):
   thm
val LLEX_total =
   |- total (RC R) ⇒ total (RC (LLEX R)):
   thm
val LLEX_transitive =
   |- transitive R ⇒ transitive (LLEX R):
   thm
val LRC_MEM =
   |- LRC R ls x y ∧ MEM e ls ⇒ ∃z t. R e z ∧ LRC R t z y:
   thm
val LRC_MEM_right =
   |- LRC R (h::t) x y ∧ MEM e t ⇒ ∃z p. R z e ∧ LRC R p x z:
   thm
val LRC_def =
   |- (∀R x y. LRC R [] x y ⇔ (x = y)) ∧
   ∀R h t x y. LRC R (h::t) x y ⇔ (x = h) ∧ ∃z. R x z ∧ LRC R t z y:
   thm
val LUPDATE_LENGTH =
   |- ∀xs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys:
   thm
val LUPDATE_MAP =
   |- ∀x n l f. MAP f (LUPDATE x n l) = LUPDATE (f x) n (MAP f l):
   thm
val LUPDATE_NIL =
   |- ∀xs n x. (LUPDATE x n xs = []) ⇔ (xs = []):
   thm
val LUPDATE_SAME =
   |- ∀n ls. n < LENGTH ls ⇒ (LUPDATE (EL n ls) n ls = ls):
   thm
val LUPDATE_SEM =
   |- (∀e n l. LENGTH (LUPDATE e n l) = LENGTH l) ∧
   ∀e n l p.
     p < LENGTH l ⇒ (EL p (LUPDATE e n l) = if p = n then e else EL p l):
   thm
val LUPDATE_SNOC =
   |- ∀ys k x y.
     LUPDATE x k (SNOC y ys) =
     if k = LENGTH ys then SNOC x ys else SNOC y (LUPDATE x k ys):
   thm
val LUPDATE_SOME_MAP =
   |- ∀xs n f h.
     LUPDATE (SOME (f h)) n (MAP (OPTION_MAP f) xs) =
     MAP (OPTION_MAP f) (LUPDATE (SOME h) n xs):
   thm
val LUPDATE_compute =
   |- (∀e n. LUPDATE e n [] = []) ∧ (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
   (∀e n x l.
      LUPDATE e (NUMERAL (BIT1 n)) (x::l) =
      x::LUPDATE e (NUMERAL (BIT1 n) − 1) l) ∧
   ∀e n x l.
     LUPDATE e (NUMERAL (BIT2 n)) (x::l) =
     x::LUPDATE e (NUMERAL (BIT1 n)) l:
   thm
val LUPDATE_def =
   |- (∀e n. LUPDATE e n [] = []) ∧ (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
   ∀e n x l. LUPDATE e (SUC n) (x::l) = x::LUPDATE e n l:
   thm
val MAP =
   |- (∀f. MAP f [] = []) ∧ ∀f h t. MAP f (h::t) = f h::MAP f t:
   thm
val MAP2 =
   |- (∀f. MAP2 f [] [] = []) ∧
   ∀f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2:
   thm
val MAP2_CONG =
   |- ∀l1 l1' l2 l2' f f'.
     (l1 = l1') ∧ (l2 = l2') ∧
     (∀x y. MEM x l1' ∧ MEM y l2' ⇒ (f x y = f' x y)) ⇒
     (MAP2 f l1 l2 = MAP2 f' l1' l2'):
   thm
val MAP2_DEF =
   |- (∀t2 t1 h2 h1 f. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2) ∧
   (∀y f. MAP2 f [] y = []) ∧ ∀v5 v4 f. MAP2 f (v4::v5) [] = []:
   thm
val MAP2_MAP =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2)):
   thm
val MAP2_ZIP =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2)):
   thm
val MAP2_ind =
   |- ∀P.
     (∀f h1 t1 h2 t2. P f t1 t2 ⇒ P f (h1::t1) (h2::t2)) ∧
     (∀f y. P f [] y) ∧ (∀f v4 v5. P f (v4::v5) []) ⇒
     ∀v v1 v2. P v v1 v2:
   thm
val MAP_APPEND =
   |- ∀f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2:
   thm
val MAP_APPEND_MAP_EQ =
   |- ∀xs ys.
     (MAP f1 xs ++ MAP g1 ys = MAP f2 xs ++ MAP g2 ys) ⇔
     (MAP f1 xs = MAP f2 xs) ∧ (MAP g1 ys = MAP g2 ys):
   thm
val MAP_CONG =
   |- ∀l1 l2 f f'.
     (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (f x = f' x)) ⇒ (MAP f l1 = MAP f' l2):
   thm
val MAP_EQ_APPEND =
   |- (MAP f l = l1 ++ l2) ⇔
   ∃l10 l20. (l = l10 ++ l20) ∧ (l1 = MAP f l10) ∧ (l2 = MAP f l20):
   thm
val MAP_EQ_CONS =
   |- (MAP f l = h::t) ⇔ ∃x0 t0. (l = x0::t0) ∧ (h = f x0) ∧ (t = MAP f t0):
   thm
val MAP_EQ_EVERY2 =
   |- ∀f1 f2 l1 l2.
     (MAP f1 l1 = MAP f2 l2) ⇔
     (LENGTH l1 = LENGTH l2) ∧ LIST_REL (λx y. f1 x = f2 y) l1 l2:
   thm
val MAP_EQ_NIL =
   |- ∀l f. ((MAP f l = []) ⇔ (l = [])) ∧ (([] = MAP f l) ⇔ (l = [])):
   thm
val MAP_EQ_SING =
   |- (MAP f l = [x]) ⇔ ∃x0. (l = [x0]) ∧ (x = f x0):
   thm
val MAP_EQ_f =
   |- ∀f1 f2 l. (MAP f1 l = MAP f2 l) ⇔ ∀e. MEM e l ⇒ (f1 e = f2 e):
   thm
val MAP_FLAT =
   |- MAP f (FLAT l) = FLAT (MAP (MAP f) l):
   thm
val MAP_GENLIST =
   |- ∀f g n. MAP f (GENLIST g n) = GENLIST (f ∘ g) n:
   thm
val MAP_ID =
   |- (MAP (λx. x) l = l) ∧ (MAP I l = l):
   thm
val MAP_LIST_BIND =
   |- MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ∘ g):
   thm
val MAP_MAP_o =
   |- ∀f g l. MAP f (MAP g l) = MAP (f ∘ g) l:
   thm
val MAP_SNOC =
   |- ∀f x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l):
   thm
val MAP_TAKE =
   |- ∀f n l. MAP f (TAKE n l) = TAKE n (MAP f l):
   thm
val MAP_TL =
   |- ∀l f. ¬NULL l ⇒ (MAP f (TL l) = TL (MAP f l)):
   thm
val MAP_ZIP =
   |- (LENGTH l1 = LENGTH l2) ⇒
   (MAP FST (ZIP (l1,l2)) = l1) ∧ (MAP SND (ZIP (l1,l2)) = l2) ∧
   (MAP (f ∘ FST) (ZIP (l1,l2)) = MAP f l1) ∧
   (MAP (g ∘ SND) (ZIP (l1,l2)) = MAP g l2):
   thm
val MAP_ZIP_SAME =
   |- ∀ls f. MAP f (ZIP (ls,ls)) = MAP (λx. f (x,x)) ls:
   thm
val MAP_o =
   |- ∀f g. MAP (f ∘ g) = MAP f ∘ MAP g:
   thm
val MEM =
   |- (∀x. MEM x [] ⇔ F) ∧ ∀x h t. MEM x (h::t) ⇔ (x = h) ∨ MEM x t:
   thm
val MEM_APPEND =
   |- ∀e l1 l2. MEM e (l1 ++ l2) ⇔ MEM e l1 ∨ MEM e l2:
   thm
val MEM_APPEND_lemma =
   |- ∀a b c d x.
     (a ++ [x] ++ b = c ++ [x] ++ d) ∧ ¬MEM x b ∧ ¬MEM x a ⇒
     (a = c) ∧ (b = d):
   thm
val MEM_DROP =
   |- ∀x ls n.
     MEM x (DROP n ls) ⇔
     n < LENGTH ls ∧ (x = EL n ls) ∨ MEM x (DROP (SUC n) ls):
   thm
val MEM_EL =
   |- ∀l x. MEM x l ⇔ ∃n. n < LENGTH l ∧ (x = EL n l):
   thm
val MEM_FILTER =
   |- ∀P L x. MEM x (FILTER P L) ⇔ P x ∧ MEM x L:
   thm
val MEM_FLAT =
   |- ∀x L. MEM x (FLAT L) ⇔ ∃l. MEM l L ∧ MEM x l:
   thm
val MEM_GENLIST =
   |- MEM x (GENLIST f n) ⇔ ∃m. m < n ∧ (x = f m):
   thm
val MEM_LUPDATE =
   |- ∀l x y i.
     MEM x (LUPDATE y i l) ⇔
     i < LENGTH l ∧ (x = y) ∨ ∃j. j < LENGTH l ∧ i ≠ j ∧ (EL j l = x):
   thm
val MEM_LUPDATE_E =
   |- ∀l x y i. MEM x (LUPDATE y i l) ⇒ (x = y) ∨ MEM x l:
   thm
val MEM_MAP =
   |- ∀l f x. MEM x (MAP f l) ⇔ ∃y. (x = f y) ∧ MEM y l:
   thm
val MEM_REVERSE =
   |- ∀l x. MEM x (REVERSE l) ⇔ MEM x l:
   thm
val MEM_SET_TO_LIST =
   |- ∀s. FINITE s ⇒ ∀x. MEM x (SET_TO_LIST s) ⇔ x ∈ s:
   thm
val MEM_SNOC =
   |- ∀y x l. MEM y (SNOC x l) ⇔ (y = x) ∨ MEM y l:
   thm
val MEM_SPLIT =
   |- ∀x l. MEM x l ⇔ ∃l1 l2. l = l1 ++ x::l2:
   thm
val MEM_SPLIT_APPEND_first =
   |- MEM e l ⇔ ∃pfx sfx. (l = pfx ++ [e] ++ sfx) ∧ ¬MEM e pfx:
   thm
val MEM_SPLIT_APPEND_last =
   |- MEM e l ⇔ ∃pfx sfx. (l = pfx ++ [e] ++ sfx) ∧ ¬MEM e sfx:
   thm
val MEM_ZIP =
   |- ∀l1 l2 p.
     (LENGTH l1 = LENGTH l2) ⇒
     (MEM p (ZIP (l1,l2)) ⇔ ∃n. n < LENGTH l1 ∧ (p = (EL n l1,EL n l2))):
   thm
val MEM_ZIP_MEM_MAP =
   |- (LENGTH (FST ps) = LENGTH (SND ps)) ∧ MEM p (ZIP ps) ⇒
   MEM (FST p) (FST ps) ∧ MEM (SND p) (SND ps):
   thm
val MEM_dropWhile_IMP =
   |- ∀P ls x. MEM x (dropWhile P ls) ⇒ MEM x ls:
   thm
val MONO_EVERY =
   |- (∀x. P x ⇒ Q x) ⇒ EVERY P l ⇒ EVERY Q l:
   thm
val MONO_EXISTS =
   |- (∀x. P x ⇒ Q x) ⇒ EXISTS P l ⇒ EXISTS Q l:
   thm
val NOT_CONS_NIL =
   |- ∀a1 a0. a0::a1 ≠ []:
   thm
val NOT_EQ_LIST =
   |- ∀h1 h2. h1 ≠ h2 ⇒ ∀l1 l2. h1::l1 ≠ h2::l2:
   thm
val NOT_EVERY =
   |- ∀P l. ¬EVERY P l ⇔ EXISTS ($~ ∘ P) l:
   thm
val NOT_EXISTS =
   |- ∀P l. ¬EXISTS P l ⇔ EVERY ($~ ∘ P) l:
   thm
val NOT_NIL_CONS =
   |- ∀a1 a0. [] ≠ a0::a1:
   thm
val NOT_NIL_EQ_LENGTH_NOT_0 =
   |- x ≠ [] ⇔ 0 < LENGTH x:
   thm
val NOT_NULL_MEM =
   |- ∀l. ¬NULL l ⇔ ∃e. MEM e l:
   thm
val NRC_LRC =
   |- NRC R n x y ⇔ ∃ls. LRC R ls x y ∧ (LENGTH ls = n):
   thm
val NULL =
   |- NULL [] ∧ ∀h t. ¬NULL (h::t):
   thm
val NULL_DEF =
   |- (NULL [] ⇔ T) ∧ ∀h t. NULL (h::t) ⇔ F:
   thm
val NULL_EQ =
   |- ∀l. NULL l ⇔ (l = []):
   thm
val NULL_FILTER =
   |- ∀P ls. NULL (FILTER P ls) ⇔ ∀x. MEM x ls ⇒ ¬P x:
   thm
val NULL_GENLIST =
   |- ∀n f. NULL (GENLIST f n) ⇔ (n = 0):
   thm
val NULL_LENGTH =
   |- ∀l. NULL l ⇔ (LENGTH l = 0):
   thm
val OPT_MMAP_def =
   |- (∀f. OPT_MMAP f [] = SOME []) ∧
   ∀f h0 t0.
     OPT_MMAP f (h0::t0) =
     OPTION_BIND (f h0)
       (λh. OPTION_BIND (OPT_MMAP f t0) (λt. SOME (h::t))):
   thm
val PAD_LEFT =
   |- ∀c n s. PAD_LEFT c n s = GENLIST (K c) (n − LENGTH s) ++ s:
   thm
val PAD_RIGHT =
   |- ∀c n s. PAD_RIGHT c n s = s ++ GENLIST (K c) (n − LENGTH s):
   thm
val REVERSE_11 =
   |- ∀l1 l2. (REVERSE l1 = REVERSE l2) ⇔ (l1 = l2):
   thm
val REVERSE_APPEND =
   |- ∀l1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1:
   thm
val REVERSE_DEF =
   |- (REVERSE [] = []) ∧ ∀h t. REVERSE (h::t) = REVERSE t ++ [h]:
   thm
val REVERSE_EQ_NIL =
   |- (REVERSE l = []) ⇔ (l = []):
   thm
val REVERSE_EQ_SING =
   |- (REVERSE l = [e]) ⇔ (l = [e]):
   thm
val REVERSE_GENLIST =
   |- REVERSE (GENLIST f n) = GENLIST (λm. f (PRE n − m)) n:
   thm
val REVERSE_REV =
   |- ∀L. REVERSE L = REV L []:
   thm
val REVERSE_REVERSE =
   |- ∀l. REVERSE (REVERSE l) = l:
   thm
val REVERSE_SNOC =
   |- ∀x l. REVERSE (SNOC x l) = x::REVERSE l:
   thm
val REVERSE_SNOC_DEF =
   |- (REVERSE [] = []) ∧ ∀x l. REVERSE (x::l) = SNOC x (REVERSE l):
   thm
val REVERSE_o_REVERSE =
   |- REVERSE ∘ REVERSE ∘ f = f:
   thm
val REV_DEF =
   |- (∀acc. REV [] acc = acc) ∧ ∀h t acc. REV (h::t) acc = REV t (h::acc):
   thm
val REV_REVERSE_LEM =
   |- ∀L1 L2. REV L1 L2 = REVERSE L1 ++ L2:
   thm
val SET_TO_LIST_CARD =
   |- ∀s. FINITE s ⇒ (LENGTH (SET_TO_LIST s) = CARD s):
   thm
val SET_TO_LIST_EMPTY =
   |- SET_TO_LIST ∅ = []:
   thm
val SET_TO_LIST_IND =
   |- ∀P. (∀s. (FINITE s ∧ s ≠ ∅ ⇒ P (REST s)) ⇒ P s) ⇒ ∀v. P v:
   thm
val SET_TO_LIST_INV =
   |- ∀s. FINITE s ⇒ (set (SET_TO_LIST s) = s):
   thm
val SET_TO_LIST_IN_MEM =
   |- ∀s. FINITE s ⇒ ∀x. x ∈ s ⇔ MEM x (SET_TO_LIST s):
   thm
val SET_TO_LIST_SING =
   |- SET_TO_LIST {x} = [x]:
   thm
val SET_TO_LIST_THM =
   |- FINITE s ⇒
   (SET_TO_LIST s =
    if s = ∅ then [] else CHOICE s::SET_TO_LIST (REST s)):
   thm
val SET_TO_LIST_primitive_def =
   |- SET_TO_LIST =
   WFREC (@R. WF R ∧ ∀s. FINITE s ∧ s ≠ ∅ ⇒ R (REST s) s)
     (λSET_TO_LIST a.
        I
          (if FINITE a then
             if a = ∅ then [] else CHOICE a::SET_TO_LIST (REST a)
           else ARB)):
   thm
val SINGL_APPLY_MAP =
   |- [f] <*> l = MAP f l:
   thm
val SINGL_APPLY_PERMUTE =
   |- fs <*> [x] = [(λf. f x)] <*> fs:
   thm
val SINGL_LIST_APPLY_L =
   |- LIST_BIND [x] f = f x:
   thm
val SINGL_LIST_APPLY_R =
   |- LIST_BIND l (λx. [x]) = l:
   thm
val SINGL_SINGL_APPLY =
   |- [f] <*> [x] = [f x]:
   thm
val SNOC =
   |- (∀x. SNOC x [] = [x]) ∧ ∀x x' l. SNOC x (x'::l) = x'::SNOC x l:
   thm
val SNOC_11 =
   |- ∀x y a b. (SNOC x y = SNOC a b) ⇔ (x = a) ∧ (y = b):
   thm
val SNOC_APPEND =
   |- ∀x l. SNOC x l = l ++ [x]:
   thm
val SNOC_Axiom =
   |- ∀e f. ∃fn. (fn [] = e) ∧ ∀x l. fn (SNOC x l) = f x l (fn l):
   thm
val SNOC_CASES =
   |- ∀ll. (ll = []) ∨ ∃x l. ll = SNOC x l:
   thm
val SNOC_INDUCT =
   |- ∀P. P [] ∧ (∀l. P l ⇒ ∀x. P (SNOC x l)) ⇒ ∀l. P l:
   thm
val SUM =
   |- (SUM [] = 0) ∧ ∀h t. SUM (h::t) = h + SUM t:
   thm
val SUM_ACC_DEF =
   |- (∀acc. SUM_ACC [] acc = acc) ∧
   ∀h t acc. SUM_ACC (h::t) acc = SUM_ACC t (h + acc):
   thm
val SUM_ACC_SUM_LEM =
   |- ∀L n. SUM_ACC L n = SUM L + n:
   thm
val SUM_APPEND =
   |- ∀l1 l2. SUM (l1 ++ l2) = SUM l1 + SUM l2:
   thm
val SUM_IMAGE_LIST_TO_SET_upper_bound =
   |- ∀ls. ∑ f (set ls) ≤ SUM (MAP f ls):
   thm
val SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST =
   |- FINITE s ⇒ (∑ f s = SUM (MAP f (SET_TO_LIST s))):
   thm
val SUM_MAP_FOLDL =
   |- ∀ls. SUM (MAP f ls) = FOLDL (λa e. a + f e) 0 ls:
   thm
val SUM_MAP_MEM_bound =
   |- ∀f x ls. MEM x ls ⇒ f x ≤ SUM (MAP f ls):
   thm
val SUM_MAP_PLUS =
   |- ∀f g ls.
     SUM (MAP (λx. f x + g x) ls) = SUM (MAP f ls) + SUM (MAP g ls):
   thm
val SUM_MAP_PLUS_ZIP =
   |- ∀ls1 ls2.
     (LENGTH ls1 = LENGTH ls2) ∧ (∀x y. f (x,y) = g x + h y) ⇒
     (SUM (MAP f (ZIP (ls1,ls2))) = SUM (MAP g ls1) + SUM (MAP h ls2)):
   thm
val SUM_SNOC =
   |- ∀x l. SUM (SNOC x l) = SUM l + x:
   thm
val SUM_SUM_ACC =
   |- ∀L. SUM L = SUM_ACC L 0:
   thm
val SUM_eq_0 =
   |- ∀ls. (SUM ls = 0) ⇔ ∀x. MEM x ls ⇒ (x = 0):
   thm
val SWAP_REVERSE =
   |- ∀l1 l2. (l1 = REVERSE l2) ⇔ (l2 = REVERSE l1):
   thm
val SWAP_REVERSE_SYM =
   |- ∀l1 l2. (REVERSE l1 = l2) ⇔ (l1 = REVERSE l2):
   thm
val TAKE_0 =
   |- TAKE 0 l = []:
   thm
val TAKE_APPEND1 =
   |- ∀n. n ≤ LENGTH l1 ⇒ (TAKE n (l1 ++ l2) = TAKE n l1):
   thm
val TAKE_APPEND2 =
   |- ∀n.
     LENGTH l1 < n ⇒ (TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2):
   thm
val TAKE_DROP =
   |- ∀n l. TAKE n l ++ DROP n l = l:
   thm
val TAKE_LENGTH_ID =
   |- ∀l. TAKE (LENGTH l) l = l:
   thm
val TAKE_LENGTH_ID_rwt =
   |- ∀l m. (m = LENGTH l) ⇒ (TAKE m l = l):
   thm
val TAKE_LENGTH_TOO_LONG =
   |- ∀l n. LENGTH l ≤ n ⇒ (TAKE n l = l):
   thm
val TAKE_SUM =
   |- ∀n m l. TAKE (n + m) l = TAKE n l ++ TAKE m (DROP n l):
   thm
val TAKE_compute =
   |- (∀l. TAKE 0 l = []) ∧ (∀n. TAKE (NUMERAL (BIT1 n)) [] = []) ∧
   (∀n. TAKE (NUMERAL (BIT2 n)) [] = []) ∧
   (∀n h t.
      TAKE (NUMERAL (BIT1 n)) (h::t) =
      h::TAKE (NUMERAL (BIT1 n) − 1) t) ∧
   ∀n h t. TAKE (NUMERAL (BIT2 n)) (h::t) = h::TAKE (NUMERAL (BIT1 n)) t:
   thm
val TAKE_cons =
   |- 0 < n ⇒ (TAKE n (x::xs) = x::TAKE (n − 1) xs):
   thm
val TAKE_def =
   |- (∀n. TAKE n [] = []) ∧
   ∀n x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n − 1) xs:
   thm
val TAKE_nil =
   |- ∀n. TAKE n [] = []:
   thm
val TAKE_splitAtPki =
   |- TAKE n l = splitAtPki (K ∘ $= n) K l:
   thm
val TL =
   |- ∀h t. TL (h::t) = t:
   thm
val TL_GENLIST =
   |- ∀f n. TL (GENLIST f (SUC n)) = GENLIST (f ∘ SUC) n:
   thm
val TR2_EQ_rules_thm =
   |- (TR2 (M,Oi,Os) (exec cmd)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         ins (NS state (exec cmd)) (Out state (exec cmd)::outStream)) ⇔
    inputTest (inputInterpret x) ∧
    CFG2Interpret (M,Oi,Os)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)) ∧
   (TR2 (M,Oi,Os) (trap cmd)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         ins (NS state (trap cmd)) (Out state (trap cmd)::outStream)) ⇔
    inputTest (inputInterpret x) ∧
    CFG2Interpret (M,Oi,Os)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)) ∧
   (TR2 (M,Oi,Os) discard
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         ins (NS state discard) (Out state discard::outStream)) ⇔
    ¬inputTest (inputInterpret x)):
   thm
val TR2_cases =
   |- ∀a0 a1 a2 a3.
     TR2 a0 a1 a2 a3 ⇔
     (∃inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        (a0 = (M,Oi,Os)) ∧ (a1 = exec cmd) ∧
        (a2 =
         CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream) ∧
        (a3 =
         CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret ins (NS state (exec cmd))
           (Out state (exec cmd)::outStream)) ∧
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)) ∨
     (∃inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        (a0 = (M,Oi,Os)) ∧ (a1 = trap cmd) ∧
        (a2 =
         CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream) ∧
        (a3 =
         CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret ins (NS state (trap cmd))
           (Out state (trap cmd)::outStream)) ∧
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)) ∨
     ∃inputInterpret certInterpret inputTest x NS M Oi Os Out state
        certs stateInterpret cmd ins outStream.
       (a0 = (M,Oi,Os)) ∧ (a1 = discard) ∧
       (a2 =
        CFG2 inputInterpret certInterpret inputTest certs stateInterpret
          (x::ins) state outStream) ∧
       (a3 =
        CFG2 inputInterpret certInterpret inputTest certs stateInterpret
          ins (NS state discard) (Out state discard::outStream)) ∧
       ¬inputTest (inputInterpret x):
   thm
val TR2_def =
   |- TR2 =
   (λa0 a1 a2 a3.
      ∀TR2'.
        (∀a0 a1 a2 a3.
           (∃inputInterpret certInterpret inputTest x NS M Oi Os Out
               state certs stateInterpret cmd ins outStream.
              (a0 = (M,Oi,Os)) ∧ (a1 = exec cmd) ∧
              (a2 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret (x::ins) state outStream) ∧
              (a3 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret ins (NS state (exec cmd))
                 (Out state (exec cmd)::outStream)) ∧
              inputTest (inputInterpret x) ∧
              CFG2Interpret (M,Oi,Os)
                (CFG2 inputInterpret certInterpret inputTest certs
                   stateInterpret (x::ins) state outStream)) ∨
           (∃inputInterpret certInterpret inputTest x NS M Oi Os Out
               state certs stateInterpret cmd ins outStream.
              (a0 = (M,Oi,Os)) ∧ (a1 = trap cmd) ∧
              (a2 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret (x::ins) state outStream) ∧
              (a3 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret ins (NS state (trap cmd))
                 (Out state (trap cmd)::outStream)) ∧
              inputTest (inputInterpret x) ∧
              CFG2Interpret (M,Oi,Os)
                (CFG2 inputInterpret certInterpret inputTest certs
                   stateInterpret (x::ins) state outStream)) ∨
           (∃inputInterpret certInterpret inputTest x NS M Oi Os Out
               state certs stateInterpret cmd ins outStream.
              (a0 = (M,Oi,Os)) ∧ (a1 = discard) ∧
              (a2 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret (x::ins) state outStream) ∧
              (a3 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret ins (NS state discard)
                 (Out state discard::outStream)) ∧
              ¬inputTest (inputInterpret x)) ⇒
           TR2' a0 a1 a2 a3) ⇒
        TR2' a0 a1 a2 a3):
   thm
val TR2_discard_cmd_rule =
   |- TR2 (M,Oi,Os) discard
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        ins (NS state discard) (Out state discard::outStream)) ⇔
   ¬inputTest (inputInterpret x):
   thm
val TR2_exec_cmd_rule =
   |- ∀inputInterpret certInterpret inputTest certs stateInterpret x cmd
      ins state outStream.
     (∀M Oi Os.
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        (M,Oi,Os) sat prop (SOME cmd)) ⇒
     ∀NS Out M Oi Os.
       TR2 (M,Oi,Os) (exec cmd)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret (x::ins) state outStream)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret ins (NS state (exec cmd))
            (Out state (exec cmd)::outStream)) ⇔
       inputTest (inputInterpret x) ∧
       CFG2Interpret (M,Oi,Os)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret (x::ins) state outStream) ∧
       (M,Oi,Os) sat prop (SOME cmd):
   thm
val TR2_iff_TR_discard_thm =
   |- ∀NS Out outStream state certs certs2 x ins ins2 stateInterpret
      inputInterpret certInterpret inputTest.
     TR2 (M,Oi,Os) discard
       (CFG2 inputInterpret certInterpret inputTest certs2
          stateInterpret (x::ins2) state outStream)
       (CFG2 inputInterpret certInterpret inputTest certs2
          stateInterpret ins2 (NS state discard)
          (Out state discard::outStream)) ⇔
     TR (M,Oi,Os) discard
       (CFG inputTest stateInterpret certs (inputInterpret x::ins) state
          outStream)
       (CFG inputTest stateInterpret certs ins (NS state discard)
          (Out state discard::outStream)):
   thm
val TR2_iff_TR_exec_thm =
   |- ∀inputInterpret certInterpret inputTest certs certs2 stateInterpret x
      P cmd ins ins2 state outStream.
     (inputInterpret x = P says prop (SOME cmd)) ⇒
     (MAP certInterpret certs2 = certs) ⇒
     (∀M Oi Os.
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterpret certs (inputInterpret x::ins)
             state outStream) ⇒
        (M,Oi,Os) sat prop (SOME cmd)) ⇒
     (∀M Oi Os.
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs2
             stateInterpret (x::ins2) state outStream) ⇒
        (M,Oi,Os) sat prop (SOME cmd)) ⇒
     ∀NS Out M Oi Os.
       TR2 (M,Oi,Os) (exec cmd)
         (CFG2 inputInterpret certInterpret inputTest certs2
            stateInterpret (x::ins2) state outStream)
         (CFG2 inputInterpret certInterpret inputTest certs2
            stateInterpret ins2 (NS state (exec cmd))
            (Out state (exec cmd)::outStream)) ⇔
       TR (M,Oi,Os) (exec cmd)
         (CFG inputTest stateInterpret certs (inputInterpret x::ins)
            state outStream)
         (CFG inputTest stateInterpret certs ins (NS state (exec cmd))
            (Out state (exec cmd)::outStream)):
   thm
val TR2_iff_TR_trap_thm =
   |- ∀inputInterpret certInterpret inputTest certs certs2 stateInterpret x
      P cmd ins ins2 state outStream.
     (inputInterpret x = P says prop (SOME cmd)) ⇒
     (MAP certInterpret certs2 = certs) ⇒
     (∀M Oi Os.
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterpret certs (inputInterpret x::ins)
             state outStream) ⇒
        (M,Oi,Os) sat prop NONE) ⇒
     (∀M Oi Os.
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs2
             stateInterpret (x::ins2) state outStream) ⇒
        (M,Oi,Os) sat prop NONE) ⇒
     ∀NS Out M Oi Os.
       TR2 (M,Oi,Os) (trap cmd)
         (CFG2 inputInterpret certInterpret inputTest certs2
            stateInterpret (x::ins2) state outStream)
         (CFG2 inputInterpret certInterpret inputTest certs2
            stateInterpret ins2 (NS state (trap cmd))
            (Out state (trap cmd)::outStream)) ⇔
       TR (M,Oi,Os) (trap cmd)
         (CFG inputTest stateInterpret certs (inputInterpret x::ins)
            state outStream)
         (CFG inputTest stateInterpret certs ins (NS state (trap cmd))
            (Out state (trap cmd)::outStream)):
   thm
val TR2_ind =
   |- ∀TR2'.
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        TR2' (M,Oi,Os) (exec cmd)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state (exec cmd))
             (Out state (exec cmd)::outStream))) ∧
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        TR2' (M,Oi,Os) (trap cmd)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state (trap cmd))
             (Out state (trap cmd)::outStream))) ∧
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        ¬inputTest (inputInterpret x) ⇒
        TR2' (M,Oi,Os) discard
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state discard)
             (Out state discard::outStream))) ⇒
     ∀a0 a1 a2 a3. TR2 a0 a1 a2 a3 ⇒ TR2' a0 a1 a2 a3:
   thm
val TR2_rules =
   |- (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state certs
       stateInterpret cmd ins outStream.
      inputTest (inputInterpret x) ∧
      CFG2Interpret (M,Oi,Os)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream) ⇒
      TR2 (M,Oi,Os) (exec cmd)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret ins (NS state (exec cmd))
           (Out state (exec cmd)::outStream))) ∧
   (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state certs
       stateInterpret cmd ins outStream.
      inputTest (inputInterpret x) ∧
      CFG2Interpret (M,Oi,Os)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream) ⇒
      TR2 (M,Oi,Os) (trap cmd)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret ins (NS state (trap cmd))
           (Out state (trap cmd)::outStream))) ∧
   ∀inputInterpret certInterpret inputTest x NS M Oi Os Out state certs
      stateInterpret cmd ins outStream.
     ¬inputTest (inputInterpret x) ⇒
     TR2 (M,Oi,Os) discard
       (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
          (x::ins) state outStream)
       (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
          ins (NS state discard) (Out state discard::outStream)):
   thm
val TR2_strongind =
   |- ∀TR2'.
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        TR2' (M,Oi,Os) (exec cmd)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state (exec cmd))
             (Out state (exec cmd)::outStream))) ∧
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        TR2' (M,Oi,Os) (trap cmd)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state (trap cmd))
             (Out state (trap cmd)::outStream))) ∧
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret ins outStream.
        ¬inputTest (inputInterpret x) ⇒
        TR2' (M,Oi,Os) discard
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state discard)
             (Out state discard::outStream))) ⇒
     ∀a0 a1 a2 a3. TR2 a0 a1 a2 a3 ⇒ TR2' a0 a1 a2 a3:
   thm
val TR2_trap_cmd_rule =
   |- ∀inputInterpret certInterpret inputTest certs stateInterpret x cmd
      ins state outStream.
     (∀M Oi Os.
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        (M,Oi,Os) sat prop NONE) ⇒
     ∀NS Out M Oi Os.
       TR2 (M,Oi,Os) (trap cmd)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret (x::ins) state outStream)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret ins (NS state (trap cmd))
            (Out state (trap cmd)::outStream)) ⇔
       inputTest (inputInterpret x) ∧
       CFG2Interpret (M,Oi,Os)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret (x::ins) state outStream) ∧
       (M,Oi,Os) sat prop NONE:
   thm
val TR2rule0 =
   |- TR2 (M,Oi,Os) (exec cmd)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        ins (NS state (exec cmd)) (Out state (exec cmd)::outStream)) ⇔
   inputTest (inputInterpret x) ∧
   CFG2Interpret (M,Oi,Os)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream):
   thm
val TR2rule1 =
   |- TR2 (M,Oi,Os) (trap cmd)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        ins (NS state (trap cmd)) (Out state (trap cmd)::outStream)) ⇔
   inputTest (inputInterpret x) ∧
   CFG2Interpret (M,Oi,Os)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream):
   thm
val TR_EQ_rules_thm =
   |- (TR (M,Oi,Os) (exec cmd)
      (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins)
         s outs)
      (CFG inputTest stateInterp certList ins (NS s (exec cmd))
         (Out s (exec cmd)::outs)) ⇔
    inputTest (P says prop (SOME cmd)) ∧
    CFGInterpret (M,Oi,Os)
      (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins)
         s outs)) ∧
   (TR (M,Oi,Os) (trap cmd)
      (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins)
         s outs)
      (CFG inputTest stateInterp certList ins (NS s (trap cmd))
         (Out s (trap cmd)::outs)) ⇔
    inputTest (P says prop (SOME cmd)) ∧
    CFGInterpret (M,Oi,Os)
      (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins)
         s outs)) ∧
   (TR (M,Oi,Os) discard
      (CFG inputTest stateInterp certList (x::ins) s outs)
      (CFG inputTest stateInterp certList ins (NS s discard)
         (Out s discard::outs)) ⇔ ¬inputTest x):
   thm
val TR_cases =
   |- ∀a0 a1 a2 a3.
     TR a0 a1 a2 a3 ⇔
     (∃inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        (a0 = (M,Oi,Os)) ∧ (a1 = exec cmd) ∧
        (a2 =
         CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs) ∧
        (a3 =
         CFG inputTest stateInterp certList ins (NS s (exec cmd))
           (Out s (exec cmd)::outs)) ∧
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)) ∨
     (∃inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        (a0 = (M,Oi,Os)) ∧ (a1 = trap cmd) ∧
        (a2 =
         CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs) ∧
        (a3 =
         CFG inputTest stateInterp certList ins (NS s (trap cmd))
           (Out s (trap cmd)::outs)) ∧
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)) ∨
     ∃inputTest NS M Oi Os Out s certList stateInterp cmd x ins outs.
       (a0 = (M,Oi,Os)) ∧ (a1 = discard) ∧
       (a2 = CFG inputTest stateInterp certList (x::ins) s outs) ∧
       (a3 =
        CFG inputTest stateInterp certList ins (NS s discard)
          (Out s discard::outs)) ∧ ¬inputTest x:
   thm
val TR_def =
   |- TR =
   (λa0 a1 a2 a3.
      ∀TR'.
        (∀a0 a1 a2 a3.
           (∃inputTest P NS M Oi Os Out s certList stateInterp cmd ins
               outs.
              (a0 = (M,Oi,Os)) ∧ (a1 = exec cmd) ∧
              (a2 =
               CFG inputTest stateInterp certList
                 (P says prop (SOME cmd)::ins) s outs) ∧
              (a3 =
               CFG inputTest stateInterp certList ins (NS s (exec cmd))
                 (Out s (exec cmd)::outs)) ∧
              inputTest (P says prop (SOME cmd)) ∧
              CFGInterpret (M,Oi,Os)
                (CFG inputTest stateInterp certList
                   (P says prop (SOME cmd)::ins) s outs)) ∨
           (∃inputTest P NS M Oi Os Out s certList stateInterp cmd ins
               outs.
              (a0 = (M,Oi,Os)) ∧ (a1 = trap cmd) ∧
              (a2 =
               CFG inputTest stateInterp certList
                 (P says prop (SOME cmd)::ins) s outs) ∧
              (a3 =
               CFG inputTest stateInterp certList ins (NS s (trap cmd))
                 (Out s (trap cmd)::outs)) ∧
              inputTest (P says prop (SOME cmd)) ∧
              CFGInterpret (M,Oi,Os)
                (CFG inputTest stateInterp certList
                   (P says prop (SOME cmd)::ins) s outs)) ∨
           (∃inputTest NS M Oi Os Out s certList stateInterp cmd x ins
               outs.
              (a0 = (M,Oi,Os)) ∧ (a1 = discard) ∧
              (a2 =
               CFG inputTest stateInterp certList (x::ins) s outs) ∧
              (a3 =
               CFG inputTest stateInterp certList ins (NS s discard)
                 (Out s discard::outs)) ∧ ¬inputTest x) ⇒
           TR' a0 a1 a2 a3) ⇒
        TR' a0 a1 a2 a3):
   thm
val TR_discard_cmd_rule =
   |- TR (M,Oi,Os) discard
     (CFG inputTest stateInterp certList (x::ins) s outs)
     (CFG inputTest stateInterp certList ins (NS s discard)
        (Out s discard::outs)) ⇔ ¬inputTest x:
   thm
val TR_exec_cmd_rule =
   |- ∀inputTest certList stateInterp P cmd ins s outs.
     (∀M Oi Os.
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        (M,Oi,Os) sat prop (SOME cmd)) ⇒
     ∀NS Out M Oi Os.
       TR (M,Oi,Os) (exec cmd)
         (CFG inputTest stateInterp certList
            (P says prop (SOME cmd)::ins) s outs)
         (CFG inputTest stateInterp certList ins (NS s (exec cmd))
            (Out s (exec cmd)::outs)) ⇔
       inputTest (P says prop (SOME cmd)) ∧
       CFGInterpret (M,Oi,Os)
         (CFG inputTest stateInterp certList
            (P says prop (SOME cmd)::ins) s outs) ∧
       (M,Oi,Os) sat prop (SOME cmd):
   thm
val TR_ind =
   |- ∀TR'.
     (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        TR' (M,Oi,Os) (exec cmd)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s (exec cmd))
             (Out s (exec cmd)::outs))) ∧
     (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        TR' (M,Oi,Os) (trap cmd)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s (trap cmd))
             (Out s (trap cmd)::outs))) ∧
     (∀inputTest NS M Oi Os Out s certList stateInterp cmd x ins outs.
        ¬inputTest x ⇒
        TR' (M,Oi,Os) discard
          (CFG inputTest stateInterp certList (x::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s discard)
             (Out s discard::outs))) ⇒
     ∀a0 a1 a2 a3. TR a0 a1 a2 a3 ⇒ TR' a0 a1 a2 a3:
   thm
val TR_rules =
   |- (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
      inputTest (P says prop (SOME cmd)) ∧
      CFGInterpret (M,Oi,Os)
        (CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs) ⇒
      TR (M,Oi,Os) (exec cmd)
        (CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs)
        (CFG inputTest stateInterp certList ins (NS s (exec cmd))
           (Out s (exec cmd)::outs))) ∧
   (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
      inputTest (P says prop (SOME cmd)) ∧
      CFGInterpret (M,Oi,Os)
        (CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs) ⇒
      TR (M,Oi,Os) (trap cmd)
        (CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs)
        (CFG inputTest stateInterp certList ins (NS s (trap cmd))
           (Out s (trap cmd)::outs))) ∧
   ∀inputTest NS M Oi Os Out s certList stateInterp cmd x ins outs.
     ¬inputTest x ⇒
     TR (M,Oi,Os) discard
       (CFG inputTest stateInterp certList (x::ins) s outs)
       (CFG inputTest stateInterp certList ins (NS s discard)
          (Out s discard::outs)):
   thm
val TR_strongind =
   |- ∀TR'.
     (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        TR' (M,Oi,Os) (exec cmd)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s (exec cmd))
             (Out s (exec cmd)::outs))) ∧
     (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        TR' (M,Oi,Os) (trap cmd)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s (trap cmd))
             (Out s (trap cmd)::outs))) ∧
     (∀inputTest NS M Oi Os Out s certList stateInterp x ins outs.
        ¬inputTest x ⇒
        TR' (M,Oi,Os) discard
          (CFG inputTest stateInterp certList (x::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s discard)
             (Out s discard::outs))) ⇒
     ∀a0 a1 a2 a3. TR a0 a1 a2 a3 ⇒ TR' a0 a1 a2 a3:
   thm
val TR_trap_cmd_rule =
   |- ∀inputTest stateInterp certList P cmd ins s outs.
     (∀M Oi Os.
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        (M,Oi,Os) sat prop NONE) ⇒
     ∀NS Out M Oi Os.
       TR (M,Oi,Os) (trap cmd)
         (CFG inputTest stateInterp certList
            (P says prop (SOME cmd)::ins) s outs)
         (CFG inputTest stateInterp certList ins (NS s (trap cmd))
            (Out s (trap cmd)::outs)) ⇔
       inputTest (P says prop (SOME cmd)) ∧
       CFGInterpret (M,Oi,Os)
         (CFG inputTest stateInterp certList
            (P says prop (SOME cmd)::ins) s outs) ∧
       (M,Oi,Os) sat prop NONE:
   thm
val TRrule0 =
   |- TR (M,Oi,Os) (exec cmd)
     (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins) s
        outs)
     (CFG inputTest stateInterp certList ins (NS s (exec cmd))
        (Out s (exec cmd)::outs)) ⇔
   inputTest (P says prop (SOME cmd)) ∧
   CFGInterpret (M,Oi,Os)
     (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins) s
        outs):
   thm
val TRrule1 =
   |- TR (M,Oi,Os) (trap cmd)
     (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins) s
        outs)
     (CFG inputTest stateInterp certList ins (NS s (trap cmd))
        (Out s (trap cmd)::outs)) ⇔
   inputTest (P says prop (SOME cmd)) ∧
   CFGInterpret (M,Oi,Os)
     (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins) s
        outs):
   thm
val UNION_APPEND =
   |- ∀l1 l2. set l1 ∪ set l2 = set (l1 ++ l2):
   thm
val UNZIP =
   |- (UNZIP [] = ([],[])) ∧
   ∀x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l)):
   thm
val UNZIP_MAP =
   |- ∀L. UNZIP L = (MAP FST L,MAP SND L):
   thm
val UNZIP_THM =
   |- (UNZIP [] = ([],[])) ∧
   (UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2))):
   thm
val UNZIP_ZIP =
   |- ∀l1 l2. (LENGTH l1 = LENGTH l2) ⇒ (UNZIP (ZIP (l1,l2)) = (l1,l2)):
   thm
val WF_LIST_PRED =
   |- WF (λL1 L2. ∃h. L2 = h::L1):
   thm
val ZIP =
   |- (ZIP ([],[]) = []) ∧
   ∀x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2):
   thm
val ZIP_DROP =
   |- ∀a b n.
     n ≤ LENGTH a ∧ (LENGTH a = LENGTH b) ⇒
     (ZIP (DROP n a,DROP n b) = DROP n (ZIP (a,b))):
   thm
val ZIP_EQ_NIL =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ((ZIP (l1,l2) = []) ⇔ (l1 = []) ∧ (l2 = [])):
   thm
val ZIP_GENLIST =
   |- ∀l f n.
     (LENGTH l = n) ⇒
     (ZIP (l,GENLIST f n) = GENLIST (λx. (EL x l,f x)) n):
   thm
val ZIP_MAP =
   |- ∀l1 l2 f1 f2.
     (LENGTH l1 = LENGTH l2) ⇒
     (ZIP (MAP f1 l1,l2) = MAP (λp. (f1 (FST p),SND p)) (ZIP (l1,l2))) ∧
     (ZIP (l1,MAP f2 l2) = MAP (λp. (FST p,f2 (SND p))) (ZIP (l1,l2))):
   thm
val ZIP_UNZIP =
   |- ∀l. ZIP (UNZIP l) = l:
   thm
val all_distinct_nub =
   |- ∀l. ALL_DISTINCT (nub l):
   thm
val configuration2_11 =
   |- ∀a0 a1 a2 a3 a4 a5 a6 a7 a0' a1' a2' a3' a4' a5' a6' a7'.
     (CFG2 a0 a1 a2 a3 a4 a5 a6 a7 =
      CFG2 a0' a1' a2' a3' a4' a5' a6' a7') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3') ∧ (a4 = a4') ∧
     (a5 = a5') ∧ (a6 = a6') ∧ (a7 = a7'):
   thm
val configuration2_Axiom =
   |- ∀f.
     ∃fn.
       ∀a0 a1 a2 a3 a4 a5 a6 a7.
         fn (CFG2 a0 a1 a2 a3 a4 a5 a6 a7) = f a0 a1 a2 a3 a4 a5 a6 a7:
   thm
val configuration2_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'configuration2' .
            (∀a0'.
               (∃a0 a1 a2 a3 a4 a5 a6 a7.
                  a0' =
                  (λa0 a1 a2 a3 a4 a5 a6 a7.
                     ind_type$CONSTR 0 (a0,a1,a2,a3,a4,a5,a6,a7)
                       (λn. ind_type$BOTTOM)) a0 a1 a2 a3 a4 a5 a6 a7) ⇒
               'configuration2' a0') ⇒
            'configuration2' a0') rep:
   thm
val configuration2_case_cong =
   |- ∀M M' f.
     (M = M') ∧
     (∀a0 a1 a2 a3 a4 a5 a6 a7.
        (M' = CFG2 a0 a1 a2 a3 a4 a5 a6 a7) ⇒
        (f a0 a1 a2 a3 a4 a5 a6 a7 = f' a0 a1 a2 a3 a4 a5 a6 a7)) ⇒
     (configuration2_CASE M f = configuration2_CASE M' f'):
   thm
val configuration2_case_def =
   |- ∀a0 a1 a2 a3 a4 a5 a6 a7 f.
     configuration2_CASE (CFG2 a0 a1 a2 a3 a4 a5 a6 a7) f =
     f a0 a1 a2 a3 a4 a5 a6 a7:
   thm
val configuration2_induction =
   |- ∀P. (∀f f0 f1 l f2 l0 s l1. P (CFG2 f f0 f1 l f2 l0 s l1)) ⇒ ∀c. P c:
   thm
val configuration2_nchotomy =
   |- ∀cc. ∃f f0 f1 l f2 l0 s l1. cc = CFG2 f f0 f1 l f2 l0 s l1:
   thm
val configuration2_one_one =
   |- ∀a0 a1 a2 a3 a4 a5 a6 a7 a0' a1' a2' a3' a4' a5' a6' a7'.
     (CFG2 a0 a1 a2 a3 a4 a5 a6 a7 =
      CFG2 a0' a1' a2' a3' a4' a5' a6' a7') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3') ∧ (a4 = a4') ∧
     (a5 = a5') ∧ (a6 = a6') ∧ (a7 = a7'):
   thm
val configuration2_size_def =
   |- ∀f f1 f2 f3 f4 f5 f6 f7 a0 a1 a2 a3 a4 a5 a6 a7.
     configuration2_size f f1 f2 f3 f4 f5 f6 f7
       (CFG2 a0 a1 a2 a3 a4 a5 a6 a7) =
     1 +
     (list_size f a3 + (list_size f4 a5 + (f7 a6 + list_size f5 a7))):
   thm
val configuration_11 =
   |- ∀a0 a1 a2 a3 a4 a5 a0' a1' a2' a3' a4' a5'.
     (CFG a0 a1 a2 a3 a4 a5 = CFG a0' a1' a2' a3' a4' a5') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3') ∧ (a4 = a4') ∧
     (a5 = a5'):
   thm
val configuration_Axiom =
   |- ∀f.
     ∃fn.
       ∀a0 a1 a2 a3 a4 a5.
         fn (CFG a0 a1 a2 a3 a4 a5) = f a0 a1 a2 a3 a4 a5:
   thm
val configuration_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'configuration' .
            (∀a0'.
               (∃a0 a1 a2 a3 a4 a5.
                  a0' =
                  (λa0 a1 a2 a3 a4 a5.
                     ind_type$CONSTR 0 (a0,a1,a2,a3,a4,a5)
                       (λn. ind_type$BOTTOM)) a0 a1 a2 a3 a4 a5) ⇒
               'configuration' a0') ⇒
            'configuration' a0') rep:
   thm
val configuration_case_cong =
   |- ∀M M' f.
     (M = M') ∧
     (∀a0 a1 a2 a3 a4 a5.
        (M' = CFG a0 a1 a2 a3 a4 a5) ⇒
        (f a0 a1 a2 a3 a4 a5 = f' a0 a1 a2 a3 a4 a5)) ⇒
     (configuration_CASE M f = configuration_CASE M' f'):
   thm
val configuration_case_def =
   |- ∀a0 a1 a2 a3 a4 a5 f.
     configuration_CASE (CFG a0 a1 a2 a3 a4 a5) f = f a0 a1 a2 a3 a4 a5:
   thm
val configuration_induction =
   |- ∀P. (∀f f0 l l0 s l1. P (CFG f f0 l l0 s l1)) ⇒ ∀c. P c:
   thm
val configuration_nchotomy =
   |- ∀cc. ∃f f0 l l0 s l1. cc = CFG f f0 l l0 s l1:
   thm
val configuration_one_one =
   |- ∀a0 a1 a2 a3 a4 a5 a0' a1' a2' a3' a4' a5'.
     (CFG a0 a1 a2 a3 a4 a5 = CFG a0' a1' a2' a3' a4' a5') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3') ∧ (a4 = a4') ∧
     (a5 = a5'):
   thm
val configuration_size_def =
   |- ∀f f1 f2 f3 f4 f5 a0 a1 a2 a3 a4 a5.
     configuration_size f f1 f2 f3 f4 f5 (CFG a0 a1 a2 a3 a4 a5) =
     1 +
     (list_size (Form_size (inst_size f) f4 f1 f2) a2 +
      (list_size (Form_size (inst_size f) f4 f1 f2) a3 +
       (f5 a4 + list_size f3 a5))):
   thm
val datatype_configuration =
   |- DATATYPE (configuration CFG):
   thm
val datatype_configuration2 =
   |- DATATYPE (configuration2 CFG2):
   thm
val datatype_inst =
   |- DATATYPE (inst SOME NONE):
   thm
val datatype_list =
   |- DATATYPE (list [] CONS):
   thm
val datatype_trType =
   |- DATATYPE (trType discard trap exec):
   thm
val dropWhile_APPEND_EVERY =
   |- ∀P l1 l2. EVERY P l1 ⇒ (dropWhile P (l1 ++ l2) = dropWhile P l2):
   thm
val dropWhile_APPEND_EXISTS =
   |- ∀P l1 l2.
     EXISTS ($~ ∘ P) l1 ⇒
     (dropWhile P (l1 ++ l2) = dropWhile P l1 ++ l2):
   thm
val dropWhile_def =
   |- (∀P. dropWhile P [] = []) ∧
   ∀P h t. dropWhile P (h::t) = if P h then dropWhile P t else h::t:
   thm
val dropWhile_eq_nil =
   |- ∀P ls. (dropWhile P ls = []) ⇔ EVERY P ls:
   thm
val dropWhile_splitAtPki =
   |- ∀P. dropWhile P = splitAtPki (combin$C (K ∘ $~ ∘ P)) (K I):
   thm
val el_append3 =
   |- ∀l1 x l2. EL (LENGTH l1) (l1 ++ [x] ++ l2) = x:
   thm
val every_zip_fst =
   |- ∀l1 l2 P.
     (LENGTH l1 = LENGTH l2) ⇒
     (EVERY (λx. P (FST x)) (ZIP (l1,l2)) ⇔ EVERY P l1):
   thm
val every_zip_snd =
   |- ∀l1 l2 P.
     (LENGTH l1 = LENGTH l2) ⇒
     (EVERY (λx. P (SND x)) (ZIP (l1,l2)) ⇔ EVERY P l2):
   thm
val exists_list_GENLIST =
   |- (∃ls. P ls) ⇔ ∃n f. P (GENLIST f n):
   thm
val inst_11 =
   |- ∀a a'. (SOME a = SOME a') ⇔ (a = a'):
   thm
val inst_Axiom =
   |- ∀f0 f1. ∃fn. (∀a. fn (SOME a) = f0 a) ∧ (fn NONE = f1):
   thm
val inst_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'inst' .
            (∀a0.
               (∃a.
                  a0 =
                  (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM)) a) ∨
               (a0 =
                ind_type$CONSTR (SUC 0) ARB (λn. ind_type$BOTTOM)) ⇒
               'inst' a0) ⇒
            'inst' a0) rep:
   thm
val inst_case_cong =
   |- ∀M M' f v.
     (M = M') ∧ (∀a. (M' = SOME a) ⇒ (f a = f' a)) ∧
     ((M' = NONE) ⇒ (v = v')) ⇒
     (inst_CASE M f v = inst_CASE M' f' v'):
   thm
val inst_case_def =
   |- (∀a f v. inst_CASE (SOME a) f v = f a) ∧ ∀f v. inst_CASE NONE f v = v:
   thm
val inst_distinct =
   |- ∀a. SOME a ≠ NONE:
   thm
val inst_distinct_clauses =
   |- ∀a. SOME a ≠ NONE:
   thm
val inst_induction =
   |- ∀P. (∀c. P (SOME c)) ∧ P NONE ⇒ ∀i. P i:
   thm
val inst_nchotomy =
   |- ∀ii. (∃c. ii = SOME c) ∨ (ii = NONE):
   thm
val inst_one_one =
   |- ∀a a'. (SOME a = SOME a') ⇔ (a = a'):
   thm
val inst_size_def =
   |- (∀f a. inst_size f (SOME a) = 1 + f a) ∧ ∀f. inst_size f NONE = 0:
   thm
val isPREFIX =
   |- (∀l. [] ≼ l ⇔ T) ∧
   ∀h t l. h::t ≼ l ⇔ case l of [] => F | h'::t' => (h = h') ∧ t ≼ t':
   thm
val isPREFIX_THM =
   |- ([] ≼ l ⇔ T) ∧ (h::t ≼ [] ⇔ F) ∧
   (h1::t1 ≼ h2::t2 ⇔ (h1 = h2) ∧ t1 ≼ t2):
   thm
val last_drop =
   |- ∀l n. n < LENGTH l ⇒ (LAST (DROP n l) = LAST l):
   thm
val length_nub_append =
   |- ∀l1 l2.
     LENGTH (nub (l1 ++ l2)) =
     LENGTH (nub l1) + LENGTH (nub (FILTER (λx. ¬MEM x l1) l2)):
   thm
val list_11 =
   |- ∀a0 a1 a0' a1'. (a0::a1 = a0'::a1') ⇔ (a0 = a0') ∧ (a1 = a1'):
   thm
val list_Axiom =
   |- ∀f0 f1. ∃fn. (fn [] = f0) ∧ ∀a0 a1. fn (a0::a1) = f1 a0 a1 (fn a1):
   thm
val list_Axiom_old =
   |- ∀x f. ∃!fn1. (fn1 [] = x) ∧ ∀h t. fn1 (h::t) = f (fn1 t) h t:
   thm
val list_CASES =
   |- ∀l. (l = []) ∨ ∃h t. l = h::t:
   thm
val list_INDUCT =
   |- ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l:
   thm
val list_INDUCT0 =
   |- ∀P. P [] ∧ (∀l. P l ⇒ ∀a. P (a::l)) ⇒ ∀l. P l:
   thm
val list_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'list' .
            (∀a0'.
               (a0' = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
               (∃a0 a1.
                  (a0' =
                   (λa0 a1.
                      ind_type$CONSTR (SUC 0) a0
                        (ind_type$FCONS a1 (λn. ind_type$BOTTOM))) a0
                     a1) ∧ 'list' a1) ⇒
               'list' a0') ⇒
            'list' a0') rep:
   thm
val list_case_compute =
   |- ∀l. list_CASE l b f = if NULL l then b else f (HD l) (TL l):
   thm
val list_case_cong =
   |- ∀M M' v f.
     (M = M') ∧ ((M' = []) ⇒ (v = v')) ∧
     (∀a0 a1. (M' = a0::a1) ⇒ (f a0 a1 = f' a0 a1)) ⇒
     (list_CASE M v f = list_CASE M' v' f'):
   thm
val list_case_def =
   |- (∀v f. list_CASE [] v f = v) ∧
   ∀a0 a1 v f. list_CASE (a0::a1) v f = f a0 a1:
   thm
val list_distinct =
   |- ∀a1 a0. [] ≠ a0::a1:
   thm
val list_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  bool | (TY, TY)fun | ind | TY itself | TY list | num |
                  one | TY option | (TY, TY)prod | TY recspace |
                  TY set | (TY, TY)sum | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT APPEND APPLICATIVE_FAPPLY ARB
  ASSOC Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED CARD CHOICE COMM
  COMPL COND CONS CR CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF
  DISJOINT DIV DIV2 DIVMOD DROP EL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2
  EVERYi EXISTS EXP EXT_POINT F FACT FAIL FCOMM FILTER FIND FINITE FLAT
  FOLDL FOLDL2 FOLDR FRONT FST FUNPOW FUNSET GENLIST GENLIST_AUX GSPEC
  HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_NONE IS_NUM_REP IS_SOME IS_SUM_REP ITSET Id IfCases K LAST LEAST
  LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND
  LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_TO_SET LLEX LRC LUPDATE
  LinearOrder MAP MAP2 MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID NIL
  NONE NOTIN NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND O ODD
  OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE
  OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2
  OPTION_MCOMP OPTREL OPT_MMAP OUTL OUTR OWHILE Order PAD_LEFT PAD_RIGHT
  PERMUTES PI POW PRE PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE
  PROD_SET PSUBSET PreOrder RC RCOMPL RDOM RDOM_DELETE RELPOW
  REL_RESTRICT REMPTY REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV S SC SET_TO_LIST SIGMA SIMP_REC SIMP_REC_REL SING SINGL SN SND
  SNOC SOME STRORD SUBSET SUC SUC_REP SUM SUM_ACC SUM_ALL SUM_IMAGE
  SUM_SET SURJ SWAP StrongLinearOrder StrongOrder T TAKE TC THE TL
  TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UPDATE W WCR WF
  WFP WFREC WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE
  \/ \\ _ inject_number antisymmetric approx bool_size case chooser
  count countable dest_rec diag diamond dropWhile enumerate equiv_on
  equivalence findq iBIT_cases internal_mult inv inv_image invtri
  invtri0 irreflexive isPREFIX itself_case lift2 listRel list_CASE
  list_size literal_case measure mk_rec napp nat_elim__magic ncons nf
  nfoldl nfst nlen nlistrec nmap nnil npair nsnd nub num_CASE
  num_to_pair o one one_CASE one_size option_ABS option_CASE option_REP
  option_size pair_CASE pair_size pair_to_num pairwise partition
  rcdiamond reflexive schroeder_close set some splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total transitive tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  isPREFIX
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  EVERY2             ->  LIST_REL
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  Id                 ->  =
  MEM                -> 
    (λ(h :α) (l :α list). bool$IN h (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val list_induction =
   |- ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l:
   thm
val list_nchotomy =
   |- ∀l. (l = []) ∨ ∃h t. l = h::t:
   thm
val list_size_cong =
   |- ∀M N f f'.
     (M = N) ∧ (∀x. MEM x N ⇒ (f x = f' x)) ⇒
     (list_size f M = list_size f' N):
   thm
val list_size_def =
   |- (∀f. list_size f [] = 0) ∧
   ∀f a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1):
   thm
val list_to_set_diff =
   |- ∀l1 l2. set l2 DIFF set l1 = set (FILTER (λx. ¬MEM x l1) l2):
   thm
val lupdate_append =
   |- ∀x n l1 l2.
     n < LENGTH l1 ⇒ (LUPDATE x n (l1 ++ l2) = LUPDATE x n l1 ++ l2):
   thm
val lupdate_append2 =
   |- ∀v l1 x l2 l3.
     LUPDATE v (LENGTH l1) (l1 ++ [x] ++ l2) = l1 ++ [v] ++ l2:
   thm
val mem_exists_set =
   |- ∀x y l. MEM (x,y) l ⇒ ∃z. (x = FST z) ∧ MEM z l:
   thm
val nub_append =
   |- ∀l1 l2. nub (l1 ++ l2) = nub (FILTER (λx. ¬MEM x l2) l1) ++ nub l2:
   thm
val nub_def =
   |- (nub [] = []) ∧
   ∀x l. nub (x::l) = if MEM x l then nub l else x::nub l:
   thm
val nub_set =
   |- ∀l. set (nub l) = set l:
   thm
val splitAtPki_APPEND =
   |- ∀l1 l2 P k.
     EVERYi (λi. $~ ∘ P i) l1 ∧
     (0 < LENGTH l2 ⇒ P (LENGTH l1) (HD l2)) ⇒
     (splitAtPki P k (l1 ++ l2) = k l1 l2):
   thm
val splitAtPki_EQN =
   |- splitAtPki P k l =
   case OLEAST i. i < LENGTH l ∧ P i (EL i l) of
     NONE => k l []
   | SOME i => k (TAKE i l) (DROP i l):
   thm
val splitAtPki_def =
   |- (∀P k. splitAtPki P k [] = k [] []) ∧
   ∀P k h t.
     splitAtPki P k (h::t) =
     if P 0 h then k [] (h::t)
     else splitAtPki (P ∘ SUC) (λp s. k (h::p) s) t:
   thm
val ssm1_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool |
                  (TY, TY, TY, TY, TY, TY)configuration | (TY, TY)fun |
                  ind | TY inst | TY itself | TY list | num | one |
                  TY option | TY po | (TY, TY)prod | TY recspace |
                  TY set | (TY, TY)sum | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CFG CFGInterpret CHOICE COMM COMPL COND CONS COUNT_LIST
  COUNT_LIST_AUX CR CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF
  DISJOINT DIV DIV2 DIVMOD DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY
  EVERY2 EVERYi EXISTS EXP EXT_POINT Efn F FACT FAIL FCOMM FF FILTER
  FIND FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW
  FUNSET Form_CASE Form_size GENLIST GENLIST_AUX GSPEC GUESS_EXISTS
  GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP
  GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF
  INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT
  INTER INVOL ISL ISR IS_EL IS_NONE IS_NUM_REP IS_PREFIX
  IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST
  IS_SUFFIX IS_SUM_REP ITSET Id IfCases IntLevel_CASE IntLevel_size Jext
  K KS Kripke_CASE Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET
  LEX LINV LINV_OPT LIST_APPLY LIST_BIND LIST_ELEM_COUNT
  LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi LIST_TO_SET LLEX LRC
  LUPDATE Lifn LinearOrder Lsfn MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM
  MIN MIN_SET MOD MODEQ MONOID NIL NONE NOTIN NRC NULL NUMERAL NUMFST
  NUMLEFT NUMRIGHT NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL
  OPTION_APPLY OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND
  OPTION_JOIN OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL
  OUTL OUTR OWHILE Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV S SC SCANL SCANR
  SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL SIMP_REC
  SIMP_REC_REL SING SINGL SN SND SNOC SOME SOME_EL SPLITL SPLITP
  SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TR TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP
  UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder
  WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf
  antisymmetric approx bool_size case chooser configuration_CASE
  configuration_size controls count countable delN dest_rec diag diamond
  discard domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on
  equivalence exec findi findq fupdLast iBIT_cases iLab il imapKS impf
  inst_CASE inst_size internal_mult intpKS inv inv_image invtri invtri0
  irreflexive isPREFIX itself_case jKS lift2 listRel list_CASE list_size
  literal_case lt lte measure meet mk_rec napp nat_elim__magic ncons nf
  nfoldl nfst nlen nlistrec nmap nnil notf npair nsnd nub num_CASE
  num_to_pair o one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orf pair_CASE pair_size pair_to_num
  pairwise partition prod_PO prop quoting rcdiamond reflexive repPO reps
  sLab sat satList says schroeder_close set sl smapKS some speaks_for
  splitAtPki stmarker sum_CASE sum_size symmetric the_fun the_value
  total trType_CASE trType_size transitive trap tri trichotomous tri⁻¹
  unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE list_CASE option_CASE
    sum_CASE num_CASE pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val ssm2_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool |
                  (TY, TY, TY, TY, TY, TY)configuration |
                  (TY, TY, TY, TY, TY, TY, TY, TY)configuration2 |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  num | one | TY option | TY po | (TY, TY)prod |
                  TY recspace | TY set | (TY, TY)sum | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h) configuration2 = (α, β, γ, δ, ε, ζ, η, θ) ssm2$configuration2
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CFG CFG2 CFG2Interpret CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Cong DATATYPE
  DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL EMPTY
  EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Efn F FACT
  FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR FOLDRi
  FRONT FST FUNPOW FUNSET Form_CASE Form_size GENLIST GENLIST_AUX GSPEC
  GUESS_EXISTS GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL
  GUESS_FORALL_GAP GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN
  INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON
  INFINITE INJ INL INR INSERT INTER INVOL ISL ISR IS_EL IS_NONE
  IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN
  IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET Id IfCases IntLevel_CASE
  IntLevel_size Jext K KS Kripke_CASE Kripke_size LAST LASTN LEAST
  LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND
  LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi
  LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn MAP MAP2 MAPi
  MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID NIL NONE NOTIN
  NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O O1 ODD OLEAST
  ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE
  OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2
  OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Order PAD_LEFT
  PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED
  PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW
  PMATCH_ROW_COND PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ
  PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0
  PMATCH_ROW_magic_1 PMATCH_ROW_magic_2 PMATCH_ROW_magic_3
  PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PRE PREFIX PREIMAGE PRIM_REC
  PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE
  Princ_size RC RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV S SC SCANL SCANR
  SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL SIMP_REC
  SIMP_REC_REL SING SINGL SN SND SNOC SOME SOME_EL SPLITL SPLITP
  SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TR TR2 TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP
  UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder
  WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf
  antisymmetric approx bool_size case chooser configuration2_CASE
  configuration2_size configuration_CASE configuration_size controls
  count countable delN dest_rec diag diamond discard domi doms dropWhile
  enumerate eqf eqi eqn eqs equiv_on equivalence exec findi findq
  fupdLast iBIT_cases iLab il imapKS impf inst_CASE inst_size
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS lift2 listRel list_CASE list_size literal_case lt lte
  measure meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair nsnd nub num_CASE num_to_pair o one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf pair_CASE pair_size pair_to_num pairwise partition
  prod_PO prop quoting rcdiamond reflexive repPO reps sLab sat satList
  says schroeder_close set sl smapKS some speaks_for splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total trType_CASE
  trType_size transitive trap tri trichotomous tri⁻¹ unint univ
  wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration2_CASE configuration_CASE trType_CASE inst_CASE
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
type thm
val trType_11 =
   |- (∀a a'. (trap a = trap a') ⇔ (a = a')) ∧
   ∀a a'. (exec a = exec a') ⇔ (a = a'):
   thm
val trType_Axiom =
   |- ∀f0 f1 f2.
     ∃fn.
       (fn discard = f0) ∧ (∀a. fn (trap a) = f1 a) ∧
       ∀a. fn (exec a) = f2 a:
   thm
val trType_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'trType' .
            (∀a0.
               (a0 = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
               (∃a.
                  a0 =
                  (λa. ind_type$CONSTR (SUC 0) a (λn. ind_type$BOTTOM))
                    a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC 0)) a
                       (λn. ind_type$BOTTOM)) a) ⇒
               'trType' a0) ⇒
            'trType' a0) rep:
   thm
val trType_case_cong =
   |- ∀M M' v f f1.
     (M = M') ∧ ((M' = discard) ⇒ (v = v')) ∧
     (∀a. (M' = trap a) ⇒ (f a = f' a)) ∧
     (∀a. (M' = exec a) ⇒ (f1 a = f1' a)) ⇒
     (trType_CASE M v f f1 = trType_CASE M' v' f' f1'):
   thm
val trType_case_def =
   |- (∀v f f1. trType_CASE discard v f f1 = v) ∧
   (∀a v f f1. trType_CASE (trap a) v f f1 = f a) ∧
   ∀a v f f1. trType_CASE (exec a) v f f1 = f1 a:
   thm
val trType_distinct =
   |- (∀a. discard ≠ trap a) ∧ (∀a. discard ≠ exec a) ∧
   ∀a' a. trap a ≠ exec a':
   thm
val trType_distinct_clauses =
   |- (∀a. discard ≠ trap a) ∧ (∀a. discard ≠ exec a) ∧
   ∀a' a. trap a ≠ exec a':
   thm
val trType_induction =
   |- ∀P. P discard ∧ (∀c. P (trap c)) ∧ (∀c. P (exec c)) ⇒ ∀t. P t:
   thm
val trType_nchotomy =
   |- ∀tt. (tt = discard) ∨ (∃c. tt = trap c) ∨ ∃c. tt = exec c:
   thm
val trType_one_one =
   |- (∀a a'. (trap a = trap a') ⇔ (a = a')) ∧
   ∀a a'. (exec a = exec a') ⇔ (a = a'):
   thm
val trType_size_def =
   |- (∀f. trType_size f discard = 0) ∧
   (∀f a. trType_size f (trap a) = 1 + f a) ∧
   ∀f a. trType_size f (exec a) = 1 + f a:
   thm
> val Alice_Operator_rejected_lemma =
   |- ¬inputOKr1
      (Name (Staff Alice) quoting Name (Role Operator) says
       prop (SOME cmd)):
   thm
val Bob_Commander_rejected_lemma =
   |- ¬inputOKr1
      (Name (Staff Bob) quoting Name (Role Commander) says
       prop (SOME cmd)):
   thm
val Bob_TR2_iff_TR_privcmd =
   |- ∀NS Out M Oi Os.
     TR2 (M,Oi,Os) (exec (PR privcmd))
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Operator) says
                    prop (SOME (PR privcmd)))))::ins2) s outs)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp ins2
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd) ins
          (NS s (exec (PR privcmd))) (Out s (exec (PR privcmd))::outs)):
   thm
val Carol_all_roles_rejected_lemma =
   |- ¬inputOKr1
      (Name (Staff Carol) quoting Name (Role role) says prop (SOME cmd)):
   thm
val Operator_Bob_exec_privcmd_justified_thm =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
          (Name (Staff Bob) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs)
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr1
       (Name (Staff Bob) quoting Name (Role Operator) says
        prop (SOME (PR privcmd))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
          (Name (Staff Bob) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs) ∧
     (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_Bob_exec_privcmd_justified_thm_r2 =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr2
       (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
        prop (SOME (PR privcmd))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs) ∧
     (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_Bob_privcmd_exec_privcmd_justified_thm =
   |- ∀NS Out M Oi Os.
     TR2 (M,Oi,Os) (exec (PR privcmd))
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (MSG Bob (Order Operator (PR privcmd))
             (sign (privK Bob)
                (hash (SOME (Order Operator (PR privcmd)))))::ins) s
          outs)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr2
       (MsgInterpret
          (MSG Bob (Order Operator (PR privcmd))
             (sign (privK Bob)
                (hash (SOME (Order Operator (PR privcmd))))))) ∧
     CFG2Interpret (M,Oi,Os)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (MSG Bob (Order Operator (PR privcmd))
             (sign (privK Bob)
                (hash (SOME (Order Operator (PR privcmd)))))::ins) s
          outs) ∧ (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_Bob_privcmd_exec_privcmd_justified_with_refinements_thm =
   |- ∀NS Out M Oi Os.
     TR2 (M,Oi,Os) (exec (PR privcmd))
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Operator) says
                    prop (SOME (PR privcmd)))))::ins) s outs)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr2
       (MsgInterpret
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Operator) says
                    prop (SOME (PR privcmd))))))) ∧
     CFG2Interpret (M,Oi,Os)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Operator) says
                    prop (SOME (PR privcmd)))))::ins) s outs) ∧
     (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_exec_privcmd_justified_thm =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs)
       (CFG inputOK SM0StateInterp (certs npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOK (Name (Role Operator) says prop (SOME (PR privcmd))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs) ∧ (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_justified_privcmd_exec_thm =
   |- ∀NS Out M Oi Os cmd npriv privcmd ins s outs.
     inputOK (Name (Role Operator) says prop (SOME (PR privcmd))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs) ⇒
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs)
       (CFG inputOK SM0StateInterp (certs npriv privcmd) ins
          (NS s (exec (PR privcmd))) (Out s (exec (PR privcmd))::outs)):
   thm
val Operator_mapSM0inputOperatorBob_exec_privcmd_justified_thm =
   |- ∀s privcmd outs npriv ins NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
          (mapSM0inputOperatorBob
             (Name (Role Operator) says prop (SOME (PR privcmd)))::ins)
          s outs)
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr1
       (mapSM0inputOperatorBob
          (Name (Role Operator) says prop (SOME (PR privcmd)))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
          (mapSM0inputOperatorBob
             (Name (Role Operator) says prop (SOME (PR privcmd)))::ins)
          s outs) ∧ (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_mapSM0r1input_exec_privcmd_justifed_thm =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (mapSM0r1input
             (mapSM0inputOperatorBob
                (Name (Role Operator) says prop (SOME (PR privcmd))))::
               ins) s outs)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr2
       (mapSM0r1input
          (mapSM0inputOperatorBob
             (Name (Role Operator) says prop (SOME (PR privcmd))))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (mapSM0r1input
             (mapSM0inputOperatorBob
                (Name (Role Operator) says prop (SOME (PR privcmd))))::
               ins) s outs) ∧ (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_privcmd_lemma =
   |- CFGInterpret (M,Oi,Os)
     (CFG inputOK SM0StateInterp (certs npriv privcmd)
        (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
        outs) ⇒
   (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_privcmd_verified_thm =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs)
       (CFG inputOK SM0StateInterp (certs npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇒
     (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val SM0StateInterp_def =
   |- ∀state. SM0StateInterp state = TT:
   thm
val SM0_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | command |
                  (TY, TY, TY, TY, TY, TY)configuration | TY digest |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  npriv | num | one | TY option | output | TY pKey |
                  TY po | principal | privcmd | (TY, TY)prod |
                  TY recspace | role | TY set | staff | state |
                  (TY, TY)sum | symKey | TY symMsg | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander
  Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL
  EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea
  Efn Es F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL
  FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS KeyA KeyS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  Machine NIL NONE NOTIN NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT
  NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY
  OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN
  OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR
  OWHILE Operator Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PR PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV Role S SC SCANL
  SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL
  SIMP_REC SIMP_REC_REL SING SINGL SM0StateInterp SM0ns SM0out SN SND
  SNOC SOME SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TT TYPE_DEFINITION UNCURRY UNION
  UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC
  WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certs chooser
  command_CASE command_size configuration_CASE configuration_size
  controls count countable deciphP deciphS delN dest_rec diag diamond
  digest_CASE digest_size discard domi doms dropWhile enumerate eqf eqi
  eqn eqs equiv_on equivalence exec findi findq fupdLast hash iBIT_cases
  iLab il imapKS impf inputOK inst_CASE inst_size internal_mult intpKS
  inv inv_image invtri invtri0 irreflexive isPREFIX itself_case jKS
  launch lift2 listRel list_CASE list_size literal_case lt lte measure
  meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen nlistrec
  nmap nnil notf npair npriv2num npriv_CASE npriv_size nsnd nub
  num2npriv num2output num2privcmd num2role num2staff num2state num_CASE
  num_to_pair o off on one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orf output2num output_CASE
  output_size pKey_CASE pKey_size pair_CASE pair_size pair_to_num
  pairwise partition principal_CASE principal_size privK privcmd2num
  privcmd_CASE privcmd_size prod_PO prop pubK quoting rcdiamond
  reflexive repPO reps reset role2num role_CASE role_size sLab sat
  satList says schroeder_close set sign signVerify sl smapKS some
  speaks_for splitAtPki staff2num staff_CASE staff_size state2num
  state_CASE state_size status stmarker sum_CASE sum_size sym
  symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric the_fun
  the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE output_CASE state_CASE
    command_CASE npriv_CASE privcmd_CASE principal_CASE staff_CASE
    role_CASE authority_CASE digest_CASE asymMsg_CASE pKey_CASE
    symMsg_CASE symKey_CASE list_CASE option_CASE sum_CASE num_CASE
    pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val SM0ns_def =
   |- (SM0ns STBY (exec (PR reset)) = STBY) ∧
   (SM0ns STBY (exec (PR launch)) = ACTIVE) ∧
   (SM0ns STBY (exec (NP status)) = STBY) ∧
   (SM0ns ACTIVE (exec (PR reset)) = STBY) ∧
   (SM0ns ACTIVE (exec (PR launch)) = ACTIVE) ∧
   (SM0ns ACTIVE (exec (NP status)) = ACTIVE) ∧
   (SM0ns STBY (trap (PR reset)) = STBY) ∧
   (SM0ns STBY (trap (PR launch)) = STBY) ∧
   (SM0ns STBY (trap (NP status)) = STBY) ∧
   (SM0ns ACTIVE (trap (PR reset)) = ACTIVE) ∧
   (SM0ns ACTIVE (trap (PR launch)) = ACTIVE) ∧
   (SM0ns ACTIVE (trap (NP status)) = ACTIVE) ∧
   (SM0ns STBY discard = STBY) ∧ (SM0ns ACTIVE discard = ACTIVE):
   thm
val SM0ns_ind =
   |- ∀P.
     P STBY (exec (PR reset)) ∧ P STBY (exec (PR launch)) ∧
     P STBY (exec (NP status)) ∧ P ACTIVE (exec (PR reset)) ∧
     P ACTIVE (exec (PR launch)) ∧ P ACTIVE (exec (NP status)) ∧
     P STBY (trap (PR reset)) ∧ P STBY (trap (PR launch)) ∧
     P STBY (trap (NP status)) ∧ P ACTIVE (trap (PR reset)) ∧
     P ACTIVE (trap (PR launch)) ∧ P ACTIVE (trap (NP status)) ∧
     P STBY discard ∧ P ACTIVE discard ⇒
     ∀v v1. P v v1:
   thm
val SM0out_def =
   |- (SM0out STBY (exec (PR reset)) = off) ∧
   (SM0out STBY (exec (PR launch)) = on) ∧
   (SM0out STBY (exec (NP status)) = off) ∧
   (SM0out ACTIVE (exec (PR reset)) = off) ∧
   (SM0out ACTIVE (exec (PR launch)) = on) ∧
   (SM0out ACTIVE (exec (NP status)) = on) ∧
   (SM0out STBY (trap (PR reset)) = off) ∧
   (SM0out STBY (trap (PR launch)) = off) ∧
   (SM0out STBY (trap (NP status)) = off) ∧
   (SM0out ACTIVE (trap (PR reset)) = on) ∧
   (SM0out ACTIVE (trap (PR launch)) = on) ∧
   (SM0out ACTIVE (trap (NP status)) = on) ∧
   (SM0out STBY discard = off) ∧ (SM0out ACTIVE discard = on):
   thm
val SM0out_ind =
   |- ∀P.
     P STBY (exec (PR reset)) ∧ P STBY (exec (PR launch)) ∧
     P STBY (exec (NP status)) ∧ P ACTIVE (exec (PR reset)) ∧
     P ACTIVE (exec (PR launch)) ∧ P ACTIVE (exec (NP status)) ∧
     P STBY (trap (PR reset)) ∧ P STBY (trap (PR launch)) ∧
     P STBY (trap (NP status)) ∧ P ACTIVE (trap (PR reset)) ∧
     P ACTIVE (trap (PR launch)) ∧ P ACTIVE (trap (NP status)) ∧
     P STBY discard ∧ P ACTIVE discard ⇒
     ∀v v1. P v v1:
   thm
val SM0r1_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | command |
                  (TY, TY, TY, TY, TY, TY)configuration | TY digest |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  npriv | num | one | TY option | output | TY pKey |
                  TY po | principal | privcmd | (TY, TY)prod |
                  TY recspace | role | TY set | staff | state |
                  (TY, TY)sum | symKey | TY symMsg | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander
  Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL
  EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea
  Efn Es F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL
  FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS KeyA KeyS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  Machine NIL NONE NOTIN NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT
  NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY
  OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN
  OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR
  OWHILE Operator Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PR PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV Role S SC SCANL
  SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL
  SIMP_REC SIMP_REC_REL SING SINGL SM0StateInterp SM0ns SM0out SN SND
  SNOC SOME SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TT TYPE_DEFINITION UNCURRY UNION
  UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC
  WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certs certsr1 chooser
  command_CASE command_size configuration_CASE configuration_size
  controls count countable deciphP deciphS delN dest_rec diag diamond
  digest_CASE digest_size discard domi doms dropWhile enumerate eqf eqi
  eqn eqs equiv_on equivalence exec findi findq fupdLast hash iBIT_cases
  iLab il imapKS impf inputOK inputOKr1 inst_CASE inst_size
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS launch lift2 listRel list_CASE list_size literal_case
  lt lte mapSM0inputOperatorBob measure meet mk_rec napp nat_elim__magic
  ncons nf nfoldl nfst nlen nlistrec nmap nnil notf npair npriv2num
  npriv_CASE npriv_size nsnd nub num2npriv num2output num2privcmd
  num2role num2staff num2state num_CASE num_to_pair o off on one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf output2num output_CASE output_size pKey_CASE pKey_size
  pair_CASE pair_size pair_to_num pairwise partition principal_CASE
  principal_size privK privcmd2num privcmd_CASE privcmd_size prod_PO
  prop pubK quoting rcdiamond reflexive repPO reps reset role2num
  role_CASE role_size sLab sat satList says schroeder_close set sign
  signVerify sl smapKS some speaks_for splitAtPki staff2num staff_CASE
  staff_size state2num state_CASE state_size status stmarker sum_CASE
  sum_size sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric
  the_fun the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE output_CASE state_CASE
    command_CASE npriv_CASE privcmd_CASE principal_CASE staff_CASE
    role_CASE authority_CASE digest_CASE asymMsg_CASE pKey_CASE
    symMsg_CASE symKey_CASE list_CASE option_CASE sum_CASE num_CASE
    pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val SM0r2_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | command |
                  (TY, TY, TY, TY, TY, TY)configuration | TY digest |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  npriv | num | one | TY option | output | TY pKey |
                  TY po | principal | privcmd | (TY, TY)prod |
                  TY recspace | role | TY set | staff | state |
                  (TY, TY)sum | symKey | TY symMsg | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander
  Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL
  EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea
  Efn Es F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL
  FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS KeyA KeyS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  Machine NIL NONE NOTIN NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT
  NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY
  OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN
  OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR
  OWHILE Operator Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PR PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV Role S SC SCANL
  SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL
  SIMP_REC SIMP_REC_REL SING SINGL SM0StateInterp SM0ns SM0out SN SND
  SNOC SOME SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TT TYPE_DEFINITION UNCURRY UNION
  UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC
  WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certs certsr1 certsr2
  certsr2root certsr2signed chooser command_CASE command_size
  configuration_CASE configuration_size controls count countable deciphP
  deciphS delN dest_rec diag diamond digest_CASE digest_size discard
  domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on equivalence
  exec findi findq fupdLast hash iBIT_cases iLab il imapKS impf inputOK
  inputOKr1 inputOKr2 inst_CASE inst_size internal_mult intpKS inv
  inv_image invtri invtri0 irreflexive isPREFIX itself_case jKS launch
  lift2 listRel list_CASE list_size literal_case lt lte
  mapSM0inputOperatorBob mapSM0r1input measure meet mk_rec napp
  nat_elim__magic ncons nf nfoldl nfst nlen nlistrec nmap nnil notf
  npair npriv2num npriv_CASE npriv_size nsnd nub num2npriv num2output
  num2privcmd num2role num2staff num2state num_CASE num_to_pair o off on
  one one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf output2num output_CASE output_size pKey_CASE pKey_size
  pair_CASE pair_size pair_to_num pairwise partition principal_CASE
  principal_size privK privcmd2num privcmd_CASE privcmd_size prod_PO
  prop pubK quoting rcdiamond reflexive repPO reps reset role2num
  role_CASE role_size sLab sat satList says schroeder_close set sign
  signVerify sl smapKS some speaks_for splitAtPki staff2num staff_CASE
  staff_size state2num state_CASE state_size status stmarker sum_CASE
  sum_size sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric
  the_fun the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE output_CASE state_CASE
    command_CASE npriv_CASE privcmd_CASE principal_CASE staff_CASE
    role_CASE authority_CASE digest_CASE asymMsg_CASE pKey_CASE
    symMsg_CASE symKey_CASE list_CASE option_CASE sum_CASE num_CASE
    pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val SM0r3_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | (TY, TY)certificate | command |
                  (TY, TY, TY, TY, TY, TY)configuration |
                  (TY, TY, TY, TY, TY, TY, TY, TY)configuration2 |
                  TY digest | (TY, TY)fun | inMsg | ind | TY inst |
                  TY itself | TY list | npriv | num | one | TY option |
                  order | output | TY pKey | TY po | principal |
                  privcmd | (TY, TY)prod | TY recspace | role | TY set |
                  staff | state | (TY, TY)sum | symKey | TY symMsg |
                  TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  ('a, 'b) certificate = (α, β) certStructure$certificate
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h) configuration2 = (α, β, γ, δ, ε, ζ, η, θ) ssm2$configuration2
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  inMsg = inMsg$inMsg                                    
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  order = inMsg$order                                    
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFG2 CFG2Interpret
  CFGInterpret CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Carol Commander Cong DATATYPE DELETE DFUNSET DIFF DISJOINT
  DIV DIV2 DIVMOD DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2
  EVERYi EXISTS EXP EXT_POINT Ea Efn Es F FACT FAIL FCOMM FF FILTER FIND
  FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET
  Form_CASE Form_size GENLIST GENLIST_AUX GSPEC GUESS_EXISTS
  GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP
  GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF
  INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT
  INTER INVOL ISL ISR IS_EL IS_NONE IS_NUM_REP IS_PREFIX
  IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST
  IS_SUFFIX IS_SUM_REP ITSET Id IfCases IntLevel_CASE IntLevel_size Jext
  K KS KeyA KeyS Kripke_CASE Kripke_size LAST LASTN LEAST LEFT_ID LEN
  LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND LIST_ELEM_COUNT
  LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi LIST_TO_SET LLEX LRC
  LUPDATE Lifn LinearOrder Lsfn MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM
  MIN MIN_SET MOD MODEQ MONOID MSG Machine MsgInterpret NIL NONE NOTIN
  NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O O1 ODD
  OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE
  OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2
  OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Operator Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PR PRE
  PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET
  PSUBSET PreOrder Princ_CASE Princ_size RC RCOMPL RCert RDOM
  RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV Role S SC SCANL SCANR SCert SEG SET_TO_LIST SIGMA
  SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING
  SINGL SM0StateInterp SM0ns SM0out SN SND SNOC SOME SOME_EL SPLITL
  SPLITP SPLITP_AUX SPLITR STBY STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size Staff StrongLinearOrder StrongOrder Subset_PO T TAKE TC
  THE TL TL_T TR TR2 TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT
  UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE
  WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certificateInterpret
  certificate_CASE certificate_size certificatesr3 certs certsr1 certsr2
  certsr2root certsr2signed checkMsg checkcert chooser command_CASE
  command_size configuration2_CASE configuration2_size
  configuration_CASE configuration_size controls count countable deciphP
  deciphS delN dest_rec diag diamond digest_CASE digest_size discard
  domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on equivalence
  exec findi findq fupdLast hash iBIT_cases iLab il imapKS impf
  inMsg_CASE inMsg_size inputOK inputOKr1 inputOKr2 inst_CASE inst_size
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS launch lift2 listRel list_CASE list_size literal_case
  lt lte mapSM0inputOperatorBob mapSM0r1input measure meet mkRCert
  mkSCert mk_rec mkinMsg napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair npriv2num npriv_CASE npriv_size nsnd nub
  num2npriv num2output num2privcmd num2role num2staff num2state num_CASE
  num_to_pair o off on one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orderInterpret order_CASE
  order_size orf output2num output_CASE output_size pKey_CASE pKey_size
  pair_CASE pair_size pair_to_num pairwise partition principal_CASE
  principal_size privK privcmd2num privcmd_CASE privcmd_size prod_PO
  prop pubK quoting rcdiamond reflexive repPO reps reset role2num
  role_CASE role_size sLab sat satList says schroeder_close set sign
  signVerify sl smapKS some speaks_for splitAtPki staff2num staff_CASE
  staff_size state2num state_CASE state_size status stmarker sum_CASE
  sum_size sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric
  the_fun the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  Order              ->  inMsg$Order relation$Order
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    certificate_CASE inMsg_CASE order_CASE configuration2_CASE
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE output_CASE state_CASE
    command_CASE npriv_CASE privcmd_CASE principal_CASE staff_CASE
    role_CASE authority_CASE digest_CASE asymMsg_CASE pKey_CASE
    symMsg_CASE symKey_CASE list_CASE option_CASE sum_CASE num_CASE
    pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val authority_11 =
   |- ∀a a'. (ca a = ca a') ⇔ (a = a'):
   thm
val authority_Axiom =
   |- ∀f. ∃fn. ∀a. fn (ca a) = f a:
   thm
val authority_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'authority' .
            (∀a0.
               (∃a.
                  a0 =
                  (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM)) a) ⇒
               'authority' a0) ⇒
            'authority' a0) rep:
   thm
val authority_case_cong =
   |- ∀M M' f.
     (M = M') ∧ (∀a. (M' = ca a) ⇒ (f a = f' a)) ⇒
     (authority_CASE M f = authority_CASE M' f'):
   thm
val authority_case_def =
   |- ∀a f. authority_CASE (ca a) f = f a:
   thm
val authority_induction =
   |- ∀P. (∀n. P (ca n)) ⇒ ∀a. P a:
   thm
val authority_nchotomy =
   |- ∀aa. ∃n. aa = ca n:
   thm
val authority_one_one =
   |- ∀a a'. (ca a = ca a') ⇔ (a = a'):
   thm
val authority_size_def =
   |- ∀a. authority_size (ca a) = 1 + a:
   thm
val certificatesr3_certsr2_map_thm =
   |- ∀npriv privcmd.
     MAP certificateInterpret (certificatesr3 npriv privcmd) =
     certsr2 npriv privcmd:
   thm
val certificatesr3_def =
   |- ∀npriv privcmd.
     certificatesr3 npriv privcmd =
     MAP mkRCert (certsr1 npriv privcmd ++ certsr2root npriv privcmd) ++
     MAP (mkSCert (ca 0)) (certsr2signed npriv privcmd):
   thm
val certs_def =
   |- ∀npriv privcmd.
     certs npriv privcmd =
     [Name (Role Operator) controls prop (SOME (NP npriv));
      Name (Role Operator) controls prop (SOME (PR privcmd));
      Name (Role Commander) controls prop (SOME (NP npriv));
      Name (Role Commander) says prop (SOME (PR privcmd)) impf
      prop NONE]:
   thm
val certsr1_def =
   |- ∀npriv privcmd.
     certsr1 npriv privcmd =
     certs npriv privcmd ++
     [reps (Name (Staff Alice)) (Name (Role Commander))
        (prop (SOME (NP npriv)));
      reps (Name (Staff Bob)) (Name (Role Operator))
        (prop (SOME (PR privcmd)));
      reps (Name (Staff Bob)) (Name (Role Operator))
        (prop (SOME (NP npriv)))]:
   thm
val certsr2_def =
   |- ∀npriv privcmd.
     certsr2 npriv privcmd =
     certsr1 npriv privcmd ++ certsr2root npriv privcmd ++
     certsr2signed npriv privcmd:
   thm
val certsr2root_def =
   |- ∀npriv privcmd.
     certsr2root npriv privcmd =
     [Name (KeyA (pubK (ca 0))) speaks_for Name (Authority (ca 0));
      Name (Authority (ca 0)) controls
      Name (KeyS (pubK Bob)) speaks_for Name (Staff Bob);
      Name (Authority (ca 0)) controls
      Name (KeyS (pubK Alice)) speaks_for Name (Staff Alice)]:
   thm
val certsr2signed_def =
   |- ∀npriv privcmd.
     certsr2signed npriv privcmd =
     [Name (KeyA (pubK (ca 0))) says
      Name (KeyS (pubK Bob)) speaks_for Name (Staff Bob);
      Name (KeyA (pubK (ca 0))) says
      Name (KeyS (pubK Alice)) speaks_for Name (Staff Alice)]:
   thm
val datatype_authority =
   |- DATATYPE (authority ca):
   thm
val datatype_principal =
   |- DATATYPE (principal Staff Authority Role KeyS KeyA Machine):
   thm
val datatype_role =
   |- DATATYPE (role Commander Operator):
   thm
val datatype_staff =
   |- DATATYPE (staff Alice Bob Carol):
   thm
val inputOK_TT_reject_lemma =
   |- ¬inputOK TT:
   thm
val inputOK_cmd_reject_lemma =
   |- ∀cmd. ¬inputOK (prop (SOME cmd)):
   thm
val inputOK_def =
   |- (inputOK (Name (Role Operator) says prop (SOME cmd)) ⇔ T) ∧
   (inputOK (Name (Role Commander) says prop (SOME cmd)) ⇔ T) ∧
   (inputOK TT ⇔ F) ∧ (inputOK FF ⇔ F) ∧ (inputOK (prop v) ⇔ F) ∧
   (inputOK (notf v1) ⇔ F) ∧ (inputOK (v2 andf v3) ⇔ F) ∧
   (inputOK (v4 orf v5) ⇔ F) ∧ (inputOK (v6 impf v7) ⇔ F) ∧
   (inputOK (v8 eqf v9) ⇔ F) ∧ (inputOK (v10 says TT) ⇔ F) ∧
   (inputOK (v10 says FF) ⇔ F) ∧
   (inputOK (Name (Staff v144) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name (Authority v145) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name (KeyS v147) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name (KeyA v148) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name (Machine v149) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name v132 says prop NONE) ⇔ F) ∧
   (inputOK (v133 meet v134 says prop v66) ⇔ F) ∧
   (inputOK (v135 quoting v136 says prop v66) ⇔ F) ∧
   (inputOK (v10 says notf v67) ⇔ F) ∧
   (inputOK (v10 says (v68 andf v69)) ⇔ F) ∧
   (inputOK (v10 says (v70 orf v71)) ⇔ F) ∧
   (inputOK (v10 says (v72 impf v73)) ⇔ F) ∧
   (inputOK (v10 says (v74 eqf v75)) ⇔ F) ∧
   (inputOK (v10 says v76 says v77) ⇔ F) ∧
   (inputOK (v10 says v78 speaks_for v79) ⇔ F) ∧
   (inputOK (v10 says v80 controls v81) ⇔ F) ∧
   (inputOK (v10 says reps v82 v83 v84) ⇔ F) ∧
   (inputOK (v10 says v85 domi v86) ⇔ F) ∧
   (inputOK (v10 says v87 eqi v88) ⇔ F) ∧
   (inputOK (v10 says v89 doms v90) ⇔ F) ∧
   (inputOK (v10 says v91 eqs v92) ⇔ F) ∧
   (inputOK (v10 says v93 eqn v94) ⇔ F) ∧
   (inputOK (v10 says v95 lte v96) ⇔ F) ∧
   (inputOK (v10 says v97 lt v98) ⇔ F) ∧
   (inputOK (v12 speaks_for v13) ⇔ F) ∧
   (inputOK (v14 controls v15) ⇔ F) ∧ (inputOK (reps v16 v17 v18) ⇔ F) ∧
   (inputOK (v19 domi v20) ⇔ F) ∧ (inputOK (v21 eqi v22) ⇔ F) ∧
   (inputOK (v23 doms v24) ⇔ F) ∧ (inputOK (v25 eqs v26) ⇔ F) ∧
   (inputOK (v27 eqn v28) ⇔ F) ∧ (inputOK (v29 lte v30) ⇔ F) ∧
   (inputOK (v31 lt v32) ⇔ F):
   thm
val inputOK_ind =
   |- ∀P.
     (∀cmd. P (Name (Role Operator) says prop (SOME cmd))) ∧
     (∀cmd. P (Name (Role Commander) says prop (SOME cmd))) ∧ P TT ∧
     P FF ∧ (∀v. P (prop v)) ∧ (∀v1. P (notf v1)) ∧
     (∀v2 v3. P (v2 andf v3)) ∧ (∀v4 v5. P (v4 orf v5)) ∧
     (∀v6 v7. P (v6 impf v7)) ∧ (∀v8 v9. P (v8 eqf v9)) ∧
     (∀v10. P (v10 says TT)) ∧ (∀v10. P (v10 says FF)) ∧
     (∀v144 v142. P (Name (Staff v144) says prop (SOME v142))) ∧
     (∀v145 v142. P (Name (Authority v145) says prop (SOME v142))) ∧
     (∀v147 v142. P (Name (KeyS v147) says prop (SOME v142))) ∧
     (∀v148 v142. P (Name (KeyA v148) says prop (SOME v142))) ∧
     (∀v149 v142. P (Name (Machine v149) says prop (SOME v142))) ∧
     (∀v132. P (Name v132 says prop NONE)) ∧
     (∀v133 v134 v66. P (v133 meet v134 says prop v66)) ∧
     (∀v135 v136 v66. P (v135 quoting v136 says prop v66)) ∧
     (∀v10 v67. P (v10 says notf v67)) ∧
     (∀v10 v68 v69. P (v10 says (v68 andf v69))) ∧
     (∀v10 v70 v71. P (v10 says (v70 orf v71))) ∧
     (∀v10 v72 v73. P (v10 says (v72 impf v73))) ∧
     (∀v10 v74 v75. P (v10 says (v74 eqf v75))) ∧
     (∀v10 v76 v77. P (v10 says v76 says v77)) ∧
     (∀v10 v78 v79. P (v10 says v78 speaks_for v79)) ∧
     (∀v10 v80 v81. P (v10 says v80 controls v81)) ∧
     (∀v10 v82 v83 v84. P (v10 says reps v82 v83 v84)) ∧
     (∀v10 v85 v86. P (v10 says v85 domi v86)) ∧
     (∀v10 v87 v88. P (v10 says v87 eqi v88)) ∧
     (∀v10 v89 v90. P (v10 says v89 doms v90)) ∧
     (∀v10 v91 v92. P (v10 says v91 eqs v92)) ∧
     (∀v10 v93 v94. P (v10 says v93 eqn v94)) ∧
     (∀v10 v95 v96. P (v10 says v95 lte v96)) ∧
     (∀v10 v97 v98. P (v10 says v97 lt v98)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val inputOK_primitive_def =
   |- inputOK =
   WFREC (@R. WF R)
     (λinputOK a.
        case a of
          TT => I F
        | FF => I F
        | prop v33 => I F
        | notf v34 => I F
        | v35 andf v36 => I F
        | v37 orf v38 => I F
        | v39 impf v40 => I F
        | v41 eqf v42 => I F
        | v43 says TT => I F
        | v43 says FF => I F
        | Name (Staff v150) says prop (SOME v143) => I F
        | Name (Authority v151) says prop (SOME v143) => I F
        | Name (Role v152) says prop (SOME v143) => I T
        | Name (KeyS v153) says prop (SOME v143) => I F
        | Name (KeyA v154) says prop (SOME v143) => I F
        | Name (Machine v155) says prop (SOME v143) => I F
        | Name v137 says prop NONE => I F
        | v138 meet v139 says prop v99 => I F
        | v140 quoting v141 says prop v99 => I F
        | v43 says notf v100 => I F
        | v43 says (v101 andf v102) => I F
        | v43 says (v103 orf v104) => I F
        | v43 says (v105 impf v106) => I F
        | v43 says (v107 eqf v108) => I F
        | v43 says v109 says v110 => I F
        | v43 says v111 speaks_for v112 => I F
        | v43 says v113 controls v114 => I F
        | v43 says reps v115 v116 v117 => I F
        | v43 says v118 domi v119 => I F
        | v43 says v120 eqi v121 => I F
        | v43 says v122 doms v123 => I F
        | v43 says v124 eqs v125 => I F
        | v43 says v126 eqn v127 => I F
        | v43 says v128 lte v129 => I F
        | v43 says v130 lt v131 => I F
        | v45 speaks_for v46 => I F
        | v47 controls v48 => I F
        | reps v49 v50 v51 => I F
        | v52 domi v53 => I F
        | v54 eqi v55 => I F
        | v56 doms v57 => I F
        | v58 eqs v59 => I F
        | v60 eqn v61 => I F
        | v62 lte v63 => I F
        | v64 lt v65 => I F):
   thm
val inputOK_staff_rejected_lemma =
   |- ∀P cmd. ¬inputOK (Name (Staff P) says prop (SOME cmd)):
   thm
val inputOKr1_TT_reject_lemma =
   |- ¬inputOKr1 TT:
   thm
val inputOKr1_cmd_reject_lemma =
   |- ∀cmd. ¬inputOKr1 (prop (SOME cmd)):
   thm
val inputOKr1_def =
   |- (inputOKr1
      (Name (Staff Bob) quoting Name (Role Operator) says
       prop (SOME cmd)) ⇔ T) ∧
   (inputOKr1
      (Name (Staff Alice) quoting Name (Role Commander) says
       prop (SOME cmd)) ⇔ T) ∧ (inputOKr1 TT ⇔ F) ∧ (inputOKr1 FF ⇔ F) ∧
   (inputOKr1 (prop v) ⇔ F) ∧ (inputOKr1 (notf v1) ⇔ F) ∧
   (inputOKr1 (v2 andf v3) ⇔ F) ∧ (inputOKr1 (v4 orf v5) ⇔ F) ∧
   (inputOKr1 (v6 impf v7) ⇔ F) ∧ (inputOKr1 (v8 eqf v9) ⇔ F) ∧
   (inputOKr1 (v10 says TT) ⇔ F) ∧ (inputOKr1 (v10 says FF) ⇔ F) ∧
   (inputOKr1 (Name v132 says prop v66) ⇔ F) ∧
   (inputOKr1 (v133 meet v134 says prop v66) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (Staff v164) says prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (Authority v165) says prop (SOME v142)) ⇔
    F) ∧
   (inputOKr1
      (Name (Staff Bob) quoting Name (Role Commander) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Staff Carol) quoting Name (Role Commander) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Staff Alice) quoting Name (Role Operator) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Staff Carol) quoting Name (Role Operator) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Authority v177) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Role v178) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (KeyS v179) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (KeyA v180) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Machine v181) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (KeyS v167) says prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (KeyA v168) says prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (Machine v169) says prop (SOME v142)) ⇔
    F) ∧
   (inputOKr1 (v155 meet v156 quoting Name v144 says prop (SOME v142)) ⇔
    F) ∧
   (inputOKr1
      ((v157 quoting v158) quoting Name v144 says prop (SOME v142)) ⇔
    F) ∧
   (inputOKr1 (v135 quoting v145 meet v146 says prop (SOME v142)) ⇔ F) ∧
   (inputOKr1 (v135 quoting v147 quoting v148 says prop (SOME v142)) ⇔
    F) ∧ (inputOKr1 (v135 quoting v136 says prop NONE) ⇔ F) ∧
   (inputOKr1 (v10 says notf v67) ⇔ F) ∧
   (inputOKr1 (v10 says (v68 andf v69)) ⇔ F) ∧
   (inputOKr1 (v10 says (v70 orf v71)) ⇔ F) ∧
   (inputOKr1 (v10 says (v72 impf v73)) ⇔ F) ∧
   (inputOKr1 (v10 says (v74 eqf v75)) ⇔ F) ∧
   (inputOKr1 (v10 says v76 says v77) ⇔ F) ∧
   (inputOKr1 (v10 says v78 speaks_for v79) ⇔ F) ∧
   (inputOKr1 (v10 says v80 controls v81) ⇔ F) ∧
   (inputOKr1 (v10 says reps v82 v83 v84) ⇔ F) ∧
   (inputOKr1 (v10 says v85 domi v86) ⇔ F) ∧
   (inputOKr1 (v10 says v87 eqi v88) ⇔ F) ∧
   (inputOKr1 (v10 says v89 doms v90) ⇔ F) ∧
   (inputOKr1 (v10 says v91 eqs v92) ⇔ F) ∧
   (inputOKr1 (v10 says v93 eqn v94) ⇔ F) ∧
   (inputOKr1 (v10 says v95 lte v96) ⇔ F) ∧
   (inputOKr1 (v10 says v97 lt v98) ⇔ F) ∧
   (inputOKr1 (v12 speaks_for v13) ⇔ F) ∧
   (inputOKr1 (v14 controls v15) ⇔ F) ∧
   (inputOKr1 (reps v16 v17 v18) ⇔ F) ∧ (inputOKr1 (v19 domi v20) ⇔ F) ∧
   (inputOKr1 (v21 eqi v22) ⇔ F) ∧ (inputOKr1 (v23 doms v24) ⇔ F) ∧
   (inputOKr1 (v25 eqs v26) ⇔ F) ∧ (inputOKr1 (v27 eqn v28) ⇔ F) ∧
   (inputOKr1 (v29 lte v30) ⇔ F) ∧ (inputOKr1 (v31 lt v32) ⇔ F):
   thm
val inputOKr1_ind =
   |- ∀P.
     (∀cmd.
        P
          (Name (Staff Bob) quoting Name (Role Operator) says
           prop (SOME cmd))) ∧
     (∀cmd.
        P
          (Name (Staff Alice) quoting Name (Role Commander) says
           prop (SOME cmd))) ∧ P TT ∧ P FF ∧ (∀v. P (prop v)) ∧
     (∀v1. P (notf v1)) ∧ (∀v2 v3. P (v2 andf v3)) ∧
     (∀v4 v5. P (v4 orf v5)) ∧ (∀v6 v7. P (v6 impf v7)) ∧
     (∀v8 v9. P (v8 eqf v9)) ∧ (∀v10. P (v10 says TT)) ∧
     (∀v10. P (v10 says FF)) ∧
     (∀v132 v66. P (Name v132 says prop v66)) ∧
     (∀v133 v134 v66. P (v133 meet v134 says prop v66)) ∧
     (∀v154 v164 v142.
        P (Name v154 quoting Name (Staff v164) says prop (SOME v142))) ∧
     (∀v154 v165 v142.
        P
          (Name v154 quoting Name (Authority v165) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Bob) quoting Name (Role Commander) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Carol) quoting Name (Role Commander) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Alice) quoting Name (Role Operator) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Carol) quoting Name (Role Operator) says
           prop (SOME v142))) ∧
     (∀v177 v166 v142.
        P
          (Name (Authority v177) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v178 v166 v142.
        P
          (Name (Role v178) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v179 v166 v142.
        P
          (Name (KeyS v179) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v180 v166 v142.
        P
          (Name (KeyA v180) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v181 v166 v142.
        P
          (Name (Machine v181) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v154 v167 v142.
        P (Name v154 quoting Name (KeyS v167) says prop (SOME v142))) ∧
     (∀v154 v168 v142.
        P (Name v154 quoting Name (KeyA v168) says prop (SOME v142))) ∧
     (∀v154 v169 v142.
        P
          (Name v154 quoting Name (Machine v169) says
           prop (SOME v142))) ∧
     (∀v155 v156 v144 v142.
        P (v155 meet v156 quoting Name v144 says prop (SOME v142))) ∧
     (∀v157 v158 v144 v142.
        P
          ((v157 quoting v158) quoting Name v144 says
           prop (SOME v142))) ∧
     (∀v135 v145 v146 v142.
        P (v135 quoting v145 meet v146 says prop (SOME v142))) ∧
     (∀v135 v147 v148 v142.
        P (v135 quoting v147 quoting v148 says prop (SOME v142))) ∧
     (∀v135 v136. P (v135 quoting v136 says prop NONE)) ∧
     (∀v10 v67. P (v10 says notf v67)) ∧
     (∀v10 v68 v69. P (v10 says (v68 andf v69))) ∧
     (∀v10 v70 v71. P (v10 says (v70 orf v71))) ∧
     (∀v10 v72 v73. P (v10 says (v72 impf v73))) ∧
     (∀v10 v74 v75. P (v10 says (v74 eqf v75))) ∧
     (∀v10 v76 v77. P (v10 says v76 says v77)) ∧
     (∀v10 v78 v79. P (v10 says v78 speaks_for v79)) ∧
     (∀v10 v80 v81. P (v10 says v80 controls v81)) ∧
     (∀v10 v82 v83 v84. P (v10 says reps v82 v83 v84)) ∧
     (∀v10 v85 v86. P (v10 says v85 domi v86)) ∧
     (∀v10 v87 v88. P (v10 says v87 eqi v88)) ∧
     (∀v10 v89 v90. P (v10 says v89 doms v90)) ∧
     (∀v10 v91 v92. P (v10 says v91 eqs v92)) ∧
     (∀v10 v93 v94. P (v10 says v93 eqn v94)) ∧
     (∀v10 v95 v96. P (v10 says v95 lte v96)) ∧
     (∀v10 v97 v98. P (v10 says v97 lt v98)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val inputOKr1_primitive_def =
   |- inputOKr1 =
   WFREC (@R. WF R)
     (λinputOKr1 a.
        case a of
          TT => I F
        | FF => I F
        | prop v33 => I F
        | notf v34 => I F
        | v35 andf v36 => I F
        | v37 orf v38 => I F
        | v39 impf v40 => I F
        | v41 eqf v42 => I F
        | v43 says TT => I F
        | v43 says FF => I F
        | Name v137 says prop v99 => I F
        | v138 meet v139 says prop v99 => I F
        | Name v159 quoting Name (Staff v170) says prop (SOME cmd) =>
            I F
        | Name v159 quoting Name (Authority v171) says
          prop (SOME cmd) =>
            I F
        | Name (Staff Alice) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I T
        | Name (Staff Bob) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I F
        | Name (Staff Carol) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I F
        | Name (Staff Alice) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I F
        | Name (Staff Bob) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I T
        | Name (Staff Carol) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I F
        | Name (Authority v183) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name (Role v184) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS v185) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name (KeyA v186) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name (Machine v187) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name v159 quoting Name (KeyS v173) says prop (SOME cmd) => I F
        | Name v159 quoting Name (KeyA v174) says prop (SOME cmd) => I F
        | Name v159 quoting Name (Machine v175) says prop (SOME cmd) =>
            I F
        | v160 meet v161 quoting Name v149 says prop (SOME cmd) => I F
        | (v162 quoting v163) quoting Name v149 says prop (SOME cmd) =>
            I F
        | v140 quoting v150 meet v151 says prop (SOME cmd) => I F
        | v140 quoting v152 quoting v153 says prop (SOME cmd) => I F
        | v140 quoting v141 says prop NONE => I F
        | v43 says notf v100 => I F
        | v43 says (v101 andf v102) => I F
        | v43 says (v103 orf v104) => I F
        | v43 says (v105 impf v106) => I F
        | v43 says (v107 eqf v108) => I F
        | v43 says v109 says v110 => I F
        | v43 says v111 speaks_for v112 => I F
        | v43 says v113 controls v114 => I F
        | v43 says reps v115 v116 v117 => I F
        | v43 says v118 domi v119 => I F
        | v43 says v120 eqi v121 => I F
        | v43 says v122 doms v123 => I F
        | v43 says v124 eqs v125 => I F
        | v43 says v126 eqn v127 => I F
        | v43 says v128 lte v129 => I F
        | v43 says v130 lt v131 => I F
        | v45 speaks_for v46 => I F
        | v47 controls v48 => I F
        | reps v49 v50 v51 => I F
        | v52 domi v53 => I F
        | v54 eqi v55 => I F
        | v56 doms v57 => I F
        | v58 eqs v59 => I F
        | v60 eqn v61 => I F
        | v62 lte v63 => I F
        | v64 lt v65 => I F):
   thm
val inputOKr1_staff_rejected_lemma =
   |- ∀P cmd. ¬inputOKr1 (Name (Staff P) says prop (SOME cmd)):
   thm
val inputOKr2_def =
   |- (inputOKr2
      (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
       prop (SOME cmd)) ⇔ T) ∧
   (inputOKr2
      (Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
       prop (SOME cmd)) ⇔ T) ∧ (inputOKr2 TT ⇔ F) ∧ (inputOKr2 FF ⇔ F) ∧
   (inputOKr2 (prop v) ⇔ F) ∧ (inputOKr2 (notf v1) ⇔ F) ∧
   (inputOKr2 (v2 andf v3) ⇔ F) ∧ (inputOKr2 (v4 orf v5) ⇔ F) ∧
   (inputOKr2 (v6 impf v7) ⇔ F) ∧ (inputOKr2 (v8 eqf v9) ⇔ F) ∧
   (inputOKr2 (Name v66 says v11) ⇔ F) ∧
   (inputOKr2 (v67 meet v68 says v11) ⇔ F) ∧
   (inputOKr2 (Name (Staff v86) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (Name (Authority v87) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (Name (Role v88) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Staff v112) says v11) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Authority v113) says v11) ⇔
    F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says TT) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says FF) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK Bob)) quoting Name (Role Commander) says
       prop (SOME v190)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK Carol)) quoting Name (Role Commander) says
       prop (SOME v190)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK Alice)) quoting Name (Role Operator) says
       prop (SOME v190)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK Carol)) quoting Name (Role Operator) says
       prop (SOME v190)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says prop NONE) ⇔
    F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says notf v125) ⇔
    F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       (v126 andf v127)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       (v128 orf v129)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       (v130 impf v131)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       (v132 eqf v133)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v134 says
       v135) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       v136 speaks_for v137) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       v138 controls v139) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       reps v140 v141 v142) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v143 domi
       v144) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v145 eqi
       v146) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v147 doms
       v148) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v149 eqs
       v150) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v151 eqn
       v152) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v153 lte
       v154) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v155 lt
       v156) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (KeyS v115) says v11) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (KeyA v116) says v11) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Machine v117) says v11) ⇔
    F) ∧
   (inputOKr2 (Name (KeyS (pubK v98)) quoting v103 meet v104 says v11) ⇔
    F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting v105 quoting v106 says v11) ⇔ F) ∧
   (inputOKr2 (Name (KeyS (privK v99)) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (Name (KeyA v90) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (Name (Machine v91) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (v77 meet v78 quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 ((v79 quoting v80) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (v12 speaks_for v13) ⇔ F) ∧
   (inputOKr2 (v14 controls v15) ⇔ F) ∧
   (inputOKr2 (reps v16 v17 v18) ⇔ F) ∧ (inputOKr2 (v19 domi v20) ⇔ F) ∧
   (inputOKr2 (v21 eqi v22) ⇔ F) ∧ (inputOKr2 (v23 doms v24) ⇔ F) ∧
   (inputOKr2 (v25 eqs v26) ⇔ F) ∧ (inputOKr2 (v27 eqn v28) ⇔ F) ∧
   (inputOKr2 (v29 lte v30) ⇔ F) ∧ (inputOKr2 (v31 lt v32) ⇔ F):
   thm
val inputOKr2_ind =
   |- ∀P.
     (∀cmd.
        P
          (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
           prop (SOME cmd))) ∧
     (∀cmd.
        P
          (Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
           prop (SOME cmd))) ∧ P TT ∧ P FF ∧ (∀v. P (prop v)) ∧
     (∀v1. P (notf v1)) ∧ (∀v2 v3. P (v2 andf v3)) ∧
     (∀v4 v5. P (v4 orf v5)) ∧ (∀v6 v7. P (v6 impf v7)) ∧
     (∀v8 v9. P (v8 eqf v9)) ∧ (∀v66 v11. P (Name v66 says v11)) ∧
     (∀v67 v68 v11. P (v67 meet v68 says v11)) ∧
     (∀v86 v70 v11. P (Name (Staff v86) quoting v70 says v11)) ∧
     (∀v87 v70 v11. P (Name (Authority v87) quoting v70 says v11)) ∧
     (∀v88 v70 v11. P (Name (Role v88) quoting v70 says v11)) ∧
     (∀v98 v112 v11.
        P (Name (KeyS (pubK v98)) quoting Name (Staff v112) says v11)) ∧
     (∀v98 v113 v11.
        P
          (Name (KeyS (pubK v98)) quoting Name (Authority v113) says
           v11)) ∧
     (∀v98 v114.
        P (Name (KeyS (pubK v98)) quoting Name (Role v114) says TT)) ∧
     (∀v98 v114.
        P (Name (KeyS (pubK v98)) quoting Name (Role v114) says FF)) ∧
     (∀v190.
        P
          (Name (KeyS (pubK Bob)) quoting Name (Role Commander) says
           prop (SOME v190))) ∧
     (∀v190.
        P
          (Name (KeyS (pubK Carol)) quoting Name (Role Commander) says
           prop (SOME v190))) ∧
     (∀v190.
        P
          (Name (KeyS (pubK Alice)) quoting Name (Role Operator) says
           prop (SOME v190))) ∧
     (∀v190.
        P
          (Name (KeyS (pubK Carol)) quoting Name (Role Operator) says
           prop (SOME v190))) ∧
     (∀v98 v114.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           prop NONE)) ∧
     (∀v98 v114 v125.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           notf v125)) ∧
     (∀v98 v114 v126 v127.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           (v126 andf v127))) ∧
     (∀v98 v114 v128 v129.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           (v128 orf v129))) ∧
     (∀v98 v114 v130 v131.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           (v130 impf v131))) ∧
     (∀v98 v114 v132 v133.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           (v132 eqf v133))) ∧
     (∀v98 v114 v134 v135.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v134 says v135)) ∧
     (∀v98 v114 v136 v137.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v136 speaks_for v137)) ∧
     (∀v98 v114 v138 v139.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v138 controls v139)) ∧
     (∀v98 v114 v140 v141 v142.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           reps v140 v141 v142)) ∧
     (∀v98 v114 v143 v144.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v143 domi v144)) ∧
     (∀v98 v114 v145 v146.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v145 eqi
           v146)) ∧
     (∀v98 v114 v147 v148.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v147 doms v148)) ∧
     (∀v98 v114 v149 v150.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v149 eqs
           v150)) ∧
     (∀v98 v114 v151 v152.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v151 eqn
           v152)) ∧
     (∀v98 v114 v153 v154.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v153 lte
           v154)) ∧
     (∀v98 v114 v155 v156.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v155 lt
           v156)) ∧
     (∀v98 v115 v11.
        P (Name (KeyS (pubK v98)) quoting Name (KeyS v115) says v11)) ∧
     (∀v98 v116 v11.
        P (Name (KeyS (pubK v98)) quoting Name (KeyA v116) says v11)) ∧
     (∀v98 v117 v11.
        P
          (Name (KeyS (pubK v98)) quoting Name (Machine v117) says
           v11)) ∧
     (∀v98 v103 v104 v11.
        P (Name (KeyS (pubK v98)) quoting v103 meet v104 says v11)) ∧
     (∀v98 v105 v106 v11.
        P (Name (KeyS (pubK v98)) quoting v105 quoting v106 says v11)) ∧
     (∀v99 v70 v11. P (Name (KeyS (privK v99)) quoting v70 says v11)) ∧
     (∀v90 v70 v11. P (Name (KeyA v90) quoting v70 says v11)) ∧
     (∀v91 v70 v11. P (Name (Machine v91) quoting v70 says v11)) ∧
     (∀v77 v78 v70 v11. P (v77 meet v78 quoting v70 says v11)) ∧
     (∀v79 v80 v70 v11. P ((v79 quoting v80) quoting v70 says v11)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val inputOKr2_primitive_def =
   |- inputOKr2 =
   WFREC (@R. WF R)
     (λinputOKr2 a.
        case a of
          TT => I F
        | FF => I F
        | prop v33 => I F
        | notf v34 => I F
        | v35 andf v36 => I F
        | v37 orf v38 => I F
        | v39 impf v40 => I F
        | v41 eqf v42 => I F
        | Name v71 says v44 => I F
        | v72 meet v73 says v44 => I F
        | Name (Staff v92) quoting v75 says v44 => I F
        | Name (Authority v93) quoting v75 says v44 => I F
        | Name (Role v94) quoting v75 says v44 => I F
        | Name (KeyS (pubK v100)) quoting Name (Staff v118) says v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Authority v119) says
          v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says TT =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says FF =>
            I F
        | Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I T
        | Name (KeyS (pubK Bob)) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS (pubK Carol)) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS (pubK Alice)) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I T
        | Name (KeyS (pubK Carol)) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          prop NONE =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          notf v158 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          (v159 andf v160) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          (v161 orf v162) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          (v163 impf v164) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          (v165 eqf v166) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v167 says v168 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v169 speaks_for v170 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v171 controls v172 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          reps v173 v174 v175 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v176 domi v177 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v178 eqi
          v179 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v180 doms v181 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v182 eqs
          v183 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v184 eqn
          v185 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v186 lte
          v187 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v188 lt
          v189 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (KeyS v121) says v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (KeyA v122) says v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Machine v123) says
          v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting v108 meet v109 says v44 => I F
        | Name (KeyS (pubK v100)) quoting v110 quoting v111 says v44 =>
            I F
        | Name (KeyS (privK v101)) quoting v75 says v44 => I F
        | Name (KeyA v96) quoting v75 says v44 => I F
        | Name (Machine v97) quoting v75 says v44 => I F
        | v82 meet v83 quoting v75 says v44 => I F
        | (v84 quoting v85) quoting v75 says v44 => I F
        | v45 speaks_for v46 => I F
        | v47 controls v48 => I F
        | reps v49 v50 v51 => I F
        | v52 domi v53 => I F
        | v54 eqi v55 => I F
        | v56 doms v57 => I F
        | v58 eqs v59 => I F
        | v60 eqn v61 => I F
        | v62 lte v63 => I F
        | v64 lt v65 => I F):
   thm
val mapSM0_Bob_Operator_privcmd_lemma =
   |- CFGInterpret (M,Oi,Os)
     (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
        (mapSM0inputOperatorBob
           (Name (Role Operator) says prop (SOME (PR privcmd)))::ins) s
        outs) ⇒
   (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val mapSM0inputOperatorBob_def =
   |- (mapSM0inputOperatorBob (Name (Role Operator) says prop (SOME cmd)) =
    Name (Staff Bob) quoting Name (Role Operator) says
    prop (SOME cmd)) ∧
   (mapSM0inputOperatorBob
      (Name (Role Commander) says prop (SOME cmd)) =
    Name (Staff Alice) quoting Name (Role Commander) says
    prop (SOME cmd)) ∧ (mapSM0inputOperatorBob TT = TT) ∧
   (mapSM0inputOperatorBob FF = TT) ∧
   (mapSM0inputOperatorBob (prop v) = TT) ∧
   (mapSM0inputOperatorBob (notf v1) = TT) ∧
   (mapSM0inputOperatorBob (v2 andf v3) = TT) ∧
   (mapSM0inputOperatorBob (v4 orf v5) = TT) ∧
   (mapSM0inputOperatorBob (v6 impf v7) = TT) ∧
   (mapSM0inputOperatorBob (v8 eqf v9) = TT) ∧
   (mapSM0inputOperatorBob (v10 says TT) = TT) ∧
   (mapSM0inputOperatorBob (v10 says FF) = TT) ∧
   (mapSM0inputOperatorBob (Name (Staff v144) says prop (SOME v142)) =
    TT) ∧
   (mapSM0inputOperatorBob
      (Name (Authority v145) says prop (SOME v142)) =
    TT) ∧
   (mapSM0inputOperatorBob (Name (KeyS v147) says prop (SOME v142)) =
    TT) ∧
   (mapSM0inputOperatorBob (Name (KeyA v148) says prop (SOME v142)) =
    TT) ∧
   (mapSM0inputOperatorBob (Name (Machine v149) says prop (SOME v142)) =
    TT) ∧ (mapSM0inputOperatorBob (Name v132 says prop NONE) = TT) ∧
   (mapSM0inputOperatorBob (v133 meet v134 says prop v66) = TT) ∧
   (mapSM0inputOperatorBob (v135 quoting v136 says prop v66) = TT) ∧
   (mapSM0inputOperatorBob (v10 says notf v67) = TT) ∧
   (mapSM0inputOperatorBob (v10 says (v68 andf v69)) = TT) ∧
   (mapSM0inputOperatorBob (v10 says (v70 orf v71)) = TT) ∧
   (mapSM0inputOperatorBob (v10 says (v72 impf v73)) = TT) ∧
   (mapSM0inputOperatorBob (v10 says (v74 eqf v75)) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v76 says v77) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v78 speaks_for v79) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v80 controls v81) = TT) ∧
   (mapSM0inputOperatorBob (v10 says reps v82 v83 v84) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v85 domi v86) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v87 eqi v88) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v89 doms v90) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v91 eqs v92) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v93 eqn v94) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v95 lte v96) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v97 lt v98) = TT) ∧
   (mapSM0inputOperatorBob (v12 speaks_for v13) = TT) ∧
   (mapSM0inputOperatorBob (v14 controls v15) = TT) ∧
   (mapSM0inputOperatorBob (reps v16 v17 v18) = TT) ∧
   (mapSM0inputOperatorBob (v19 domi v20) = TT) ∧
   (mapSM0inputOperatorBob (v21 eqi v22) = TT) ∧
   (mapSM0inputOperatorBob (v23 doms v24) = TT) ∧
   (mapSM0inputOperatorBob (v25 eqs v26) = TT) ∧
   (mapSM0inputOperatorBob (v27 eqn v28) = TT) ∧
   (mapSM0inputOperatorBob (v29 lte v30) = TT) ∧
   (mapSM0inputOperatorBob (v31 lt v32) = TT):
   thm
val mapSM0inputOperatorBob_ind =
   |- ∀P.
     (∀cmd. P (Name (Role Operator) says prop (SOME cmd))) ∧
     (∀cmd. P (Name (Role Commander) says prop (SOME cmd))) ∧ P TT ∧
     P FF ∧ (∀v. P (prop v)) ∧ (∀v1. P (notf v1)) ∧
     (∀v2 v3. P (v2 andf v3)) ∧ (∀v4 v5. P (v4 orf v5)) ∧
     (∀v6 v7. P (v6 impf v7)) ∧ (∀v8 v9. P (v8 eqf v9)) ∧
     (∀v10. P (v10 says TT)) ∧ (∀v10. P (v10 says FF)) ∧
     (∀v144 v142. P (Name (Staff v144) says prop (SOME v142))) ∧
     (∀v145 v142. P (Name (Authority v145) says prop (SOME v142))) ∧
     (∀v147 v142. P (Name (KeyS v147) says prop (SOME v142))) ∧
     (∀v148 v142. P (Name (KeyA v148) says prop (SOME v142))) ∧
     (∀v149 v142. P (Name (Machine v149) says prop (SOME v142))) ∧
     (∀v132. P (Name v132 says prop NONE)) ∧
     (∀v133 v134 v66. P (v133 meet v134 says prop v66)) ∧
     (∀v135 v136 v66. P (v135 quoting v136 says prop v66)) ∧
     (∀v10 v67. P (v10 says notf v67)) ∧
     (∀v10 v68 v69. P (v10 says (v68 andf v69))) ∧
     (∀v10 v70 v71. P (v10 says (v70 orf v71))) ∧
     (∀v10 v72 v73. P (v10 says (v72 impf v73))) ∧
     (∀v10 v74 v75. P (v10 says (v74 eqf v75))) ∧
     (∀v10 v76 v77. P (v10 says v76 says v77)) ∧
     (∀v10 v78 v79. P (v10 says v78 speaks_for v79)) ∧
     (∀v10 v80 v81. P (v10 says v80 controls v81)) ∧
     (∀v10 v82 v83 v84. P (v10 says reps v82 v83 v84)) ∧
     (∀v10 v85 v86. P (v10 says v85 domi v86)) ∧
     (∀v10 v87 v88. P (v10 says v87 eqi v88)) ∧
     (∀v10 v89 v90. P (v10 says v89 doms v90)) ∧
     (∀v10 v91 v92. P (v10 says v91 eqs v92)) ∧
     (∀v10 v93 v94. P (v10 says v93 eqn v94)) ∧
     (∀v10 v95 v96. P (v10 says v95 lte v96)) ∧
     (∀v10 v97 v98. P (v10 says v97 lt v98)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val mapSM0inputOperatorBob_primitive_def =
   |- mapSM0inputOperatorBob =
   WFREC (@R. WF R)
     (λmapSM0inputOperatorBob a.
        case a of
          TT => I TT
        | FF => I TT
        | prop v33 => I TT
        | notf v34 => I TT
        | v35 andf v36 => I TT
        | v37 orf v38 => I TT
        | v39 impf v40 => I TT
        | v41 eqf v42 => I TT
        | v43 says TT => I TT
        | v43 says FF => I TT
        | Name (Staff v150) says prop (SOME cmd) => I TT
        | Name (Authority v151) says prop (SOME cmd) => I TT
        | Name (Role Commander) says prop (SOME cmd) =>
            I
              (Name (Staff Alice) quoting Name (Role Commander) says
               prop (SOME cmd))
        | Name (Role Operator) says prop (SOME cmd) =>
            I
              (Name (Staff Bob) quoting Name (Role Operator) says
               prop (SOME cmd))
        | Name (KeyS v153) says prop (SOME cmd) => I TT
        | Name (KeyA v154) says prop (SOME cmd) => I TT
        | Name (Machine v155) says prop (SOME cmd) => I TT
        | Name v137 says prop NONE => I TT
        | v138 meet v139 says prop v99 => I TT
        | v140 quoting v141 says prop v99 => I TT
        | v43 says notf v100 => I TT
        | v43 says (v101 andf v102) => I TT
        | v43 says (v103 orf v104) => I TT
        | v43 says (v105 impf v106) => I TT
        | v43 says (v107 eqf v108) => I TT
        | v43 says v109 says v110 => I TT
        | v43 says v111 speaks_for v112 => I TT
        | v43 says v113 controls v114 => I TT
        | v43 says reps v115 v116 v117 => I TT
        | v43 says v118 domi v119 => I TT
        | v43 says v120 eqi v121 => I TT
        | v43 says v122 doms v123 => I TT
        | v43 says v124 eqs v125 => I TT
        | v43 says v126 eqn v127 => I TT
        | v43 says v128 lte v129 => I TT
        | v43 says v130 lt v131 => I TT
        | v45 speaks_for v46 => I TT
        | v47 controls v48 => I TT
        | reps v49 v50 v51 => I TT
        | v52 domi v53 => I TT
        | v54 eqi v55 => I TT
        | v56 doms v57 => I TT
        | v58 eqs v59 => I TT
        | v60 eqn v61 => I TT
        | v62 lte v63 => I TT
        | v64 lt v65 => I TT):
   thm
val mapSM0r1_Bob_Operator_privcmd_lemma =
   |- CFGInterpret (M,Oi,Os)
     (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
        (mapSM0r1input
           (mapSM0inputOperatorBob
              (Name (Role Operator) says prop (SOME (PR privcmd))))::
             ins) s outs) ⇒
   (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val mapSM0r1input_def =
   |- (mapSM0r1input
      (Name (Staff Bob) quoting Name (Role Operator) says
       prop (SOME cmd)) =
    Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
    prop (SOME cmd)) ∧
   (mapSM0r1input
      (Name (Staff Alice) quoting Name (Role Commander) says
       prop (SOME cmd)) =
    Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
    prop (SOME cmd)) ∧ (mapSM0r1input TT = TT) ∧
   (mapSM0r1input FF = TT) ∧ (mapSM0r1input (prop v) = TT) ∧
   (mapSM0r1input (notf v1) = TT) ∧ (mapSM0r1input (v2 andf v3) = TT) ∧
   (mapSM0r1input (v4 orf v5) = TT) ∧
   (mapSM0r1input (v6 impf v7) = TT) ∧
   (mapSM0r1input (v8 eqf v9) = TT) ∧
   (mapSM0r1input (v10 says TT) = TT) ∧
   (mapSM0r1input (v10 says FF) = TT) ∧
   (mapSM0r1input (Name v132 says prop v66) = TT) ∧
   (mapSM0r1input (v133 meet v134 says prop v66) = TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (Staff v164) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (Authority v165) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Staff Bob) quoting Name (Role Commander) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Staff Carol) quoting Name (Role Commander) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Staff Alice) quoting Name (Role Operator) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Staff Carol) quoting Name (Role Operator) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Authority v177) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Role v178) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (KeyS v179) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (KeyA v180) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Machine v181) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (KeyS v167) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (KeyA v168) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (Machine v169) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (v155 meet v156 quoting Name v144 says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      ((v157 quoting v158) quoting Name v144 says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input (v135 quoting v145 meet v146 says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (v135 quoting v147 quoting v148 says prop (SOME v142)) =
    TT) ∧ (mapSM0r1input (v135 quoting v136 says prop NONE) = TT) ∧
   (mapSM0r1input (v10 says notf v67) = TT) ∧
   (mapSM0r1input (v10 says (v68 andf v69)) = TT) ∧
   (mapSM0r1input (v10 says (v70 orf v71)) = TT) ∧
   (mapSM0r1input (v10 says (v72 impf v73)) = TT) ∧
   (mapSM0r1input (v10 says (v74 eqf v75)) = TT) ∧
   (mapSM0r1input (v10 says v76 says v77) = TT) ∧
   (mapSM0r1input (v10 says v78 speaks_for v79) = TT) ∧
   (mapSM0r1input (v10 says v80 controls v81) = TT) ∧
   (mapSM0r1input (v10 says reps v82 v83 v84) = TT) ∧
   (mapSM0r1input (v10 says v85 domi v86) = TT) ∧
   (mapSM0r1input (v10 says v87 eqi v88) = TT) ∧
   (mapSM0r1input (v10 says v89 doms v90) = TT) ∧
   (mapSM0r1input (v10 says v91 eqs v92) = TT) ∧
   (mapSM0r1input (v10 says v93 eqn v94) = TT) ∧
   (mapSM0r1input (v10 says v95 lte v96) = TT) ∧
   (mapSM0r1input (v10 says v97 lt v98) = TT) ∧
   (mapSM0r1input (v12 speaks_for v13) = TT) ∧
   (mapSM0r1input (v14 controls v15) = TT) ∧
   (mapSM0r1input (reps v16 v17 v18) = TT) ∧
   (mapSM0r1input (v19 domi v20) = TT) ∧
   (mapSM0r1input (v21 eqi v22) = TT) ∧
   (mapSM0r1input (v23 doms v24) = TT) ∧
   (mapSM0r1input (v25 eqs v26) = TT) ∧
   (mapSM0r1input (v27 eqn v28) = TT) ∧
   (mapSM0r1input (v29 lte v30) = TT) ∧
   (mapSM0r1input (v31 lt v32) = TT):
   thm
val mapSM0r1input_ind =
   |- ∀P.
     (∀cmd.
        P
          (Name (Staff Bob) quoting Name (Role Operator) says
           prop (SOME cmd))) ∧
     (∀cmd.
        P
          (Name (Staff Alice) quoting Name (Role Commander) says
           prop (SOME cmd))) ∧ P TT ∧ P FF ∧ (∀v. P (prop v)) ∧
     (∀v1. P (notf v1)) ∧ (∀v2 v3. P (v2 andf v3)) ∧
     (∀v4 v5. P (v4 orf v5)) ∧ (∀v6 v7. P (v6 impf v7)) ∧
     (∀v8 v9. P (v8 eqf v9)) ∧ (∀v10. P (v10 says TT)) ∧
     (∀v10. P (v10 says FF)) ∧
     (∀v132 v66. P (Name v132 says prop v66)) ∧
     (∀v133 v134 v66. P (v133 meet v134 says prop v66)) ∧
     (∀v154 v164 v142.
        P (Name v154 quoting Name (Staff v164) says prop (SOME v142))) ∧
     (∀v154 v165 v142.
        P
          (Name v154 quoting Name (Authority v165) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Bob) quoting Name (Role Commander) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Carol) quoting Name (Role Commander) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Alice) quoting Name (Role Operator) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Carol) quoting Name (Role Operator) says
           prop (SOME v142))) ∧
     (∀v177 v166 v142.
        P
          (Name (Authority v177) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v178 v166 v142.
        P
          (Name (Role v178) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v179 v166 v142.
        P
          (Name (KeyS v179) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v180 v166 v142.
        P
          (Name (KeyA v180) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v181 v166 v142.
        P
          (Name (Machine v181) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v154 v167 v142.
        P (Name v154 quoting Name (KeyS v167) says prop (SOME v142))) ∧
     (∀v154 v168 v142.
        P (Name v154 quoting Name (KeyA v168) says prop (SOME v142))) ∧
     (∀v154 v169 v142.
        P
          (Name v154 quoting Name (Machine v169) says
           prop (SOME v142))) ∧
     (∀v155 v156 v144 v142.
        P (v155 meet v156 quoting Name v144 says prop (SOME v142))) ∧
     (∀v157 v158 v144 v142.
        P
          ((v157 quoting v158) quoting Name v144 says
           prop (SOME v142))) ∧
     (∀v135 v145 v146 v142.
        P (v135 quoting v145 meet v146 says prop (SOME v142))) ∧
     (∀v135 v147 v148 v142.
        P (v135 quoting v147 quoting v148 says prop (SOME v142))) ∧
     (∀v135 v136. P (v135 quoting v136 says prop NONE)) ∧
     (∀v10 v67. P (v10 says notf v67)) ∧
     (∀v10 v68 v69. P (v10 says (v68 andf v69))) ∧
     (∀v10 v70 v71. P (v10 says (v70 orf v71))) ∧
     (∀v10 v72 v73. P (v10 says (v72 impf v73))) ∧
     (∀v10 v74 v75. P (v10 says (v74 eqf v75))) ∧
     (∀v10 v76 v77. P (v10 says v76 says v77)) ∧
     (∀v10 v78 v79. P (v10 says v78 speaks_for v79)) ∧
     (∀v10 v80 v81. P (v10 says v80 controls v81)) ∧
     (∀v10 v82 v83 v84. P (v10 says reps v82 v83 v84)) ∧
     (∀v10 v85 v86. P (v10 says v85 domi v86)) ∧
     (∀v10 v87 v88. P (v10 says v87 eqi v88)) ∧
     (∀v10 v89 v90. P (v10 says v89 doms v90)) ∧
     (∀v10 v91 v92. P (v10 says v91 eqs v92)) ∧
     (∀v10 v93 v94. P (v10 says v93 eqn v94)) ∧
     (∀v10 v95 v96. P (v10 says v95 lte v96)) ∧
     (∀v10 v97 v98. P (v10 says v97 lt v98)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val mapSM0r1input_primitive_def =
   |- mapSM0r1input =
   WFREC (@R. WF R)
     (λmapSM0r1input a.
        case a of
          TT => I TT
        | FF => I TT
        | prop v33 => I TT
        | notf v34 => I TT
        | v35 andf v36 => I TT
        | v37 orf v38 => I TT
        | v39 impf v40 => I TT
        | v41 eqf v42 => I TT
        | v43 says TT => I TT
        | v43 says FF => I TT
        | Name v137 says prop v99 => I TT
        | v138 meet v139 says prop v99 => I TT
        | Name v159 quoting Name (Staff v170) says prop (SOME cmd) =>
            I TT
        | Name v159 quoting Name (Authority v171) says
          prop (SOME cmd) =>
            I TT
        | Name (Staff Alice) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I
              (Name (KeyS (pubK Alice)) quoting
               Name (Role Commander) says prop (SOME cmd))
        | Name (Staff Bob) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I TT
        | Name (Staff Carol) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I TT
        | Name (Staff Alice) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I TT
        | Name (Staff Bob) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I
              (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
               prop (SOME cmd))
        | Name (Staff Carol) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I TT
        | Name (Authority v183) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name (Role v184) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name (KeyS v185) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name (KeyA v186) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name (Machine v187) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name v159 quoting Name (KeyS v173) says prop (SOME cmd) =>
            I TT
        | Name v159 quoting Name (KeyA v174) says prop (SOME cmd) =>
            I TT
        | Name v159 quoting Name (Machine v175) says prop (SOME cmd) =>
            I TT
        | v160 meet v161 quoting Name v149 says prop (SOME cmd) => I TT
        | (v162 quoting v163) quoting Name v149 says prop (SOME cmd) =>
            I TT
        | v140 quoting v150 meet v151 says prop (SOME cmd) => I TT
        | v140 quoting v152 quoting v153 says prop (SOME cmd) => I TT
        | v140 quoting v141 says prop NONE => I TT
        | v43 says notf v100 => I TT
        | v43 says (v101 andf v102) => I TT
        | v43 says (v103 orf v104) => I TT
        | v43 says (v105 impf v106) => I TT
        | v43 says (v107 eqf v108) => I TT
        | v43 says v109 says v110 => I TT
        | v43 says v111 speaks_for v112 => I TT
        | v43 says v113 controls v114 => I TT
        | v43 says reps v115 v116 v117 => I TT
        | v43 says v118 domi v119 => I TT
        | v43 says v120 eqi v121 => I TT
        | v43 says v122 doms v123 => I TT
        | v43 says v124 eqs v125 => I TT
        | v43 says v126 eqn v127 => I TT
        | v43 says v128 lte v129 => I TT
        | v43 says v130 lt v131 => I TT
        | v45 speaks_for v46 => I TT
        | v47 controls v48 => I TT
        | reps v49 v50 v51 => I TT
        | v52 domi v53 => I TT
        | v54 eqi v55 => I TT
        | v56 doms v57 => I TT
        | v58 eqs v59 => I TT
        | v60 eqn v61 => I TT
        | v62 lte v63 => I TT
        | v64 lt v65 => I TT):
   thm
val mkinMsg_SM0r2_Bob_Operator_privcmd_lemma =
   |- CFG2Interpret (M,Oi,Os)
     (CFG2 MsgInterpret certificateInterpret inputOKr2
        (certificatesr3 npriv privcmd) SM0StateInterp
        (mkinMsg
           (mapSM0r1input
              (mapSM0inputOperatorBob
                 (Name (Role Operator) says
                  prop (SOME (PR privcmd)))))::ins) s outs) ⇒
   (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val num2role_11 =
   |- ∀r r'. r < 2 ⇒ r' < 2 ⇒ ((num2role r = num2role r') ⇔ (r = r')):
   thm
val num2role_ONTO =
   |- ∀a. ∃r. (a = num2role r) ∧ r < 2:
   thm
val num2role_role2num =
   |- ∀a. num2role (role2num a) = a:
   thm
val num2role_thm =
   |- (num2role 0 = Commander) ∧ (num2role 1 = Operator):
   thm
val num2staff_11 =
   |- ∀r r'. r < 3 ⇒ r' < 3 ⇒ ((num2staff r = num2staff r') ⇔ (r = r')):
   thm
val num2staff_ONTO =
   |- ∀a. ∃r. (a = num2staff r) ∧ r < 3:
   thm
val num2staff_staff2num =
   |- ∀a. num2staff (staff2num a) = a:
   thm
val num2staff_thm =
   |- (num2staff 0 = Alice) ∧ (num2staff 1 = Bob) ∧ (num2staff 2 = Carol):
   thm
val principal_11 =
   |- (∀a a'. (Staff a = Staff a') ⇔ (a = a')) ∧
   (∀a a'. (Authority a = Authority a') ⇔ (a = a')) ∧
   (∀a a'. (Role a = Role a') ⇔ (a = a')) ∧
   (∀a a'. (KeyS a = KeyS a') ⇔ (a = a')) ∧
   (∀a a'. (KeyA a = KeyA a') ⇔ (a = a')) ∧
   ∀a a'. (Machine a = Machine a') ⇔ (a = a'):
   thm
val principal_Axiom =
   |- ∀f0 f1 f2 f3 f4 f5.
     ∃fn.
       (∀a. fn (Staff a) = f0 a) ∧ (∀a. fn (Authority a) = f1 a) ∧
       (∀a. fn (Role a) = f2 a) ∧ (∀a. fn (KeyS a) = f3 a) ∧
       (∀a. fn (KeyA a) = f4 a) ∧ ∀a. fn (Machine a) = f5 a:
   thm
val principal_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'principal' .
            (∀a0.
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR 0 (a,ARB,ARB,ARB,ARB,ARB)
                       (λn. ind_type$BOTTOM)) a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC 0) (ARB,a,ARB,ARB,ARB,ARB)
                       (λn. ind_type$BOTTOM)) a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC 0))
                       (ARB,ARB,a,ARB,ARB,ARB) (λn. ind_type$BOTTOM))
                    a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC (SUC 0)))
                       (ARB,ARB,ARB,a,ARB,ARB) (λn. ind_type$BOTTOM))
                    a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC (SUC (SUC 0))))
                       (ARB,ARB,ARB,ARB,a,ARB) (λn. ind_type$BOTTOM))
                    a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC (SUC (SUC (SUC 0)))))
                       (ARB,ARB,ARB,ARB,ARB,a) (λn. ind_type$BOTTOM))
                    a) ⇒
               'principal' a0) ⇒
            'principal' a0) rep:
   thm
val principal_case_cong =
   |- ∀M M' f f1 f2 f3 f4 f5.
     (M = M') ∧ (∀a. (M' = Staff a) ⇒ (f a = f' a)) ∧
     (∀a. (M' = Authority a) ⇒ (f1 a = f1' a)) ∧
     (∀a. (M' = Role a) ⇒ (f2 a = f2' a)) ∧
     (∀a. (M' = KeyS a) ⇒ (f3 a = f3' a)) ∧
     (∀a. (M' = KeyA a) ⇒ (f4 a = f4' a)) ∧
     (∀a. (M' = Machine a) ⇒ (f5 a = f5' a)) ⇒
     (principal_CASE M f f1 f2 f3 f4 f5 =
      principal_CASE M' f' f1' f2' f3' f4' f5'):
   thm
val principal_case_def =
   |- (∀a f f1 f2 f3 f4 f5.
      principal_CASE (Staff a) f f1 f2 f3 f4 f5 = f a) ∧
   (∀a f f1 f2 f3 f4 f5.
      principal_CASE (Authority a) f f1 f2 f3 f4 f5 = f1 a) ∧
   (∀a f f1 f2 f3 f4 f5.
      principal_CASE (Role a) f f1 f2 f3 f4 f5 = f2 a) ∧
   (∀a f f1 f2 f3 f4 f5.
      principal_CASE (KeyS a) f f1 f2 f3 f4 f5 = f3 a) ∧
   (∀a f f1 f2 f3 f4 f5.
      principal_CASE (KeyA a) f f1 f2 f3 f4 f5 = f4 a) ∧
   ∀a f f1 f2 f3 f4 f5.
     principal_CASE (Machine a) f f1 f2 f3 f4 f5 = f5 a:
   thm
val principal_distinct =
   |- (∀a' a. Staff a ≠ Authority a') ∧ (∀a' a. Staff a ≠ Role a') ∧
   (∀a' a. Staff a ≠ KeyS a') ∧ (∀a' a. Staff a ≠ KeyA a') ∧
   (∀a' a. Staff a ≠ Machine a') ∧ (∀a' a. Authority a ≠ Role a') ∧
   (∀a' a. Authority a ≠ KeyS a') ∧ (∀a' a. Authority a ≠ KeyA a') ∧
   (∀a' a. Authority a ≠ Machine a') ∧ (∀a' a. Role a ≠ KeyS a') ∧
   (∀a' a. Role a ≠ KeyA a') ∧ (∀a' a. Role a ≠ Machine a') ∧
   (∀a' a. KeyS a ≠ KeyA a') ∧ (∀a' a. KeyS a ≠ Machine a') ∧
   ∀a' a. KeyA a ≠ Machine a':
   thm
val principal_distinct_clauses =
   |- (∀a' a. Staff a ≠ Authority a') ∧ (∀a' a. Staff a ≠ Role a') ∧
   (∀a' a. Staff a ≠ KeyS a') ∧ (∀a' a. Staff a ≠ KeyA a') ∧
   (∀a' a. Staff a ≠ Machine a') ∧ (∀a' a. Authority a ≠ Role a') ∧
   (∀a' a. Authority a ≠ KeyS a') ∧ (∀a' a. Authority a ≠ KeyA a') ∧
   (∀a' a. Authority a ≠ Machine a') ∧ (∀a' a. Role a ≠ KeyS a') ∧
   (∀a' a. Role a ≠ KeyA a') ∧ (∀a' a. Role a ≠ Machine a') ∧
   (∀a' a. KeyS a ≠ KeyA a') ∧ (∀a' a. KeyS a ≠ Machine a') ∧
   ∀a' a. KeyA a ≠ Machine a':
   thm
val principal_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY)asymMsg | authority | bool | TY digest |
                  (TY, TY)fun | ind | TY itself | TY list | num | one |
                  TY option | TY pKey | principal | (TY, TY)prod |
                  TY recspace | role | TY set | staff | (TY, TY)sum |
                  symKey | TY symMsg | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a pKey = α cipher$pKey                               
  principal = principal$principal                        
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CHOICE COMM COMPL COND CONS
  COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander Cong DATATYPE
  DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL EMPTY
  EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea Es F
  FACT FAIL FCOMM FILTER FIND FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR
  FOLDRi FRONT FST FUNPOW FUNSET GENLIST GENLIST_AUX GSPEC GUESS_EXISTS
  GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP
  GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF
  INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT
  INTER INVOL ISL ISR IS_EL IS_NONE IS_NUM_REP IS_PREFIX
  IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST
  IS_SUFFIX IS_SUM_REP ITSET Id IfCases K KeyA KeyS LAST LASTN LEAST
  LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND
  LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi
  LIST_TO_SET LLEX LRC LUPDATE LinearOrder MAP MAP2 MAPi MAPi_ACC MAX
  MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID Machine NIL NONE NOTIN NRC
  NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND O ODD OLEAST ONE_ONE ONTO
  OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE OPTION_GUARD
  OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2 OPTION_MCOMP
  OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Operator Order PAD_LEFT
  PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED
  PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW
  PMATCH_ROW_COND PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ
  PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0
  PMATCH_ROW_magic_1 PMATCH_ROW_magic_2 PMATCH_ROW_magic_3
  PMATCH_ROW_magic_4 PMATCH_magic_1 POW PRE PREFIX PREIMAGE PRIM_REC
  PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder RC RCOMPL
  RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ
  RELPOW REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST
  RESTRICT RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL
  RES_SELECT REV REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT
  RSUBSET RTC RUNION RUNIV Role S SC SCANL SCANR SEG SET_TO_LIST SIGMA
  SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING
  SINGL SN SND SNOC SOME SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP Staff StrongLinearOrder StrongOrder T TAKE TC THE TL TL_T
  TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
  UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder WeakOrder
  ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number antisymmetric approx
  asymMsg_CASE asymMsg_size authority_CASE authority_size bool_size ca
  case chooser count countable deciphP deciphS delN dest_rec diag
  diamond digest_CASE digest_size dropWhile enumerate equiv_on
  equivalence findi findq fupdLast hash iBIT_cases internal_mult inv
  inv_image invtri invtri0 irreflexive isPREFIX itself_case lift2
  listRel list_CASE list_size literal_case measure mk_rec napp
  nat_elim__magic ncons nf nfoldl nfst nlen nlistrec nmap nnil npair
  nsnd nub num2role num2staff num_CASE num_to_pair o one one_CASE
  one_size option_ABS option_CASE option_REP option_size pKey_CASE
  pKey_size pair_CASE pair_size pair_to_num pairwise partition
  principal_CASE principal_size privK pubK rcdiamond reflexive role2num
  role_CASE role_size schroeder_close set sign signVerify some
  splitAtPki staff2num staff_CASE staff_size stmarker sum_CASE sum_size
  sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric the_fun
  the_value total transitive tri trichotomous tri⁻¹ unint univ
  wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    principal_CASE staff_CASE role_CASE authority_CASE digest_CASE
    asymMsg_CASE pKey_CASE symMsg_CASE symKey_CASE list_CASE option_CASE
    sum_CASE num_CASE pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val principal_induction =
   |- ∀P.
     (∀s. P (Staff s)) ∧ (∀a. P (Authority a)) ∧ (∀r. P (Role r)) ∧
     (∀p. P (KeyS p)) ∧ (∀p. P (KeyA p)) ∧ (∀n. P (Machine n)) ⇒
     ∀p. P p:
   thm
val principal_nchotomy =
   |- ∀pp.
     (∃s. pp = Staff s) ∨ (∃a. pp = Authority a) ∨ (∃r. pp = Role r) ∨
     (∃p. pp = KeyS p) ∨ (∃p. pp = KeyA p) ∨ ∃n. pp = Machine n:
   thm
val principal_one_one =
   |- (∀a a'. (Staff a = Staff a') ⇔ (a = a')) ∧
   (∀a a'. (Authority a = Authority a') ⇔ (a = a')) ∧
   (∀a a'. (Role a = Role a') ⇔ (a = a')) ∧
   (∀a a'. (KeyS a = KeyS a') ⇔ (a = a')) ∧
   (∀a a'. (KeyA a = KeyA a') ⇔ (a = a')) ∧
   ∀a a'. (Machine a = Machine a') ⇔ (a = a'):
   thm
val principal_size_def =
   |- (∀a. principal_size (Staff a) = 1 + staff_size a) ∧
   (∀a. principal_size (Authority a) = 1 + authority_size a) ∧
   (∀a. principal_size (Role a) = 1 + role_size a) ∧
   (∀a. principal_size (KeyS a) = 1 + pKey_size staff_size a) ∧
   (∀a. principal_size (KeyA a) = 1 + pKey_size authority_size a) ∧
   ∀a. principal_size (Machine a) = 1 + a:
   thm
val role2num_11 =
   |- ∀a a'. (role2num a = role2num a') ⇔ (a = a'):
   thm
val role2num_ONTO =
   |- ∀r. r < 2 ⇔ ∃a. r = role2num a:
   thm
val role2num_num2role =
   |- ∀r. r < 2 ⇔ (role2num (num2role r) = r):
   thm
val role2num_thm =
   |- (role2num Commander = 0) ∧ (role2num Operator = 1):
   thm
val role_Axiom =
   |- ∀x0 x1. ∃f. (f Commander = x0) ∧ (f Operator = x1):
   thm
val role_BIJ =
   |- (∀a. num2role (role2num a) = a) ∧
   ∀r. (λn. n < 2) r ⇔ (role2num (num2role r) = r):
   thm
val role_CASE =
   |- ∀x v0 v1.
     (case x of Commander => v0 | Operator => v1) =
     (λm. if m = 0 then v0 else v1) (role2num x):
   thm
val role_EQ_role =
   |- ∀a a'. (a = a') ⇔ (role2num a = role2num a'):
   thm
val role_TY_DEF =
   |- ∃rep. TYPE_DEFINITION (λn. n < 2) rep:
   thm
val role_case_cong =
   |- ∀M M' v0 v1.
     (M = M') ∧ ((M' = Commander) ⇒ (v0 = v0')) ∧
     ((M' = Operator) ⇒ (v1 = v1')) ⇒
     ((case M of Commander => v0 | Operator => v1) =
      case M' of Commander => v0' | Operator => v1'):
   thm
val role_case_def =
   |- (∀v0 v1. (case Commander of Commander => v0 | Operator => v1) = v0) ∧
   ∀v0 v1. (case Operator of Commander => v0 | Operator => v1) = v1:
   thm
val role_distinct =
   |- Commander ≠ Operator:
   thm
val role_distinct_clauses =
   |- Commander ≠ Operator:
   thm
val role_induction =
   |- ∀P. P Commander ∧ P Operator ⇒ ∀a. P a:
   thm
val role_nchotomy =
   |- ∀a. (a = Commander) ∨ (a = Operator):
   thm
val role_size_def =
   |- ∀x. role_size x = 0:
   thm
val staff2num_11 =
   |- ∀a a'. (staff2num a = staff2num a') ⇔ (a = a'):
   thm
val staff2num_ONTO =
   |- ∀r. r < 3 ⇔ ∃a. r = staff2num a:
   thm
val staff2num_num2staff =
   |- ∀r. r < 3 ⇔ (staff2num (num2staff r) = r):
   thm
val staff2num_thm =
   |- (staff2num Alice = 0) ∧ (staff2num Bob = 1) ∧ (staff2num Carol = 2):
   thm
val staff_Axiom =
   |- ∀x0 x1 x2. ∃f. (f Alice = x0) ∧ (f Bob = x1) ∧ (f Carol = x2):
   thm
val staff_BIJ =
   |- (∀a. num2staff (staff2num a) = a) ∧
   ∀r. (λn. n < 3) r ⇔ (staff2num (num2staff r) = r):
   thm
val staff_CASE =
   |- ∀x v0 v1 v2.
     (case x of Alice => v0 | Bob => v1 | Carol => v2) =
     (λm. if m < 1 then v0 else if m = 1 then v1 else v2) (staff2num x):
   thm
val staff_EQ_staff =
   |- ∀a a'. (a = a') ⇔ (staff2num a = staff2num a'):
   thm
val staff_TY_DEF =
   |- ∃rep. TYPE_DEFINITION (λn. n < 3) rep:
   thm
val staff_case_cong =
   |- ∀M M' v0 v1 v2.
     (M = M') ∧ ((M' = Alice) ⇒ (v0 = v0')) ∧
     ((M' = Bob) ⇒ (v1 = v1')) ∧ ((M' = Carol) ⇒ (v2 = v2')) ⇒
     ((case M of Alice => v0 | Bob => v1 | Carol => v2) =
      case M' of Alice => v0' | Bob => v1' | Carol => v2'):
   thm
val staff_case_def =
   |- (∀v0 v1 v2.
      (case Alice of Alice => v0 | Bob => v1 | Carol => v2) = v0) ∧
   (∀v0 v1 v2.
      (case Bob of Alice => v0 | Bob => v1 | Carol => v2) = v1) ∧
   ∀v0 v1 v2. (case Carol of Alice => v0 | Bob => v1 | Carol => v2) = v2:
   thm
val staff_distinct =
   |- Alice ≠ Bob ∧ Alice ≠ Carol ∧ Bob ≠ Carol:
   thm
val staff_distinct_clauses =
   |- Alice ≠ Bob ∧ Alice ≠ Carol ∧ Bob ≠ Carol:
   thm
val staff_induction =
   |- ∀P. P Alice ∧ P Bob ∧ P Carol ⇒ ∀a. P a:
   thm
val staff_nchotomy =
   |- ∀a. (a = Alice) ∨ (a = Bob) ∨ (a = Carol):
   thm
val staff_size_def =
   |- ∀x. staff_size x = 0:
   thm
type thm
> val MAP_certificateInterpret_mkRCert_thm =
   |- ∀formList. MAP certificateInterpret (MAP mkRCert formList) = formList:
   thm
val MAP_certificateInterpret_mkSCert_thm =
   |- ∀formList auth.
     MAP certificateInterpret (MAP (mkSCert auth) formList) = formList:
   thm
val MsgInterpretOK =
   |- ∀staff role command.
     MsgInterpret
       (MSG staff (Order role command)
          (sign (privK staff) (hash (SOME (Order role command))))) =
     Name (KeyS (pubK staff)) quoting Name (Role role) says
     prop (SOME command):
   thm
val MsgInterpret_def =
   |- MsgInterpret (MSG staff (Order role command) signature) =
   if checkMsg (MSG staff (Order role command) signature) then
     Name (KeyS (pubK staff)) quoting Name (Role role) says
     prop (SOME command)
   else TT:
   thm
val MsgInterpret_ind =
   |- ∀P.
     (∀staff role command signature.
        P (MSG staff (Order role command) signature)) ⇒
     ∀v. P v:
   thm
val MsgInterpret_inverts_mkinMsg_thm =
   |- ∀staff role command.
     MsgInterpret
       (mkinMsg
          (Name (KeyS (pubK staff)) quoting Name (Role role) says
           prop (SOME command))) =
     Name (KeyS (pubK staff)) quoting Name (Role role) says
     prop (SOME command):
   thm
val MsgInterpret_primitive_def =
   |- MsgInterpret =
   WFREC (@R. WF R)
     (λMsgInterpret a.
        case a of
          MSG staff (Order role command) signature =>
            I
              (if
                 checkMsg (MSG staff (Order role command) signature)
               then
                 Name (KeyS (pubK staff)) quoting Name (Role role) says
                 prop (SOME command)
               else TT)):
   thm
val certStructure_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | (TY, TY)certificate | command |
                  (TY, TY, TY, TY, TY, TY)configuration | TY digest |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  npriv | num | one | TY option | output | TY pKey |
                  TY po | principal | privcmd | (TY, TY)prod |
                  TY recspace | role | TY set | staff | state |
                  (TY, TY)sum | symKey | TY symMsg | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  ('a, 'b) certificate = (α, β) certStructure$certificate
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander
  Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL
  EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea
  Efn Es F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL
  FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS KeyA KeyS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  Machine NIL NONE NOTIN NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT
  NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY
  OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN
  OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR
  OWHILE Operator Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PR PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RCert RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV Role S SC SCANL
  SCANR SCert SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TT TYPE_DEFINITION UNCURRY UNION
  UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC
  WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certificateInterpret
  certificate_CASE certificate_size checkcert chooser command_CASE
  command_size configuration_CASE configuration_size controls count
  countable deciphP deciphS delN dest_rec diag diamond digest_CASE
  digest_size discard domi doms dropWhile enumerate eqf eqi eqn eqs
  equiv_on equivalence exec findi findq fupdLast hash iBIT_cases iLab il
  imapKS impf inst_CASE inst_size internal_mult intpKS inv inv_image
  invtri invtri0 irreflexive isPREFIX itself_case jKS launch lift2
  listRel list_CASE list_size literal_case lt lte measure meet mkRCert
  mkSCert mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen nlistrec
  nmap nnil notf npair npriv2num npriv_CASE npriv_size nsnd nub
  num2npriv num2output num2privcmd num2role num2staff num2state num_CASE
  num_to_pair o off on one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orf output2num output_CASE
  output_size pKey_CASE pKey_size pair_CASE pair_size pair_to_num
  pairwise partition principal_CASE principal_size privK privcmd2num
  privcmd_CASE privcmd_size prod_PO prop pubK quoting rcdiamond
  reflexive repPO reps reset role2num role_CASE role_size sLab sat
  satList says schroeder_close set sign signVerify sl smapKS some
  speaks_for splitAtPki staff2num staff_CASE staff_size state2num
  state_CASE state_size status stmarker sum_CASE sum_size sym
  symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric the_fun
  the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    certificate_CASE configuration_CASE trType_CASE inst_CASE
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    output_CASE state_CASE command_CASE npriv_CASE privcmd_CASE
    principal_CASE staff_CASE role_CASE authority_CASE digest_CASE
    asymMsg_CASE pKey_CASE symMsg_CASE symKey_CASE list_CASE option_CASE
    sum_CASE num_CASE pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val certificateInterpretRCert_thm =
   |- ∀formula. certificateInterpret (RCert formula) = formula:
   thm
val certificateInterpretSCert_thm =
   |- ∀formula auth.
     certificateInterpret
       (SCert (KeyA (pubK auth)) formula
          (sign (privK auth) (hash (SOME formula)))) =
     formula:
   thm
val certificateInterpret_def =
   |- (certificateInterpret (RCert formula) =
    if checkcert (RCert formula) then formula else TT) ∧
   (certificateInterpret (SCert (KeyA (pubK auth)) formula signature) =
    if checkcert (SCert (KeyA (pubK auth)) formula signature) then
      formula
    else TT):
   thm
val certificateInterpret_ind =
   |- ∀P.
     (∀formula. P (RCert formula)) ∧
     (∀auth formula signature.
        P (SCert (KeyA (pubK auth)) formula signature)) ∧
     (∀v5 v15 v16. P (SCert (Staff v5) v15 v16)) ∧
     (∀v7 v17 v18. P (SCert (Authority v7) v17 v18)) ∧
     (∀v9 v19 v20. P (SCert (Role v9) v19 v20)) ∧
     (∀v11 v21 v22. P (SCert (KeyS v11) v21 v22)) ∧
     (∀v25 v26 v27. P (SCert (KeyA (privK v25)) v26 v27)) ∧
     (∀v14 v28 v29. P (SCert (Machine v14) v28 v29)) ⇒
     ∀v. P v:
   thm
val certificateInterpret_mkRCert_thm =
   |- ∀formula. certificateInterpret (mkRCert formula) = formula:
   thm
val certificateInterpret_mkSCert_thm =
   |- ∀formula auth. certificateInterpret (mkSCert auth formula) = formula:
   thm
val certificateInterpret_primitive_def =
   |- certificateInterpret =
   WFREC (@R. WF R)
     (λcertificateInterpret a.
        case a of
          RCert formula =>
            I (if checkcert (RCert formula) then formula else TT)
        | SCert (Staff v4) formula' signature => ARB
        | SCert (Authority v6) formula' signature => ARB
        | SCert (Role v8) formula' signature => ARB
        | SCert (KeyS v10) formula' signature => ARB
        | SCert (KeyA (pubK auth)) formula' signature =>
            I
              (if
                 checkcert (SCert (KeyA (pubK auth)) formula' signature)
               then
                 formula'
               else TT)
        | SCert (KeyA (privK v24)) formula' signature => ARB
        | SCert (Machine v13) formula' signature => ARB):
   thm
val certificate_11 =
   |- (∀a a'. (RCert a = RCert a') ⇔ (a = a')) ∧
   ∀a0 a1 a2 a0' a1' a2'.
     (SCert a0 a1 a2 = SCert a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2'):
   thm
val certificate_Axiom =
   |- ∀f0 f1.
     ∃fn.
       (∀a. fn (RCert a) = f0 a) ∧
       ∀a0 a1 a2. fn (SCert a0 a1 a2) = f1 a0 a1 a2:
   thm
val certificate_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'certificate' .
            (∀a0'.
               (∃a.
                  a0' =
                  (λa.
                     ind_type$CONSTR 0 (a,ARB,ARB)
                       (λn. ind_type$BOTTOM)) a) ∨
               (∃a0 a1 a2.
                  a0' =
                  (λa0 a1 a2.
                     ind_type$CONSTR (SUC 0) (a1,a0,a2)
                       (λn. ind_type$BOTTOM)) a0 a1 a2) ⇒
               'certificate' a0') ⇒
            'certificate' a0') rep:
   thm
val certificate_case_cong =
   |- ∀M M' f f1.
     (M = M') ∧ (∀a. (M' = RCert a) ⇒ (f a = f' a)) ∧
     (∀a0 a1 a2. (M' = SCert a0 a1 a2) ⇒ (f1 a0 a1 a2 = f1' a0 a1 a2)) ⇒
     (certificate_CASE M f f1 = certificate_CASE M' f' f1'):
   thm
val certificate_case_def =
   |- (∀a f f1. certificate_CASE (RCert a) f f1 = f a) ∧
   ∀a0 a1 a2 f f1. certificate_CASE (SCert a0 a1 a2) f f1 = f1 a0 a1 a2:
   thm
val certificate_distinct =
   |- ∀a2 a1 a0 a. RCert a ≠ SCert a0 a1 a2:
   thm
val certificate_distinct_thm =
   |- ∀a2 a1 a0 a. RCert a ≠ SCert a0 a1 a2:
   thm
val certificate_induction =
   |- ∀P. (∀F. P (RCert F)) ∧ (∀p F a. P (SCert p F a)) ⇒ ∀c. P c:
   thm
val certificate_nchotomy =
   |- ∀cc. (∃F. cc = RCert F) ∨ ∃p F a. cc = SCert p F a:
   thm
val certificate_one_one =
   |- (∀a a'. (RCert a = RCert a') ⇔ (a = a')) ∧
   ∀a0 a1 a2 a0' a1' a2'.
     (SCert a0 a1 a2 = SCert a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2'):
   thm
val certificate_size_def =
   |- (∀f f1 a.
      certificate_size f f1 (RCert a) =
      1 + Form_size (inst_size command_size) principal_size f f1 a) ∧
   ∀f f1 a0 a1 a2.
     certificate_size f f1 (SCert a0 a1 a2) =
     1 +
     (principal_size a0 +
      (Form_size (inst_size command_size) principal_size f f1 a1 +
       asymMsg_size
         (digest_size
            (Form_size (inst_size command_size) principal_size f f1))
         authority_size a2)):
   thm
val checkMsgOK =
   |- checkMsg (MSG staff order (sign (privK staff) (hash (SOME order)))):
   thm
val checkMsg_def =
   |- ∀staff order signature.
     checkMsg (MSG staff order signature) ⇔
     signVerify (pubK staff) signature (SOME order):
   thm
val checkcert_def =
   |- (checkcert (RCert formula) ⇔ T) ∧
   (checkcert (SCert (KeyA (pubK auth)) formula signature) ⇔
    signVerify (pubK auth) signature (SOME formula)):
   thm
val checkcert_ind =
   |- ∀P.
     (∀formula. P (RCert formula)) ∧
     (∀auth formula signature.
        P (SCert (KeyA (pubK auth)) formula signature)) ∧
     (∀v5 v15 v16. P (SCert (Staff v5) v15 v16)) ∧
     (∀v7 v17 v18. P (SCert (Authority v7) v17 v18)) ∧
     (∀v9 v19 v20. P (SCert (Role v9) v19 v20)) ∧
     (∀v11 v21 v22. P (SCert (KeyS v11) v21 v22)) ∧
     (∀v25 v26 v27. P (SCert (KeyA (privK v25)) v26 v27)) ∧
     (∀v14 v28 v29. P (SCert (Machine v14) v28 v29)) ⇒
     ∀v. P v:
   thm
val checkcert_primitive_def =
   |- checkcert =
   WFREC (@R. WF R)
     (λcheckcert a.
        case a of
          RCert formula => I T
        | SCert (Staff v4) formula' signature => ARB
        | SCert (Authority v6) formula' signature => ARB
        | SCert (Role v8) formula' signature => ARB
        | SCert (KeyS v10) formula' signature => ARB
        | SCert (KeyA (pubK auth)) formula' signature =>
            I (signVerify (pubK auth) signature (SOME formula'))
        | SCert (KeyA (privK v24)) formula' signature => ARB
        | SCert (Machine v13) formula' signature => ARB):
   thm
val datatype_certificate =
   |- DATATYPE (certificate RCert SCert):
   thm
val datatype_inMsg =
   |- DATATYPE (inMsg MSG):
   thm
val datatype_order =
   |- DATATYPE (order Order):
   thm
val inMsg_11 =
   |- ∀a0 a1 a2 a0' a1' a2'.
     (MSG a0 a1 a2 = MSG a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2'):
   thm
val inMsg_Axiom =
   |- ∀f. ∃fn. ∀a0 a1 a2. fn (MSG a0 a1 a2) = f a0 a1 a2:
   thm
val inMsg_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'inMsg' .
            (∀a0'.
               (∃a0 a1 a2.
                  a0' =
                  (λa0 a1 a2.
                     ind_type$CONSTR 0 (a0,a1,a2) (λn. ind_type$BOTTOM))
                    a0 a1 a2) ⇒
               'inMsg' a0') ⇒
            'inMsg' a0') rep:
   thm
val inMsg_case_cong =
   |- ∀M M' f.
     (M = M') ∧
     (∀a0 a1 a2. (M' = MSG a0 a1 a2) ⇒ (f a0 a1 a2 = f' a0 a1 a2)) ⇒
     (inMsg_CASE M f = inMsg_CASE M' f'):
   thm
val inMsg_case_def =
   |- ∀a0 a1 a2 f. inMsg_CASE (MSG a0 a1 a2) f = f a0 a1 a2:
   thm
val inMsg_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | command |
                  (TY, TY, TY, TY, TY, TY)configuration |
                  (TY, TY, TY, TY, TY, TY, TY, TY)configuration2 |
                  TY digest | (TY, TY)fun | inMsg | ind | TY inst |
                  TY itself | TY list | npriv | num | one | TY option |
                  order | output | TY pKey | TY po | principal |
                  privcmd | (TY, TY)prod | TY recspace | role | TY set |
                  staff | state | (TY, TY)sum | symKey | TY symMsg |
                  TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h) configuration2 = (α, β, γ, δ, ε, ζ, η, θ) ssm2$configuration2
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  inMsg = inMsg$inMsg                                    
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  order = inMsg$order                                    
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFG2 CFG2Interpret
  CFGInterpret CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Carol Commander Cong DATATYPE DELETE DFUNSET DIFF DISJOINT
  DIV DIV2 DIVMOD DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2
  EVERYi EXISTS EXP EXT_POINT Ea Efn Es F FACT FAIL FCOMM FF FILTER FIND
  FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET
  Form_CASE Form_size GENLIST GENLIST_AUX GSPEC GUESS_EXISTS
  GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP
  GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF
  INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT
  INTER INVOL ISL ISR IS_EL IS_NONE IS_NUM_REP IS_PREFIX
  IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST
  IS_SUFFIX IS_SUM_REP ITSET Id IfCases IntLevel_CASE IntLevel_size Jext
  K KS KeyA KeyS Kripke_CASE Kripke_size LAST LASTN LEAST LEFT_ID LEN
  LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND LIST_ELEM_COUNT
  LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi LIST_TO_SET LLEX LRC
  LUPDATE Lifn LinearOrder Lsfn MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM
  MIN MIN_SET MOD MODEQ MONOID MSG Machine MsgInterpret NIL NONE NOTIN
  NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O O1 ODD
  OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE
  OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2
  OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Operator Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PR PRE
  PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET
  PSUBSET PreOrder Princ_CASE Princ_size RC RCOMPL RDOM RDOM_DELETE
  REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV Role S SC SCANL SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TR2 TT TYPE_DEFINITION UNCURRY
  UNION UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP
  WFREC WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/
  \\ _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case checkMsg chooser
  command_CASE command_size configuration2_CASE configuration2_size
  configuration_CASE configuration_size controls count countable deciphP
  deciphS delN dest_rec diag diamond digest_CASE digest_size discard
  domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on equivalence
  exec findi findq fupdLast hash iBIT_cases iLab il imapKS impf
  inMsg_CASE inMsg_size inst_CASE inst_size internal_mult intpKS inv
  inv_image invtri invtri0 irreflexive isPREFIX itself_case jKS launch
  lift2 listRel list_CASE list_size literal_case lt lte measure meet
  mk_rec mkinMsg napp nat_elim__magic ncons nf nfoldl nfst nlen nlistrec
  nmap nnil notf npair npriv2num npriv_CASE npriv_size nsnd nub
  num2npriv num2output num2privcmd num2role num2staff num2state num_CASE
  num_to_pair o off on one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orderInterpret order_CASE
  order_size orf output2num output_CASE output_size pKey_CASE pKey_size
  pair_CASE pair_size pair_to_num pairwise partition principal_CASE
  principal_size privK privcmd2num privcmd_CASE privcmd_size prod_PO
  prop pubK quoting rcdiamond reflexive repPO reps reset role2num
  role_CASE role_size sLab sat satList says schroeder_close set sign
  signVerify sl smapKS some speaks_for splitAtPki staff2num staff_CASE
  staff_size state2num state_CASE state_size status stmarker sum_CASE
  sum_size sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric
  the_fun the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  Order              ->  inMsg$Order relation$Order
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    inMsg_CASE order_CASE configuration2_CASE configuration_CASE
    trType_CASE inst_CASE Kripke_CASE Form_CASE SecLevel_CASE
    IntLevel_CASE Princ_CASE output_CASE state_CASE command_CASE
    npriv_CASE privcmd_CASE principal_CASE staff_CASE role_CASE
    authority_CASE digest_CASE asymMsg_CASE pKey_CASE symMsg_CASE
    symKey_CASE list_CASE option_CASE sum_CASE num_CASE pair_CASE
    itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val inMsg_induction =
   |- ∀P. (∀s $o a. P (MSG s $o a)) ⇒ ∀i. P i:
   thm
val inMsg_nchotomy =
   |- ∀ii. ∃s $o a. ii = MSG s $o a:
   thm
val inMsg_one_one =
   |- ∀a0 a1 a2 a0' a1' a2'.
     (MSG a0 a1 a2 = MSG a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2'):
   thm
val inMsg_size_def =
   |- ∀a0 a1 a2.
     inMsg_size (MSG a0 a1 a2) =
     1 +
     (staff_size a0 +
      (order_size a1 +
       asymMsg_size (digest_size order_size) staff_size a2)):
   thm
val mkRCert_def =
   |- ∀formula. mkRCert formula = RCert formula:
   thm
val mkSCert_def =
   |- ∀auth formula.
     mkSCert auth formula =
     SCert (KeyA (pubK auth)) formula
       (sign (privK auth) (hash (SOME formula))):
   thm
val mkinMsg_def =
   |- mkinMsg
     (Name (KeyS (pubK staff)) quoting Name (Role role) says
      prop (SOME command)) =
   MSG staff (Order role command)
     (sign (privK staff) (hash (SOME (Order role command)))):
   thm
val mkinMsg_ind =
   |- ∀P.
     (∀staff role command.
        P
          (Name (KeyS (pubK staff)) quoting Name (Role role) says
           prop (SOME command))) ∧ P TT ∧ P FF ∧ (∀v1. P (prop v1)) ∧
     (∀v3. P (notf v3)) ∧ (∀v6 v7. P (v6 andf v7)) ∧
     (∀v10 v11. P (v10 orf v11)) ∧ (∀v14 v15. P (v14 impf v15)) ∧
     (∀v18 v19. P (v18 eqf v19)) ∧ (∀v129. P (v129 says TT)) ∧
     (∀v130. P (v130 says FF)) ∧
     (∀v132 v139. P (Name v132 says prop v139)) ∧
     (∀v135 v136 v140. P (v135 meet v136 says prop v140)) ∧
     (∀v171 v161 command.
        P
          (Name v171 quoting Name (Staff v161) says
           prop (SOME command))) ∧
     (∀v172 v163 command.
        P
          (Name v172 quoting Name (Authority v163) says
           prop (SOME command))) ∧
     (∀v174 v184 command.
        P
          (Name (Staff v174) quoting Name (Role v184) says
           prop (SOME command))) ∧
     (∀v176 v185 command.
        P
          (Name (Authority v176) quoting Name (Role v185) says
           prop (SOME command))) ∧
     (∀v178 v186 command.
        P
          (Name (Role v178) quoting Name (Role v186) says
           prop (SOME command))) ∧
     (∀v189 role command.
        P
          (Name (KeyS (privK v189)) quoting Name (Role role) says
           prop (SOME command))) ∧
     (∀v181 v190 command.
        P
          (Name (KeyA v181) quoting Name (Role v190) says
           prop (SOME command))) ∧
     (∀v183 v191 command.
        P
          (Name (Machine v183) quoting Name (Role v191) says
           prop (SOME command))) ∧
     (∀v192 v166 command.
        P
          (Name v192 quoting Name (KeyS v166) says
           prop (SOME command))) ∧
     (∀v193 v168 command.
        P
          (Name v193 quoting Name (KeyA v168) says
           prop (SOME command))) ∧
     (∀v194 v170 command.
        P
          (Name v194 quoting Name (Machine v170) says
           prop (SOME command))) ∧
     (∀v154 v155 v195 v196.
        P (v154 meet v155 quoting Name v195 says prop (SOME v196))) ∧
     (∀v158 v159 v197 v198.
        P
          ((v158 quoting v159) quoting Name v197 says
           prop (SOME v198))) ∧
     (∀v200 v145 v146 v199.
        P (v200 quoting v145 meet v146 says prop (SOME v199))) ∧
     (∀v202 v149 v150 v201.
        P (v202 quoting v149 quoting v150 says prop (SOME v201))) ∧
     (∀v203 v204. P (v203 quoting v204 says prop NONE)) ∧
     (∀v205 v66. P (v205 says notf v66)) ∧
     (∀v206 v69 v70. P (v206 says (v69 andf v70))) ∧
     (∀v207 v73 v74. P (v207 says (v73 orf v74))) ∧
     (∀v208 v77 v78. P (v208 says (v77 impf v78))) ∧
     (∀v209 v81 v82. P (v209 says (v81 eqf v82))) ∧
     (∀v210 v85 v86. P (v210 says v85 says v86)) ∧
     (∀v211 v89 v90. P (v211 says v89 speaks_for v90)) ∧
     (∀v212 v93 v94. P (v212 says v93 controls v94)) ∧
     (∀v213 v98 v99 v100. P (v213 says reps v98 v99 v100)) ∧
     (∀v214 v103 v104. P (v214 says v103 domi v104)) ∧
     (∀v215 v107 v108. P (v215 says v107 eqi v108)) ∧
     (∀v216 v111 v112. P (v216 says v111 doms v112)) ∧
     (∀v217 v115 v116. P (v217 says v115 eqs v116)) ∧
     (∀v218 v119 v120. P (v218 says v119 eqn v120)) ∧
     (∀v219 v123 v124. P (v219 says v123 lte v124)) ∧
     (∀v220 v127 v128. P (v220 says v127 lt v128)) ∧
     (∀v24 v25. P (v24 speaks_for v25)) ∧
     (∀v28 v29. P (v28 controls v29)) ∧
     (∀v33 v34 v35. P (reps v33 v34 v35)) ∧
     (∀v38 v39. P (v38 domi v39)) ∧ (∀v42 v43. P (v42 eqi v43)) ∧
     (∀v46 v47. P (v46 doms v47)) ∧ (∀v50 v51. P (v50 eqs v51)) ∧
     (∀v54 v55. P (v54 eqn v55)) ∧ (∀v58 v59. P (v58 lte v59)) ∧
     (∀v62 v63. P (v62 lt v63)) ⇒
     ∀v. P v:
   thm
val mkinMsg_primitive_def =
   |- mkinMsg =
   WFREC (@R. WF R)
     (λmkinMsg a.
        case a of
          TT => ARB
        | FF => ARB
        | prop v => ARB
        | notf v2 => ARB
        | v4 andf v5 => ARB
        | v8 orf v9 => ARB
        | v12 impf v13 => ARB
        | v16 eqf v17 => ARB
        | v20 says TT => ARB
        | v20 says FF => ARB
        | Name v131 says prop v64 => ARB
        | v133 meet v134 says prop v64 => ARB
        | Name v151 quoting Name (Staff v160) says
          prop (SOME command) =>
            ARB
        | Name v151 quoting Name (Authority v162) says
          prop (SOME command) =>
            ARB
        | Name (Staff v173) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (Authority v175) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (Role v177) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (KeyS (pubK staff)) quoting Name (Role role) says
          prop (SOME command) =>
            I
              (MSG staff (Order role command)
                 (sign (privK staff)
                    (hash (SOME (Order role command)))))
        | Name (KeyS (privK v188)) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (KeyA v180) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (Machine v182) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name v151 quoting Name (KeyS v165) says prop (SOME command) =>
            ARB
        | Name v151 quoting Name (KeyA v167) says prop (SOME command) =>
            ARB
        | Name v151 quoting Name (Machine v169) says
          prop (SOME command) =>
            ARB
        | v152 meet v153 quoting Name v142 says prop (SOME command) =>
            ARB
        | (v156 quoting v157) quoting Name v142 says
          prop (SOME command) =>
            ARB
        | v137 quoting v143 meet v144 says prop (SOME command) => ARB
        | v137 quoting v147 quoting v148 says prop (SOME command) => ARB
        | v137 quoting v138 says prop NONE => ARB
        | v20 says notf v65 => ARB
        | v20 says (v67 andf v68) => ARB
        | v20 says (v71 orf v72) => ARB
        | v20 says (v75 impf v76) => ARB
        | v20 says (v79 eqf v80) => ARB
        | v20 says v83 says v84 => ARB
        | v20 says v87 speaks_for v88 => ARB
        | v20 says v91 controls v92 => ARB
        | v20 says reps v95 v96 v97 => ARB
        | v20 says v101 domi v102 => ARB
        | v20 says v105 eqi v106 => ARB
        | v20 says v109 doms v110 => ARB
        | v20 says v113 eqs v114 => ARB
        | v20 says v117 eqn v118 => ARB
        | v20 says v121 lte v122 => ARB
        | v20 says v125 lt v126 => ARB
        | v22 speaks_for v23 => ARB
        | v26 controls v27 => ARB
        | reps v30 v31 v32 => ARB
        | v36 domi v37 => ARB
        | v40 eqi v41 => ARB
        | v44 doms v45 => ARB
        | v48 eqs v49 => ARB
        | v52 eqn v53 => ARB
        | v56 lte v57 => ARB
        | v60 lt v61 => ARB):
   thm
val orderInterpret_def =
   |- ∀role command.
     orderInterpret (Order role command) =
     Name (Role role) says prop (SOME command):
   thm
val order_11 =
   |- ∀a0 a1 a0' a1'.
     (Order a0 a1 = Order a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1'):
   thm
val order_Axiom =
   |- ∀f. ∃fn. ∀a0 a1. fn (Order a0 a1) = f a0 a1:
   thm
val order_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'order' .
            (∀a0'.
               (∃a0 a1.
                  a0' =
                  (λa0 a1.
                     ind_type$CONSTR 0 (a0,a1) (λn. ind_type$BOTTOM)) a0
                    a1) ⇒
               'order' a0') ⇒
            'order' a0') rep:
   thm
val order_case_cong =
   |- ∀M M' f.
     (M = M') ∧ (∀a0 a1. (M' = Order a0 a1) ⇒ (f a0 a1 = f' a0 a1)) ⇒
     (order_CASE M f = order_CASE M' f'):
   thm
val order_case_def =
   |- ∀a0 a1 f. order_CASE (Order a0 a1) f = f a0 a1:
   thm
val order_induction =
   |- ∀P. (∀r c. P (Order r c)) ⇒ ∀ $o. P $o:
   thm
val order_nchotomy =
   |- ∀oo. ∃r c. oo = Order r c:
   thm
val order_one_one =
   |- ∀a0 a1 a0' a1'.
     (Order a0 a1 = Order a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1'):
   thm
val order_size_def =
   |- ∀a0 a1.
     order_size (Order a0 a1) = 1 + (role_size a0 + command_size a1):
   thm
type thm
> val ACL_AND_SAYS_LR_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_AND_SAYS_RL_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_ASSUM = fn: term -> thm
val ACL_ASSUM2 = fn: term -> term -> term -> thm
val ACL_CONJ = fn: thm -> thm -> thm
val ACL_CONJ_TAC = fn: 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_CONTROLS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DC_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DISJ1 = fn: term -> thm -> thm
val ACL_DISJ1_TAC = fn: 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DISJ2 = fn: term -> thm -> thm
val ACL_DISJ2_TAC = fn: 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DN = fn: thm -> thm
val ACL_DOMI_TRANS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DOMS_TRANS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_HS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_IDEMP_SPEAKS_FOR_TAC = fn: 'a * term -> 'b list * ('c -> thm)
val ACL_IL_DOMI_TAC = fn:
   term -> term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_MONO_SPEAKS_FOR_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_MP = fn: thm -> thm -> thm
val ACL_MP_SAYS_TAC = fn: 'a * term -> 'b list * ('c -> thm)
val ACL_MP_TAC = fn: thm -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_MT = fn: thm -> thm -> thm
val ACL_QUOTING_LR_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_QUOTING_RL_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_REPS_TAC = fn:
   term -> term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_REP_SAYS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_SAYS_TAC = fn: 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_SIMP1 = fn: thm -> thm
val ACL_SIMP2 = fn: thm -> thm
val ACL_SPEAKS_FOR_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_TAUT = fn: term -> thm
val ACL_TAUT_TAC = fn: tactic
val ACL_TRANS_SPEAKS_FOR_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val AND_SAYS_LR = fn: thm -> thm
val AND_SAYS_RL = fn: thm -> thm
val And_Says =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P meet Q says f eqf P says f andf Q says f:
   thm
val And_Says_Eq =
   |- (M,Oi,Os) sat P meet Q says f ⇔ (M,Oi,Os) sat P says f andf Q says f:
   thm
val CONTROLS = fn: thm -> thm -> thm
val Conjunction =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 ⇒ (M,Oi,Os) sat f2 ⇒ (M,Oi,Os) sat f1 andf f2:
   thm
val Controls =
   |- ∀M Oi Os P f.
     (M,Oi,Os) sat P says f ⇒
     (M,Oi,Os) sat P controls f ⇒
     (M,Oi,Os) sat f:
   thm
val Controls_Eq =
   |- ∀M Oi Os P f.
     (M,Oi,Os) sat P controls f ⇔ (M,Oi,Os) sat P says f impf f:
   thm
val DC = fn: thm -> thm -> thm
val DIFF_UNIV_SUBSET =
   |- (𝕌(:α) DIFF s ∪ t = 𝕌(:α)) ⇔ s ⊆ t:
   thm
val DOMI_TRANS = fn: thm -> thm -> thm
val DOMS_TRANS = fn: thm -> thm -> thm
val Derived_Controls =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P speaks_for Q ⇒
     (M,Oi,Os) sat Q controls f ⇒
     (M,Oi,Os) sat P controls f:
   thm
val Derived_Speaks_For =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P speaks_for Q ⇒
     (M,Oi,Os) sat P says f ⇒
     (M,Oi,Os) sat Q says f:
   thm
val Disjunction1 =
   |- ∀M Oi Os f1 f2. (M,Oi,Os) sat f1 ⇒ (M,Oi,Os) sat f1 orf f2:
   thm
val Disjunction2 =
   |- ∀M Oi Os f1 f2. (M,Oi,Os) sat f2 ⇒ (M,Oi,Os) sat f1 orf f2:
   thm
val Disjunctive_Syllogism =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 orf f2 ⇒ (M,Oi,Os) sat notf f1 ⇒ (M,Oi,Os) sat f2:
   thm
val Double_Negation =
   |- ∀M Oi Os f. (M,Oi,Os) sat notf (notf f) ⇒ (M,Oi,Os) sat f:
   thm
val EQF_ANDF1 = fn: thm -> thm -> thm
val EQF_ANDF2 = fn: thm -> thm -> thm
val EQF_CONTROLS = fn: thm -> thm -> thm
val EQF_EQF1 = fn: thm -> thm -> thm
val EQF_EQF2 = fn: thm -> thm -> thm
val EQF_IMPF1 = fn: thm -> thm -> thm
val EQF_IMPF2 = fn: thm -> thm -> thm
val EQF_NOTF = fn: thm -> thm -> thm
val EQF_ORF1 = fn: thm -> thm -> thm
val EQF_ORF2 = fn: thm -> thm -> thm
val EQF_REPS = fn: thm -> thm -> thm
val EQF_SAYS = fn: thm -> thm -> thm
val EQN_EQN = fn: thm -> thm -> thm -> thm
val EQN_LT = fn: thm -> thm -> thm -> thm
val EQN_LTE = fn: thm -> thm -> thm -> thm
val HS = fn: thm -> thm -> thm
val Hypothetical_Syllogism =
   |- ∀M Oi Os f1 f2 f3.
     (M,Oi,Os) sat f1 impf f2 ⇒
     (M,Oi,Os) sat f2 impf f3 ⇒
     (M,Oi,Os) sat f1 impf f3:
   thm
val IDEMP_SPEAKS_FOR = fn: term -> thm
val IL_DOMI = fn: thm -> thm -> thm -> thm
val INTER_EQ_UNIV =
   |- ∀s1 s2. (s1 ∩ s2 = 𝕌(:α)) ⇔ (s1 = 𝕌(:α)) ∧ (s2 = 𝕌(:α)):
   thm
val Idemp_Speaks_For =
   |- ∀M Oi Os P. (M,Oi,Os) sat P speaks_for P:
   thm
val Image_SUBSET =
   |- ∀R1 R2. R2 ⊆ᵣ R1 ⇒ ∀w. R2 w ⊆ R1 w:
   thm
val Image_UNION =
   |- ∀R1 R2 w. (R1 ∪ᵣ R2) w = R1 w ∪ R2 w:
   thm
val Image_cmp =
   |- ∀R1 R2 R3 u. (R1 ∘ᵣ R2) u ⊆ R3 ⇔ R2 u ⊆ {y | R1 y ⊆ R3}:
   thm
val MONO_SPEAKS_FOR = fn: thm -> thm -> thm
val MP_SAYS = fn: term -> term -> term -> thm
val MP_Says =
   |- ∀M Oi Os P f1 f2.
     (M,Oi,Os) sat P says (f1 impf f2) impf P says f1 impf P says f2:
   thm
val Modus_Ponens =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 ⇒ (M,Oi,Os) sat f1 impf f2 ⇒ (M,Oi,Os) sat f2:
   thm
val Modus_Tollens =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 impf f2 ⇒
     (M,Oi,Os) sat notf f2 ⇒
     (M,Oi,Os) sat notf f1:
   thm
val Mono_speaks_for =
   |- ∀M Oi Os P P' Q Q'.
     (M,Oi,Os) sat P speaks_for P' ⇒
     (M,Oi,Os) sat Q speaks_for Q' ⇒
     (M,Oi,Os) sat P quoting Q speaks_for P' quoting Q':
   thm
val QUOTING_LR = fn: thm -> thm
val QUOTING_RL = fn: thm -> thm
val Quoting =
   |- ∀M Oi Os P Q f. (M,Oi,Os) sat P quoting Q says f eqf P says Q says f:
   thm
val Quoting_Eq =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P quoting Q says f ⇔ (M,Oi,Os) sat P says Q says f:
   thm
val REPS = fn: thm -> thm -> thm -> thm
val REP_SAYS = fn: thm -> thm -> thm
val Rep_Controls_Eq =
   |- ∀M Oi Os A B f.
     (M,Oi,Os) sat reps A B f ⇔ (M,Oi,Os) sat A controls B says f:
   thm
val Rep_Says =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat reps P Q f ⇒
     (M,Oi,Os) sat P quoting Q says f ⇒
     (M,Oi,Os) sat Q says f:
   thm
val Reps =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat reps P Q f ⇒
     (M,Oi,Os) sat P quoting Q says f ⇒
     (M,Oi,Os) sat Q controls f ⇒
     (M,Oi,Os) sat f:
   thm
val Reps_Eq =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat reps P Q f ⇔
     (M,Oi,Os) sat P quoting Q says f impf Q says f:
   thm
val SAYS = fn: term -> thm -> thm
val SAYS_SIMP1 = fn: thm -> thm
val SAYS_SIMP2 = fn: thm -> thm
val SL_DOMS = fn: thm -> thm -> thm -> thm
val SPEAKS_FOR = fn: thm -> thm -> thm
val SUBSET_Image_SUBSET =
   |- ∀R1 R2 R3.
     (∀w1. R2 w1 ⊆ R1 w1) ⇒ ∀w. {w | R1 w ⊆ R3} ⊆ {w | R2 w ⊆ R3}:
   thm
val Says =
   |- ∀M Oi Os P f. (M,Oi,Os) sat f ⇒ (M,Oi,Os) sat P says f:
   thm
val Says_Simplification1 =
   |- ∀M Oi Os P f1 f2.
     (M,Oi,Os) sat P says (f1 andf f2) ⇒ (M,Oi,Os) sat P says f1:
   thm
val Says_Simplification2 =
   |- ∀M Oi Os P f1 f2.
     (M,Oi,Os) sat P says (f1 andf f2) ⇒ (M,Oi,Os) sat P says f2:
   thm
val Simplification1 =
   |- ∀M Oi Os f1 f2. (M,Oi,Os) sat f1 andf f2 ⇒ (M,Oi,Os) sat f1:
   thm
val Simplification2 =
   |- ∀M Oi Os f1 f2. (M,Oi,Os) sat f1 andf f2 ⇒ (M,Oi,Os) sat f2:
   thm
val Speaks_For =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P speaks_for Q impf P says f impf Q says f:
   thm
val TRANS_SPEAKS_FOR = fn: thm -> thm -> thm
val Trans_Speaks_For =
   |- ∀M Oi Os P Q R.
     (M,Oi,Os) sat P speaks_for Q ⇒
     (M,Oi,Os) sat Q speaks_for R ⇒
     (M,Oi,Os) sat P speaks_for R:
   thm
val UNIV_DIFF_SUBSET =
   |- ∀R1 R2. R1 ⊆ R2 ⇒ (𝕌(:α) DIFF R1 ∪ R2 = 𝕌(:α)):
   thm
val aclDrules_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool | (TY, TY)fun | ind |
                  TY itself | TY list | num | one | TY option | TY po |
                  (TY, TY)prod | TY recspace | TY set | (TY, TY)sum |
                  unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD
  DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP
  EXT_POINT Efn F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT
  FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  NIL NONE NOTIN NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O
  O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND
  OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP
  OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PRE PREFIX
  PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET
  PreOrder Princ_CASE Princ_size RC RCOMPL RDOM RDOM_DELETE
  REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV S SC SCANL SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
  UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder WeakOrder
  ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf antisymmetric
  approx bool_size case chooser controls count countable delN dest_rec
  diag diamond domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on
  equivalence findi findq fupdLast iBIT_cases iLab il imapKS impf
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS lift2 listRel list_CASE list_size literal_case lt lte
  measure meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair nsnd nub num_CASE num_to_pair o one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf pair_CASE pair_size pair_to_num pairwise partition
  prod_PO prop quoting rcdiamond reflexive repPO reps sLab sat says
  schroeder_close set sl smapKS some speaks_for splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total transitive tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val aclrules_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool | (TY, TY)fun | ind |
                  TY itself | TY list | num | one | TY option | TY po |
                  (TY, TY)prod | TY recspace | TY set | (TY, TY)sum |
                  unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD
  DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP
  EXT_POINT Efn F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT
  FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  NIL NONE NOTIN NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O
  O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND
  OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP
  OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PRE PREFIX
  PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET
  PreOrder Princ_CASE Princ_size RC RCOMPL RDOM RDOM_DELETE
  REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV S SC SCANL SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
  UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder WeakOrder
  ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf antisymmetric
  approx bool_size case chooser controls count countable delN dest_rec
  diag diamond domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on
  equivalence findi findq fupdLast iBIT_cases iLab il imapKS impf
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS lift2 listRel list_CASE list_size literal_case lt lte
  measure meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair nsnd nub num_CASE num_to_pair o one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf pair_CASE pair_size pair_to_num pairwise partition
  prod_PO prop quoting rcdiamond reflexive repPO reps sLab sat says
  schroeder_close set sl smapKS some speaks_for splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total transitive tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val and_says_lemma =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P meet Q says f impf P says f andf Q says f:
   thm
type conv = Abbrev.conv
val domi_antisymmetric =
   |- ∀M Oi Os l1 l2.
     (M,Oi,Os) sat l1 domi l2 ⇒
     (M,Oi,Os) sat l2 domi l1 ⇒
     (M,Oi,Os) sat l1 eqi l2:
   thm
val domi_reflexive =
   |- ∀M Oi Os l. (M,Oi,Os) sat l domi l:
   thm
val domi_transitive =
   |- ∀M Oi Os l1 l2 l3.
     (M,Oi,Os) sat l1 domi l2 ⇒
     (M,Oi,Os) sat l2 domi l3 ⇒
     (M,Oi,Os) sat l1 domi l3:
   thm
val doms_antisymmetric =
   |- ∀M Oi Os l1 l2.
     (M,Oi,Os) sat l1 doms l2 ⇒
     (M,Oi,Os) sat l2 doms l1 ⇒
     (M,Oi,Os) sat l1 eqs l2:
   thm
val doms_reflexive =
   |- ∀M Oi Os l. (M,Oi,Os) sat l doms l:
   thm
val doms_transitive =
   |- ∀M Oi Os l1 l2 l3.
     (M,Oi,Os) sat l1 doms l2 ⇒
     (M,Oi,Os) sat l2 doms l3 ⇒
     (M,Oi,Os) sat l1 doms l3:
   thm
val eqf_and_impf =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 eqf f2 ⇔
     (M,Oi,Os) sat (f1 impf f2) andf (f2 impf f1):
   thm
val eqf_andf1 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat f andf g ⇒
     (M,Oi,Os) sat f' andf g:
   thm
val eqf_andf2 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat g andf f ⇒
     (M,Oi,Os) sat g andf f':
   thm
val eqf_controls =
   |- ∀M Oi Os P f f'.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat P controls f ⇒
     (M,Oi,Os) sat P controls f':
   thm
val eqf_eq =
   |- (Efn Oi Os M (f1 eqf f2) = 𝕌(:β)) ⇔ (Efn Oi Os M f1 = Efn Oi Os M f2):
   thm
val eqf_eqf1 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat f eqf g ⇒
     (M,Oi,Os) sat f' eqf g:
   thm
val eqf_eqf2 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat g eqf f ⇒
     (M,Oi,Os) sat g eqf f':
   thm
val eqf_impf1 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat f impf g ⇒
     (M,Oi,Os) sat f' impf g:
   thm
val eqf_impf2 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat g impf f ⇒
     (M,Oi,Os) sat g impf f':
   thm
val eqf_notf =
   |- ∀M Oi Os f f'.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat notf f ⇒
     (M,Oi,Os) sat notf f':
   thm
val eqf_orf1 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat f orf g ⇒
     (M,Oi,Os) sat f' orf g:
   thm
val eqf_orf2 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat g orf f ⇒
     (M,Oi,Os) sat g orf f':
   thm
val eqf_reps =
   |- ∀M Oi Os P Q f f'.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat reps P Q f ⇒
     (M,Oi,Os) sat reps P Q f':
   thm
val eqf_sat =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 eqf f2 ⇒ ((M,Oi,Os) sat f1 ⇔ (M,Oi,Os) sat f2):
   thm
val eqf_says =
   |- ∀M Oi Os P f f'.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat P says f ⇒
     (M,Oi,Os) sat P says f':
   thm
val eqi_Eq =
   |- ∀M Oi Os l1 l2.
     (M,Oi,Os) sat l1 eqi l2 ⇔ (M,Oi,Os) sat l2 domi l1 andf l1 domi l2:
   thm
val eqn_eqn =
   |- (M,Oi,Os) sat c1 eqn n1 ⇒
   (M,Oi,Os) sat c2 eqn n2 ⇒
   (M,Oi,Os) sat n1 eqn n2 ⇒
   (M,Oi,Os) sat c1 eqn c2:
   thm
val eqn_lt =
   |- (M,Oi,Os) sat c1 eqn n1 ⇒
   (M,Oi,Os) sat c2 eqn n2 ⇒
   (M,Oi,Os) sat n1 lt n2 ⇒
   (M,Oi,Os) sat c1 lt c2:
   thm
val eqn_lte =
   |- (M,Oi,Os) sat c1 eqn n1 ⇒
   (M,Oi,Os) sat c2 eqn n2 ⇒
   (M,Oi,Os) sat n1 lte n2 ⇒
   (M,Oi,Os) sat c1 lte c2:
   thm
val eqs_Eq =
   |- ∀M Oi Os l1 l2.
     (M,Oi,Os) sat l1 eqs l2 ⇔ (M,Oi,Os) sat l2 doms l1 andf l1 doms l2:
   thm
val il_domi =
   |- ∀M Oi Os P Q l1 l2.
     (M,Oi,Os) sat il P eqi l1 ⇒
     (M,Oi,Os) sat il Q eqi l2 ⇒
     (M,Oi,Os) sat l2 domi l1 ⇒
     (M,Oi,Os) sat il Q domi il P:
   thm
val reps_def_lemma =
   |- ∀M Oi Os P Q f.
     Efn Oi Os M (reps P Q f) =
     Efn Oi Os M (P quoting Q says f impf Q says f):
   thm
val satList_CONS =
   |- ∀h t M Oi Os.
     (M,Oi,Os) satList (h::t) ⇔ (M,Oi,Os) sat h ∧ (M,Oi,Os) satList t:
   thm
val satList_conj =
   |- ∀l1 l2 M Oi Os.
     (M,Oi,Os) satList l1 ∧ (M,Oi,Os) satList l2 ⇔
     (M,Oi,Os) satList (l1 ++ l2):
   thm
val satList_def =
   |- ∀M Oi Os formList.
     (M,Oi,Os) satList formList ⇔
     FOLDR (λx y. x ∧ y) T (MAP (λf. (M,Oi,Os) sat f) formList):
   thm
val satList_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool | (TY, TY)fun | ind |
                  TY itself | TY list | num | one | TY option | TY po |
                  (TY, TY)prod | TY recspace | TY set | (TY, TY)sum |
                  unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD
  DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP
  EXT_POINT Efn F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT
  FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  NIL NONE NOTIN NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O
  O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND
  OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP
  OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PRE PREFIX
  PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET
  PreOrder Princ_CASE Princ_size RC RCOMPL RDOM RDOM_DELETE
  REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV S SC SCANL SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
  UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder WeakOrder
  ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf antisymmetric
  approx bool_size case chooser controls count countable delN dest_rec
  diag diamond domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on
  equivalence findi findq fupdLast iBIT_cases iLab il imapKS impf
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS lift2 listRel list_CASE list_size literal_case lt lte
  measure meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair nsnd nub num_CASE num_to_pair o one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf pair_CASE pair_size pair_to_num pairwise partition
  prod_PO prop quoting rcdiamond reflexive repPO reps sLab sat satList
  says schroeder_close set sl smapKS some speaks_for splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total transitive tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val satList_nil =
   |- (M,Oi,Os) satList []:
   thm
val sat_TT =
   |- (M,Oi,Os) sat TT:
   thm
val sat_allworld =
   |- ∀M f. (M,Oi,Os) sat f ⇔ ∀w. w ∈ Efn Oi Os M f:
   thm
val sat_andf_eq_and_sat =
   |- (M,Oi,Os) sat f1 andf f2 ⇔ (M,Oi,Os) sat f1 ∧ (M,Oi,Os) sat f2:
   thm
val sat_def =
   |- ∀M Oi Os f. (M,Oi,Os) sat f ⇔ (Efn Oi Os M f = 𝕌(:'world)):
   thm
val says_and_lemma =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P says f andf Q says f impf P meet Q says f:
   thm
val sl_doms =
   |- ∀M Oi Os P Q l1 l2.
     (M,Oi,Os) sat sl P eqs l1 ⇒
     (M,Oi,Os) sat sl Q eqs l2 ⇒
     (M,Oi,Os) sat l2 doms l1 ⇒
     (M,Oi,Os) sat sl Q doms sl P:
   thm
val speaks_for_SUBSET =
   |- ∀R3 R2 R1. R2 ⊆ᵣ R1 ⇒ ∀w. {w | R1 w ⊆ R3} ⊆ {w | R2 w ⊆ R3}:
   thm
type tactic = Abbrev.tactic
eqtype term
type thm
type thm_tactic = Abbrev.thm_tactic
val world_F =
   |- ∀M Oi Os w. w ∉ Efn Oi Os M FF:
   thm
val world_T =
   |- ∀M Oi Os w. w ∈ Efn Oi Os M TT:
   thm
val world_and =
   |- ∀M Oi Os f1 f2 w.
     w ∈ Efn Oi Os M (f1 andf f2) ⇔
     w ∈ Efn Oi Os M f1 ∧ w ∈ Efn Oi Os M f2:
   thm
val world_eq =
   |- ∀M Oi Os f1 f2 w.
     w ∈ Efn Oi Os M (f1 eqf f2) ⇔
     (w ∈ Efn Oi Os M f1 ⇔ w ∈ Efn Oi Os M f2):
   thm
val world_eqn =
   |- ∀M Oi Os n1 n2 w. w ∈ Efn Oi Os m (n1 eqn n2) ⇔ (n1 = n2):
   thm
val world_imp =
   |- ∀M Oi Os f1 f2 w.
     w ∈ Efn Oi Os M (f1 impf f2) ⇔
     w ∈ Efn Oi Os M f1 ⇒ w ∈ Efn Oi Os M f2:
   thm
val world_lt =
   |- ∀M Oi Os n1 n2 w. w ∈ Efn Oi Os m (n1 lt n2) ⇔ n1 < n2:
   thm
val world_lte =
   |- ∀M Oi Os n1 n2 w. w ∈ Efn Oi Os m (n1 lte n2) ⇔ n1 ≤ n2:
   thm
val world_not =
   |- ∀M Oi Os f w. w ∈ Efn Oi Os M (notf f) ⇔ w ∉ Efn Oi Os M f:
   thm
val world_or =
   |- ∀M f1 f2 w.
     w ∈ Efn Oi Os M (f1 orf f2) ⇔
     w ∈ Efn Oi Os M f1 ∨ w ∈ Efn Oi Os M f2:
   thm
val world_says =
   |- ∀M Oi Os P f w.
     w ∈ Efn Oi Os M (P says f) ⇔
     ∀v. v ∈ Jext (jKS M) P w ⇒ v ∈ Efn Oi Os M f:
   thm
> # # # # # # # # # ** types trace now on
> # # # # # # # # # ** Unicode trace now off
> Definition has been stored under "certsr1a_def"
<<HOL message: inventing new type variable names: 'a, 'b>>
Definition has been stored under "certsr2a_def"
<<HOL message: inventing new type variable names: 'a, 'b>>
Definition has been stored under "certificatesr3a_def"
val certificatesr3a_def =
   |- !(npriv :npriv) (privcmd :privcmd) (cmd :command).
     (certificatesr3a npriv privcmd cmd :('a, 'b) certificate list) =
     ((MAP
         (mkRCert :(command inst, principal, 'a, 'b) Form ->
                   ('a, 'b) certificate)
         (((certsr1a npriv privcmd cmd :
              (command inst, principal, 'a, 'b) Form list) ++
           (certsr2root npriv privcmd :
              (command inst, principal, 'a, 'b) Form list))
            :(command inst, principal, 'a, 'b) Form list) ++
       MAP
         (mkSCert (ca (0 :num)) :
            (command inst, principal, 'a, 'b) Form ->
            ('a, 'b) certificate)
         (certsr2signed npriv privcmd :
            (command inst, principal, 'a, 'b) Form list))
        :('a, 'b) certificate list):
   thm
val certsr1a_def =
   |- !(npriv :npriv) (privcmd :privcmd) (cmd :command).
     (certsr1a npriv privcmd cmd :
        (command inst, principal, 'd, 'e) Form list) =
     (((certs npriv privcmd :
          (command inst, principal, 'd, 'e) Form list) ++
       [reps (Name (Staff Alice)) (Name (Role Commander))
          (prop (SOME cmd :command inst) :
             (command inst, principal, 'd, 'e) Form);
        reps (Name (Staff Bob)) (Name (Role Operator))
          (prop (SOME cmd :command inst) :
             (command inst, principal, 'd, 'e) Form)])
        :(command inst, principal, 'd, 'e) Form list):
   thm
val certsr2a_def =
   |- !(npriv :npriv) (privcmd :privcmd) (cmd :command).
     (certsr2a npriv privcmd cmd :
        (command inst, principal, 'a, 'b) Form list) =
     (((((certsr1a npriv privcmd cmd :
            (command inst, principal, 'a, 'b) Form list) ++
        (certsr2root npriv privcmd :
           (command inst, principal, 'a, 'b) Form list))
          :(command inst, principal, 'a, 'b) Form list) ++
       (certsr2signed npriv privcmd :
          (command inst, principal, 'a, 'b) Form list))
        :(command inst, principal, 'a, 'b) Form list):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> /tmp/hol17804cKx:12: error: ; expected but val was found
Exception- Fail "Static Errors" raised
> 
*** Emacs/HOL command completed ***

> # # # # # # # # poly: : error: Expression expected but ; was found
poly: : error: ] expected but ; was found
poly: : error: ) expected but ; was found
Static Errors
> Meson search level: ....
val SM0_Commander_privcmd_trapped_lemma =
   |- CFGInterpret
     ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
      (Os :'e po))
     (CFG (inputOK :(command inst, principal, 'd, 'e) Form -> bool)
        (SM0StateInterp :state ->
                         (command inst, principal, 'd, 'e) Form)
        (certs (npriv :npriv) (privcmd :privcmd) :
           (command inst, principal, 'd, 'e) Form list)
        (Name (Role Commander) says
         (prop (SOME (PR privcmd) :command inst) :
            (command inst, principal, 'd, 'e) Form)::
             (ins :(command inst, principal, 'd, 'e) Form list))
        (s :state) (outs :output list)) ==>
   (M,Oi,Os) sat
   (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> Meson search level: ....
val SM0_Commander_privcmd_trapped_lemma =
   |- CFGInterpret
     ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
      (Os :'e po))
     (CFG (inputOK :(command inst, principal, 'd, 'e) Form -> bool)
        (SM0StateInterp :state ->
                         (command inst, principal, 'd, 'e) Form)
        (certs (npriv :npriv) (privcmd :privcmd) :
           (command inst, principal, 'd, 'e) Form list)
        (Name (Role Commander) says
         (prop (SOME (PR privcmd) :command inst) :
            (command inst, principal, 'd, 'e) Form)::
             (ins :(command inst, principal, 'd, 'e) Form list))
        (s :state) (outs :output list)) ==>
   (M,Oi,Os) sat
   (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> # 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# poly: : warning: (>) has infix status but was not preceded by op.
poly: : error: Type error in function application.
   Function: > : int * int -> bool
   Argument: use : string -> unit
   Reason: Can't unify int * int to string -> unit (Incompatible types)
Found near > use "/tmp/hol17804ooM"
poly: : error: Type error in function application.
   Function: > use : bool
   Argument: "/tmp/hol17804ooM" : string
   Reason: Value being applied does not have a function type
Found near > use "/tmp/hol17804ooM"
Static Errors
> Meson search level: ........................................
val SM0_Commander_trap_privcmd_justified_thm =
   |- !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR (M,Oi,Os) (trap (PR (privcmd :privcmd)))
       (CFG (inputOK :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certs (npriv :npriv) privcmd :
             (command inst, principal, 'd, 'e) Form list)
          (Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::
               (ins :(command inst, principal, 'd, 'e) Form list))
          (s :state) (outs :output list))
       (CFG (inputOK :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certs npriv privcmd :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     inputOK
       (Name (Role Commander) says
        (prop (SOME (PR privcmd) :command inst) :
           (command inst, principal, 'd, 'e) Form)) /\
     CFGInterpret (M,Oi,Os)
       (CFG (inputOK :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certs npriv privcmd :
             (command inst, principal, 'd, 'e) Form list)
          (Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::ins) s outs) /\
     (M,Oi,Os) sat
     (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> \
# 


# # # 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# poly: : error: Value or constructor (\) has not been declared
Found near \ use "/tmp/hol17804C9Y"
Static Errors
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> Meson search level: ........................................
val SM0_Commander_trap_privcmd_justified_thm =
   |- !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR (M,Oi,Os) (trap (PR (privcmd :privcmd)))
       (CFG (inputOK :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certs (npriv :npriv) privcmd :
             (command inst, principal, 'd, 'e) Form list)
          (Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::
               (ins :(command inst, principal, 'd, 'e) Form list))
          (s :state) (outs :output list))
       (CFG (inputOK :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certs npriv privcmd :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     inputOK
       (Name (Role Commander) says
        (prop (SOME (PR privcmd) :command inst) :
           (command inst, principal, 'd, 'e) Form)) /\
     CFGInterpret (M,Oi,Os)
       (CFG (inputOK :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certs npriv privcmd :
             (command inst, principal, 'd, 'e) Form list)
          (Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::ins) s outs) /\
     (M,Oi,Os) sat
     (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> Meson search level: ......
Meson search level: ....
val SM0r1_mapSM0_Alice_Commander_trap_privcmd_lemma =
   |- CFGInterpret
     ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
      (Os :'e po))
     (CFG (inputOKr1 :(command inst, principal, 'd, 'e) Form -> bool)
        (SM0StateInterp :state ->
                         (command inst, principal, 'd, 'e) Form)
        (certsr1a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
           (command inst, principal, 'd, 'e) Form list)
        (mapSM0inputOperatorBob
           (Name (Role Commander) says
            (prop (SOME (PR privcmd) :command inst) :
               (command inst, principal, 'd, 'e) Form))::
             (ins :(command inst, principal, 'd, 'e) Form list))
        (s :state) (outs :output list)) ==>
   (M,Oi,Os) sat
   (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val th1 =
   |- ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
    (Os :'e po)) satList
   (certsr1a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
      (command inst, principal, 'd, 'e) Form list) ==>
   (M,Oi,Os) sat
   Name (Staff Alice) quoting Name (Role Commander) says
   (prop (SOME (PR privcmd) :command inst) :
      (command inst, principal, 'd, 'e) Form) ==>
   (M,Oi,Os) sat
   (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> val SM0r1_Commander_Alice_trap_privcmd_justified_thm =
   |- !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR (M,Oi,Os) (trap (PR (privcmd :privcmd)))
       (CFG (inputOKr1 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr1a (npriv :npriv) privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (Name (Staff Alice) quoting Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::
               (ins :(command inst, principal, 'd, 'e) Form list))
          (s :state) (outs :output list))
       (CFG (inputOKr1 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr1a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     inputOKr1
       (Name (Staff Alice) quoting Name (Role Commander) says
        (prop (SOME (PR privcmd) :command inst) :
           (command inst, principal, 'd, 'e) Form)) /\
     CFGInterpret (M,Oi,Os)
       (CFG (inputOKr1 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr1a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (Name (Staff Alice) quoting Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::ins) s outs) /\
     (M,Oi,Os) sat
     (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> val SM0r1_Commander_Alice_trap_privcmd_justified_thm =
   |- !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR (M,Oi,Os) (trap (PR (privcmd :privcmd)))
       (CFG (inputOKr1 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr1a (npriv :npriv) privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (Name (Staff Alice) quoting Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::
               (ins :(command inst, principal, 'd, 'e) Form list))
          (s :state) (outs :output list))
       (CFG (inputOKr1 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr1a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     inputOKr1
       (Name (Staff Alice) quoting Name (Role Commander) says
        (prop (SOME (PR privcmd) :command inst) :
           (command inst, principal, 'd, 'e) Form)) /\
     CFGInterpret (M,Oi,Os)
       (CFG (inputOKr1 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr1a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (Name (Staff Alice) quoting Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::ins) s outs) /\
     (M,Oi,Os) sat
     (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
Process HOL finished
