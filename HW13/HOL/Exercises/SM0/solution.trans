
---------------------------------------------------------------------
       HOL-4 [Kananaskis 11 (stdknl, built Sat Aug 19 09:30:06 2017)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
[extending loadPath with Holmakefile INCLUDES variable]
> > > > val it = (): unit
> 
*** Emacs/HOL command completed ***

> Loading ssm1Theory
> Loading ssm2Theory
> > Loading SM0r3Theory
> > > > > > > > > Loading acl_infRules
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:88: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:125: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:162: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:250: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f1_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1245: warning: Matches are not exhaustive. Found near fn [th1, th2] => ACL_CONJ th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1276: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ1 disj2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1304: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ2 disj1 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1336: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1337: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1340: warning: Matches are not exhaustive. Found near fn [th] => ACL_MP th2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1374: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1408: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1440: warning: Matches are not exhaustive. Found near fn [th1, th2] => CONTROLS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1473: warning: Matches are not exhaustive. Found near fn [th1, th2] => DC th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1506: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMI_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1541: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMS_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1575: warning: Matches are not exhaustive. Found near fn [th1, th2] => HS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1601: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1602: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1604: warning: Pattern is not exhaustive.
Found near val (_, [proptype, ...]) = dest_type formType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1643: warning: Matches are not exhaustive.
Found near fn [th1, th2, th3] => IL_DOMI th2 th1 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1679: warning: Matches are not exhaustive.
Found near fn [th1, th2] => MONO_SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1709: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1710: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1745: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1776: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1810: warning: Matches are not exhaustive. Found near fn [th1, th2, th3] => REPS th1 th2 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1842: warning: Matches are not exhaustive. Found near fn [th1, th2] => REP_SAYS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1869: warning: Matches are not exhaustive. Found near fn [th] => SAYS princ th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1901: warning: Matches are not exhaustive. Found near fn [th1, th2] => SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1934: warning: Matches are not exhaustive.
Found near fn [th1, th2] => TRANS_SPEAKS_FOR th1 th2
> > val ALL_DISTINCT =
   |- (ALL_DISTINCT [] ⇔ T) ∧
   ∀h t. ALL_DISTINCT (h::t) ⇔ ¬MEM h t ∧ ALL_DISTINCT t:
   thm
val ALL_DISTINCT_APPEND =
   |- ∀l1 l2.
     ALL_DISTINCT (l1 ++ l2) ⇔
     ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀e. MEM e l1 ⇒ ¬MEM e l2:
   thm
val ALL_DISTINCT_CARD_LIST_TO_SET =
   |- ∀ls. ALL_DISTINCT ls ⇒ (CARD (set ls) = LENGTH ls):
   thm
val ALL_DISTINCT_DROP =
   |- ∀ls n. ALL_DISTINCT ls ⇒ ALL_DISTINCT (DROP n ls):
   thm
val ALL_DISTINCT_EL_IMP =
   |- ∀l n1 n2.
     ALL_DISTINCT l ∧ n1 < LENGTH l ∧ n2 < LENGTH l ⇒
     ((EL n1 l = EL n2 l) ⇔ (n1 = n2)):
   thm
val ALL_DISTINCT_FILTER =
   |- ∀l. ALL_DISTINCT l ⇔ ∀x. MEM x l ⇒ (FILTER ($= x) l = [x]):
   thm
val ALL_DISTINCT_FILTER_EL_IMP =
   |- ∀P l n1 n2.
     ALL_DISTINCT (FILTER P l) ∧ n1 < LENGTH l ∧ n2 < LENGTH l ∧
     P (EL n1 l) ∧ (EL n1 l = EL n2 l) ⇒
     (n1 = n2):
   thm
val ALL_DISTINCT_FLAT_REVERSE =
   |- ∀xs. ALL_DISTINCT (FLAT (REVERSE xs)) ⇔ ALL_DISTINCT (FLAT xs):
   thm
val ALL_DISTINCT_GENLIST =
   |- ALL_DISTINCT (GENLIST f n) ⇔
   ∀m1 m2. m1 < n ∧ m2 < n ∧ (f m1 = f m2) ⇒ (m1 = m2):
   thm
val ALL_DISTINCT_MAP =
   |- ∀f ls. ALL_DISTINCT (MAP f ls) ⇒ ALL_DISTINCT ls:
   thm
val ALL_DISTINCT_MAP_INJ =
   |- ∀ls f.
     (∀x y. MEM x ls ∧ MEM y ls ∧ (f x = f y) ⇒ (x = y)) ∧
     ALL_DISTINCT ls ⇒
     ALL_DISTINCT (MAP f ls):
   thm
val ALL_DISTINCT_REVERSE =
   |- ∀l. ALL_DISTINCT (REVERSE l) ⇔ ALL_DISTINCT l:
   thm
val ALL_DISTINCT_SET_TO_LIST =
   |- ∀s. FINITE s ⇒ ALL_DISTINCT (SET_TO_LIST s):
   thm
val ALL_DISTINCT_SING =
   |- ∀x. ALL_DISTINCT [x]:
   thm
val ALL_DISTINCT_SNOC =
   |- ∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l:
   thm
val ALL_DISTINCT_ZIP =
   |- ∀l1 l2.
     ALL_DISTINCT l1 ∧ (LENGTH l1 = LENGTH l2) ⇒
     ALL_DISTINCT (ZIP (l1,l2)):
   thm
val ALL_DISTINCT_ZIP_SWAP =
   |- ∀l1 l2.
     ALL_DISTINCT (ZIP (l1,l2)) ∧ (LENGTH l1 = LENGTH l2) ⇒
     ALL_DISTINCT (ZIP (l2,l1)):
   thm
val APPEND =
   |- (∀l. [] ++ l = l) ∧ ∀l1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2):
   thm
val APPEND_11 =
   |- (∀l1 l2 l3. (l1 ++ l2 = l1 ++ l3) ⇔ (l2 = l3)) ∧
   ∀l1 l2 l3. (l2 ++ l1 = l3 ++ l1) ⇔ (l2 = l3):
   thm
val APPEND_11_LENGTH =
   |- (∀l1 l2 l1' l2'.
      (LENGTH l1 = LENGTH l1') ⇒
      ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2'))) ∧
   ∀l1 l2 l1' l2'.
     (LENGTH l2 = LENGTH l2') ⇒
     ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2')):
   thm
val APPEND_ASSOC =
   |- ∀l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3:
   thm
val APPEND_EQ_APPEND =
   |- (l1 ++ l2 = m1 ++ m2) ⇔
   (∃l. (l1 = m1 ++ l) ∧ (m2 = l ++ l2)) ∨
   ∃l. (m1 = l1 ++ l) ∧ (l2 = l ++ m2):
   thm
val APPEND_EQ_APPEND_MID =
   |- (l1 ++ [e] ++ l2 = m1 ++ m2) ⇔
   (∃l. (m1 = l1 ++ [e] ++ l) ∧ (l2 = l ++ m2)) ∨
   ∃l. (l1 = m1 ++ l) ∧ (m2 = l ++ [e] ++ l2):
   thm
val APPEND_EQ_CONS =
   |- (l1 ++ l2 = h::t) ⇔
   (l1 = []) ∧ (l2 = h::t) ∨ ∃ $lt. (l1 = h:: $lt) ∧ (t = $lt ++ l2):
   thm
val APPEND_EQ_SELF =
   |- (∀l1 l2. (l1 ++ l2 = l1) ⇔ (l2 = [])) ∧
   (∀l1 l2. (l1 ++ l2 = l2) ⇔ (l1 = [])) ∧
   (∀l1 l2. (l1 = l1 ++ l2) ⇔ (l2 = [])) ∧
   ∀l1 l2. (l2 = l1 ++ l2) ⇔ (l1 = []):
   thm
val APPEND_EQ_SING =
   |- (l1 ++ l2 = [e]) ⇔ (l1 = [e]) ∧ (l2 = []) ∨ (l1 = []) ∧ (l2 = [e]):
   thm
val APPEND_FRONT_LAST =
   |- ∀l. l ≠ [] ⇒ (FRONT l ++ [LAST l] = l):
   thm
val APPEND_LENGTH_EQ =
   |- ∀l1 l1'.
     (LENGTH l1 = LENGTH l1') ⇒
     ∀l2 l2'.
       (LENGTH l2 = LENGTH l2') ⇒
       ((l1 ++ l2 = l1' ++ l2') ⇔ (l1 = l1') ∧ (l2 = l2')):
   thm
val APPEND_NIL =
   |- ∀l. l ++ [] = l:
   thm
val APPEND_SNOC =
   |- ∀l1 x l2. l1 ++ SNOC x l2 = SNOC x (l1 ++ l2):
   thm
val APPEND_eq_NIL =
   |- (∀l1 l2. ([] = l1 ++ l2) ⇔ (l1 = []) ∧ (l2 = [])) ∧
   ∀l1 l2. (l1 ++ l2 = []) ⇔ (l1 = []) ∧ (l2 = []):
   thm
val BIGUNION_IMAGE_set_SUBSET =
   |- BIGUNION (IMAGE f (set ls)) ⊆ s ⇔ ∀x. MEM x ls ⇒ f x ⊆ s:
   thm
val CARD_LIST_TO_SET =
   |- CARD (set ls) ≤ LENGTH ls:
   thm
val CARD_LIST_TO_SET_ALL_DISTINCT =
   |- ∀ls. (CARD (set ls) = LENGTH ls) ⇒ ALL_DISTINCT ls:
   thm
val CFG2Interpret_def =
   |- CFG2Interpret (M,Oi,Os)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream) ⇔
   (M,Oi,Os) satList MAP certInterpret certs ∧
   (M,Oi,Os) sat inputInterpret x ∧ (M,Oi,Os) sat stateInterpret state:
   thm
val CFG2Interpret_ind =
   |- ∀P.
     (∀M Oi Os inputInterpret certInterpret inputTest certs
         stateInterpret x ins state outStream.
        P (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)) ∧
     (∀v19 v12 v13 v14 v15 v16 v17 v18.
        P v19 (CFG2 v12 v13 v14 v15 v16 [] v17 v18)) ⇒
     ∀v v1 v2 v3. P (v,v1,v2) v3:
   thm
val CFGInterpret_def =
   |- CFGInterpret (M,Oi,Os)
     (CFG inputTest stateInterp context (x::ins) state outStream) ⇔
   (M,Oi,Os) satList context ∧ (M,Oi,Os) sat x ∧
   (M,Oi,Os) sat stateInterp state:
   thm
val CFGInterpret_ind =
   |- ∀P.
     (∀M Oi Os inputTest stateInterp context x ins state outStream.
        P (M,Oi,Os)
          (CFG inputTest stateInterp context (x::ins) state
             outStream)) ∧
     (∀v15 v10 v11 v12 v13 v14. P v15 (CFG v10 v11 v12 [] v13 v14)) ⇒
     ∀v v1 v2 v3. P (v,v1,v2) v3:
   thm
val CONS =
   |- ∀l. ¬NULL l ⇒ (HD l::TL l = l):
   thm
val CONS_11 =
   |- ∀a0 a1 a0' a1'. (a0::a1 = a0'::a1') ⇔ (a0 = a0') ∧ (a1 = a1'):
   thm
val CONS_ACYCLIC =
   |- ∀l x. l ≠ x::l ∧ x::l ≠ l:
   thm
val DISJOINT_GENLIST_PLUS =
   |- DISJOINT x (set (GENLIST ($+ n) (a + b))) ⇒
   DISJOINT x (set (GENLIST ($+ n) a)) ∧
   DISJOINT x (set (GENLIST ($+ (n + a)) b)):
   thm
val DROP_0 =
   |- DROP 0 l = l:
   thm
val DROP_LENGTH_TOO_LONG =
   |- ∀l n. LENGTH l ≤ n ⇒ (DROP n l = []):
   thm
val DROP_NIL =
   |- ∀ls n. (DROP n ls = []) ⇔ n ≥ LENGTH ls:
   thm
val DROP_compute =
   |- (∀l. DROP 0 l = l) ∧ (∀n. DROP (NUMERAL (BIT1 n)) [] = []) ∧
   (∀n. DROP (NUMERAL (BIT2 n)) [] = []) ∧
   (∀n h t.
      DROP (NUMERAL (BIT1 n)) (h::t) = DROP (NUMERAL (BIT1 n) − 1) t) ∧
   ∀n h t. DROP (NUMERAL (BIT2 n)) (h::t) = DROP (NUMERAL (BIT1 n)) t:
   thm
val DROP_cons =
   |- 0 < n ⇒ (DROP n (x::xs) = DROP (n − 1) xs):
   thm
val DROP_def =
   |- (∀n. DROP n [] = []) ∧
   ∀n x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n − 1) xs:
   thm
val DROP_nil =
   |- ∀n. DROP n [] = []:
   thm
val DROP_splitAtPki =
   |- DROP n l = splitAtPki (K ∘ $= n) (K I) l:
   thm
val EL =
   |- (∀l. EL 0 l = HD l) ∧ ∀l n. EL (SUC n) l = EL n (TL l):
   thm
val EL_ALL_DISTINCT_EL_EQ =
   |- ∀l.
     ALL_DISTINCT l ⇔
     ∀n1 n2.
       n1 < LENGTH l ∧ n2 < LENGTH l ⇒ ((EL n1 l = EL n2 l) ⇔ (n1 = n2)):
   thm
val EL_APPEND_EQN =
   |- ∀l1 l2 n.
     EL n (l1 ++ l2) =
     if n < LENGTH l1 then EL n l1 else EL (n − LENGTH l1) l2:
   thm
val EL_GENLIST =
   |- ∀f n x. x < n ⇒ (EL x (GENLIST f n) = f x):
   thm
val EL_LENGTH_SNOC =
   |- ∀l x. EL (LENGTH l) (SNOC x l) = x:
   thm
val EL_LENGTH_dropWhile_REVERSE =
   |- ∀P ls k.
     LENGTH (dropWhile P (REVERSE ls)) ≤ k ∧ k < LENGTH ls ⇒ P (EL k ls):
   thm
val EL_LUPDATE =
   |- ∀ys x i k.
     EL i (LUPDATE x k ys) =
     if (i = k) ∧ k < LENGTH ys then x else EL i ys:
   thm
val EL_MAP =
   |- ∀n l. n < LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l):
   thm
val EL_REVERSE =
   |- ∀n l. n < LENGTH l ⇒ (EL n (REVERSE l) = EL (PRE (LENGTH l − n)) l):
   thm
val EL_SNOC =
   |- ∀n l. n < LENGTH l ⇒ ∀x. EL n (SNOC x l) = EL n l:
   thm
val EL_ZIP =
   |- ∀l1 l2 n.
     (LENGTH l1 = LENGTH l2) ∧ n < LENGTH l1 ⇒
     (EL n (ZIP (l1,l2)) = (EL n l1,EL n l2)):
   thm
val EL_compute =
   |- ∀n. EL n l = if n = 0 then HD l else EL (PRE n) (TL l):
   thm
val EL_restricted =
   |- (EL 0 = HD) ∧ (EL (SUC n) (l::ls) = EL n ls):
   thm
val EL_simp =
   |- (EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l)) ∧
   (EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l)):
   thm
val EL_simp_restricted =
   |- (EL (NUMERAL (BIT1 n)) (l::ls) = EL (PRE (NUMERAL (BIT1 n))) ls) ∧
   (EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls):
   thm
val EQ_LIST =
   |- ∀h1 h2. (h1 = h2) ⇒ ∀l1 l2. (l1 = l2) ⇒ (h1::l1 = h2::l2):
   thm
val EVERY2_EVERY =
   |- ∀l1 l2 f.
     LIST_REL f l1 l2 ⇔
     (LENGTH l1 = LENGTH l2) ∧ EVERY (UNCURRY f) (ZIP (l1,l2)):
   thm
val EVERY2_LENGTH =
   |- ∀P l1 l2. LIST_REL P l1 l2 ⇒ (LENGTH l1 = LENGTH l2):
   thm
val EVERY2_LUPDATE_same =
   |- ∀P l1 l2 v1 v2 n.
     P v1 v2 ∧ LIST_REL P l1 l2 ⇒
     LIST_REL P (LUPDATE v1 n l1) (LUPDATE v2 n l2):
   thm
val EVERY2_MAP =
   |- (LIST_REL P (MAP f l1) l2 ⇔ LIST_REL (λx y. P (f x) y) l1 l2) ∧
   (LIST_REL Q l1 (MAP g l2) ⇔ LIST_REL (λx y. Q x (g y)) l1 l2):
   thm
val EVERY2_MEM_MONO =
   |- ∀P Q l1 l2.
     (∀x. MEM x (ZIP (l1,l2)) ∧ UNCURRY P x ⇒ UNCURRY Q x) ∧
     LIST_REL P l1 l2 ⇒
     LIST_REL Q l1 l2:
   thm
val EVERY2_REVERSE =
   |- ∀R l1 l2. LIST_REL R l1 l2 ⇒ LIST_REL R (REVERSE l1) (REVERSE l2):
   thm
val EVERY2_THM =
   |- (∀P ys. LIST_REL P [] ys ⇔ (ys = [])) ∧
   (∀P yys x xs.
      LIST_REL P (x::xs) yys ⇔
      ∃y ys. (yys = y::ys) ∧ P x y ∧ LIST_REL P xs ys) ∧
   (∀P xs. LIST_REL P xs [] ⇔ (xs = [])) ∧
   ∀P xxs y ys.
     LIST_REL P xxs (y::ys) ⇔
     ∃x xs. (xxs = x::xs) ∧ P x y ∧ LIST_REL P xs ys:
   thm
val EVERY2_cong =
   |- ∀l1 l1' l2 l2' P P'.
     (l1 = l1') ∧ (l2 = l2') ∧
     (∀x y. MEM x l1' ∧ MEM y l2' ⇒ (P x y ⇔ P' x y)) ⇒
     (LIST_REL P l1 l2 ⇔ LIST_REL P' l1' l2'):
   thm
val EVERY2_mono =
   |- (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2:
   thm
val EVERY2_refl =
   |- (∀x. MEM x ls ⇒ R x x) ⇒ LIST_REL R ls ls:
   thm
val EVERY2_sym =
   |- (∀x y. R1 x y ⇒ R2 y x) ⇒ ∀x y. LIST_REL R1 x y ⇒ LIST_REL R2 y x:
   thm
val EVERY2_trans =
   |- (∀x y z. R x y ∧ R y z ⇒ R x z) ⇒
   ∀x y z. LIST_REL R x y ∧ LIST_REL R y z ⇒ LIST_REL R x z:
   thm
val EVERY_APPEND =
   |- ∀P l1 l2. EVERY P (l1 ++ l2) ⇔ EVERY P l1 ∧ EVERY P l2:
   thm
val EVERY_CONG =
   |- ∀l1 l2 P P'.
     (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒
     (EVERY P l1 ⇔ EVERY P' l2):
   thm
val EVERY_CONJ =
   |- ∀P Q l. EVERY (λx. P x ∧ Q x) l ⇔ EVERY P l ∧ EVERY Q l:
   thm
val EVERY_DEF =
   |- (∀P. EVERY P [] ⇔ T) ∧ ∀P h t. EVERY P (h::t) ⇔ P h ∧ EVERY P t:
   thm
val EVERY_EL =
   |- ∀l P. EVERY P l ⇔ ∀n. n < LENGTH l ⇒ P (EL n l):
   thm
val EVERY_FILTER =
   |- ∀P1 P2 l. EVERY P1 (FILTER P2 l) ⇔ EVERY (λx. P2 x ⇒ P1 x) l:
   thm
val EVERY_FILTER_IMP =
   |- ∀P1 P2 l. EVERY P1 l ⇒ EVERY P1 (FILTER P2 l):
   thm
val EVERY_GENLIST =
   |- ∀n. EVERY P (GENLIST f n) ⇔ ∀i. i < n ⇒ P (f i):
   thm
val EVERY_MAP =
   |- ∀P f l. EVERY P (MAP f l) ⇔ EVERY (λx. P (f x)) l:
   thm
val EVERY_MEM =
   |- ∀P l. EVERY P l ⇔ ∀e. MEM e l ⇒ P e:
   thm
val EVERY_MEM_MONO =
   |- ∀P Q l. (∀x. MEM x l ∧ P x ⇒ Q x) ∧ EVERY P l ⇒ EVERY Q l:
   thm
val EVERY_MONOTONIC =
   |- ∀P Q. (∀x. P x ⇒ Q x) ⇒ ∀l. EVERY P l ⇒ EVERY Q l:
   thm
val EVERY_NOT_EXISTS =
   |- ∀P l. EVERY P l ⇔ ¬EXISTS (λx. ¬P x) l:
   thm
val EVERY_SIMP =
   |- ∀c l. EVERY (λx. c) l ⇔ (l = []) ∨ c:
   thm
val EVERY_SNOC =
   |- ∀P x l. EVERY P (SNOC x l) ⇔ EVERY P l ∧ P x:
   thm
val EVERYi_def =
   |- (∀P. EVERYi P [] ⇔ T) ∧
   ∀P h t. EVERYi P (h::t) ⇔ P 0 h ∧ EVERYi (P ∘ SUC) t:
   thm
val EXISTS_APPEND =
   |- ∀P l1 l2. EXISTS P (l1 ++ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2:
   thm
val EXISTS_CONG =
   |- ∀l1 l2 P P'.
     (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (P x ⇔ P' x)) ⇒
     (EXISTS P l1 ⇔ EXISTS P' l2):
   thm
val EXISTS_DEF =
   |- (∀P. EXISTS P [] ⇔ F) ∧ ∀P h t. EXISTS P (h::t) ⇔ P h ∨ EXISTS P t:
   thm
val EXISTS_GENLIST =
   |- ∀n. EXISTS P (GENLIST f n) ⇔ ∃i. i < n ∧ P (f i):
   thm
val EXISTS_LIST =
   |- (∃l. P l) ⇔ P [] ∨ ∃h t. P (h::t):
   thm
val EXISTS_LIST_EQ_MAP =
   |- ∀ls f. EVERY (λx. ∃y. x = f y) ls ⇒ ∃l. ls = MAP f l:
   thm
val EXISTS_MAP =
   |- ∀P f l. EXISTS P (MAP f l) ⇔ EXISTS (λx. P (f x)) l:
   thm
val EXISTS_MEM =
   |- ∀P l. EXISTS P l ⇔ ∃e. MEM e l ∧ P e:
   thm
val EXISTS_NOT_EVERY =
   |- ∀P l. EXISTS P l ⇔ ¬EVERY (λx. ¬P x) l:
   thm
val EXISTS_SIMP =
   |- ∀c l. EXISTS (λx. c) l ⇔ l ≠ [] ∧ c:
   thm
val EXISTS_SNOC =
   |- ∀P x l. EXISTS P (SNOC x l) ⇔ P x ∨ EXISTS P l:
   thm
val FILTER =
   |- (∀P. FILTER P [] = []) ∧
   ∀P h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t:
   thm
val FILTER_ALL_DISTINCT =
   |- ∀P l. ALL_DISTINCT l ⇒ ALL_DISTINCT (FILTER P l):
   thm
val FILTER_APPEND_DISTRIB =
   |- ∀P L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M:
   thm
val FILTER_COND_REWRITE =
   |- (FILTER P [] = []) ∧ (∀h. P h ⇒ (FILTER P (h::l) = h::FILTER P l)) ∧
   ∀h. ¬P h ⇒ (FILTER P (h::l) = FILTER P l):
   thm
val FILTER_EQ_APPEND =
   |- ∀P l l1 l2.
     (FILTER P l = l1 ++ l2) ⇔
     ∃l3 l4. (l = l3 ++ l4) ∧ (FILTER P l3 = l1) ∧ (FILTER P l4 = l2):
   thm
val FILTER_EQ_CONS =
   |- ∀P l h lr.
     (FILTER P l = h::lr) ⇔
     ∃l1 l2.
       (l = l1 ++ [h] ++ l2) ∧ (FILTER P l1 = []) ∧ (FILTER P l2 = lr) ∧
       P h:
   thm
val FILTER_EQ_ID =
   |- ∀P l. (FILTER P l = l) ⇔ EVERY P l:
   thm
val FILTER_EQ_NIL =
   |- ∀P l. (FILTER P l = []) ⇔ EVERY (λx. ¬P x) l:
   thm
val FILTER_NEQ_ID =
   |- ∀P l. FILTER P l ≠ l ⇔ ∃x. MEM x l ∧ ¬P x:
   thm
val FILTER_NEQ_NIL =
   |- ∀P l. FILTER P l ≠ [] ⇔ ∃x. MEM x l ∧ P x:
   thm
val FILTER_REVERSE =
   |- ∀l P. FILTER P (REVERSE l) = REVERSE (FILTER P l):
   thm
val FIND_def =
   |- ∀P. FIND P = OPTION_MAP SND ∘ INDEX_FIND 0 P:
   thm
val FINITE_LIST_TO_SET =
   |- ∀l. FINITE (set l):
   thm
val FLAT =
   |- (FLAT [] = []) ∧ ∀h t. FLAT (h::t) = h ++ FLAT t:
   thm
val FLAT_APPEND =
   |- ∀l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2:
   thm
val FLAT_EQ_NIL =
   |- ∀ls. (FLAT ls = []) ⇔ EVERY ($= []) ls:
   thm
val FLAT_compute =
   |- (FLAT [] = []) ∧ (FLAT ([]::t) = FLAT t) ∧
   (FLAT ((h::t1)::t2) = h::FLAT (t1::t2)):
   thm
val FOLDL =
   |- (∀f e. FOLDL f e [] = e) ∧
   ∀f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l:
   thm
val FOLDL2_FOLDL =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ∀f a. FOLDL2 f a l1 l2 = FOLDL (λa. UNCURRY (f a)) a (ZIP (l1,l2)):
   thm
val FOLDL2_cong =
   |- ∀l1 l1' l2 l2' a a' f f'.
     (l1 = l1') ∧ (l2 = l2') ∧ (a = a') ∧
     (∀z b c. MEM b l1' ∧ MEM c l2' ⇒ (f z b c = f' z b c)) ⇒
     (FOLDL2 f a l1 l2 = FOLDL2 f' a' l1' l2'):
   thm
val FOLDL2_def =
   |- (∀f cs c bs b a.
      FOLDL2 f a (b::bs) (c::cs) = FOLDL2 f (f a b c) bs cs) ∧
   (∀f cs a. FOLDL2 f a [] cs = a) ∧
   ∀v7 v6 f a. FOLDL2 f a (v6::v7) [] = a:
   thm
val FOLDL2_ind =
   |- ∀P.
     (∀f a b bs c cs. P f (f a b c) bs cs ⇒ P f a (b::bs) (c::cs)) ∧
     (∀f a cs. P f a [] cs) ∧ (∀f a v6 v7. P f a (v6::v7) []) ⇒
     ∀v v1 v2 v3. P v v1 v2 v3:
   thm
val FOLDL_CONG =
   |- ∀l l' b b' f f'.
     (l = l') ∧ (b = b') ∧ (∀x a. MEM x l' ⇒ (f a x = f' a x)) ⇒
     (FOLDL f b l = FOLDL f' b' l'):
   thm
val FOLDL_EQ_FOLDR =
   |- ∀f l e. ASSOC f ∧ COMM f ⇒ (FOLDL f e l = FOLDR f e l):
   thm
val FOLDL_SNOC =
   |- ∀f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x:
   thm
val FOLDL_UNION_BIGUNION =
   |- ∀f ls s. FOLDL (λs x. s ∪ f x) s ls = s ∪ BIGUNION (IMAGE f (set ls)):
   thm
val FOLDL_UNION_BIGUNION_paired =
   |- ∀f ls s.
     FOLDL (λs (x,y). s ∪ f x y) s ls =
     s ∪ BIGUNION (IMAGE (UNCURRY f) (set ls)):
   thm
val FOLDL_ZIP_SAME =
   |- ∀ls f e. FOLDL f e (ZIP (ls,ls)) = FOLDL (λx y. f x (y,y)) e ls:
   thm
val FOLDR =
   |- (∀f e. FOLDR f e [] = e) ∧
   ∀f e x l. FOLDR f e (x::l) = f x (FOLDR f e l):
   thm
val FOLDR_CONG =
   |- ∀l l' b b' f f'.
     (l = l') ∧ (b = b') ∧ (∀x a. MEM x l' ⇒ (f x a = f' x a)) ⇒
     (FOLDR f b l = FOLDR f' b' l'):
   thm
val FOLDR_CONS =
   |- ∀f ls a. FOLDR (λx y. f x::y) a ls = MAP f ls ++ a:
   thm
val FORALL_LIST =
   |- (∀l. P l) ⇔ P [] ∧ ∀h t. P (h::t):
   thm
val FRONT_CONS =
   |- (∀x. FRONT [x] = []) ∧ ∀x y z. FRONT (x::y::z) = x::FRONT (y::z):
   thm
val FRONT_CONS_EQ_NIL =
   |- (∀x xs. (FRONT (x::xs) = []) ⇔ (xs = [])) ∧
   (∀x xs. ([] = FRONT (x::xs)) ⇔ (xs = [])) ∧
   ∀x xs. NULL (FRONT (x::xs)) ⇔ NULL xs:
   thm
val FRONT_DEF =
   |- ∀h t. FRONT (h::t) = if t = [] then [] else h::FRONT t:
   thm
val FRONT_SNOC =
   |- ∀x l. FRONT (SNOC x l) = l:
   thm
val GENLIST =
   |- (∀f. GENLIST f 0 = []) ∧
   ∀f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n):
   thm
val GENLIST_APPEND =
   |- ∀f a b. GENLIST f (a + b) = GENLIST f b ++ GENLIST (λt. f (t + b)) a:
   thm
val GENLIST_AUX =
   |- (∀f l. GENLIST_AUX f 0 l = l) ∧
   ∀f n l. GENLIST_AUX f (SUC n) l = GENLIST_AUX f n (f n::l):
   thm
val GENLIST_AUX_compute =
   |- (∀f l. GENLIST_AUX f 0 l = l) ∧
   (∀f n l.
      GENLIST_AUX f (NUMERAL (BIT1 n)) l =
      GENLIST_AUX f (NUMERAL (BIT1 n) − 1)
        (f (NUMERAL (BIT1 n) − 1)::l)) ∧
   ∀f n l.
     GENLIST_AUX f (NUMERAL (BIT2 n)) l =
     GENLIST_AUX f (NUMERAL (BIT1 n)) (f (NUMERAL (BIT1 n))::l):
   thm
val GENLIST_CONS =
   |- GENLIST f (SUC n) = f 0::GENLIST (f ∘ SUC) n:
   thm
val GENLIST_EL =
   |- ∀ls f n.
     (n = LENGTH ls) ∧ (∀i. i < n ⇒ (f i = EL i ls)) ⇒
     (GENLIST f n = ls):
   thm
val GENLIST_EL_MAP =
   |- ∀f ls. GENLIST (λn. f (EL n ls)) (LENGTH ls) = MAP f ls:
   thm
val GENLIST_FUN_EQ =
   |- ∀n f g. (GENLIST f n = GENLIST g n) ⇔ ∀x. x < n ⇒ (f x = g x):
   thm
val GENLIST_GENLIST_AUX =
   |- ∀n. GENLIST f n = GENLIST_AUX f n []:
   thm
val GENLIST_NUMERALS =
   |- (GENLIST f 0 = []) ∧
   (GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []):
   thm
val GENLIST_PLUS_APPEND =
   |- GENLIST ($+ a) n1 ++ GENLIST ($+ (n1 + a)) n2 =
   GENLIST ($+ a) (n1 + n2):
   thm
val HD =
   |- ∀h t. HD (h::t) = h:
   thm
val HD_GENLIST =
   |- HD (GENLIST f (SUC n)) = f 0:
   thm
val HD_GENLIST_COR =
   |- ∀n f. 0 < n ⇒ (HD (GENLIST f n) = f 0):
   thm
val HD_REVERSE =
   |- ∀x. x ≠ [] ⇒ (HD (REVERSE x) = LAST x):
   thm
val HD_dropWhile =
   |- ∀P ls. EXISTS ($~ ∘ P) ls ⇒ ¬P (HD (dropWhile P ls)):
   thm
val IMAGE_EL_count_LENGTH =
   |- ∀f ls. IMAGE (λn. f (EL n ls)) (count (LENGTH ls)) = IMAGE f (set ls):
   thm
val IMP_EVERY_LUPDATE =
   |- ∀xs h i. P h ∧ EVERY P xs ⇒ EVERY P (LUPDATE h i xs):
   thm
val INDEX_FIND_def =
   |- (∀i P. INDEX_FIND i P [] = NONE) ∧
   ∀i P h t.
     INDEX_FIND i P (h::t) =
     if P h then SOME (i,h) else INDEX_FIND (SUC i) P t:
   thm
val INDEX_OF_def =
   |- ∀x. INDEX_OF x = OPTION_MAP FST ∘ INDEX_FIND 0 ($= x):
   thm
val INFINITE_LIST_UNIV =
   |- INFINITE 𝕌(:α list):
   thm
val INJ_MAP_EQ =
   |- ∀f l1 l2.
     INJ f (set l1 ∪ set l2) 𝕌(:β) ∧ (MAP f l1 = MAP f l2) ⇒ (l1 = l2):
   thm
val INJ_MAP_EQ_IFF =
   |- ∀f l1 l2.
     INJ f (set l1 ∪ set l2) 𝕌(:β) ⇒ ((MAP f l1 = MAP f l2) ⇔ (l1 = l2)):
   thm
val ITSET_eq_FOLDL_SET_TO_LIST =
   |- ∀s.
     FINITE s ⇒ ∀f a. ITSET f s a = FOLDL (combin$C f) a (SET_TO_LIST s):
   thm
val LAST_APPEND_CONS =
   |- ∀h l1 l2. LAST (l1 ++ h::l2) = LAST (h::l2):
   thm
val LAST_CONS =
   |- (∀x. LAST [x] = x) ∧ ∀x y z. LAST (x::y::z) = LAST (y::z):
   thm
val LAST_CONS_cond =
   |- LAST (h::t) = if t = [] then h else LAST t:
   thm
val LAST_DEF =
   |- ∀h t. LAST (h::t) = if t = [] then h else LAST t:
   thm
val LAST_EL =
   |- ∀ls. ls ≠ [] ⇒ (LAST ls = EL (PRE (LENGTH ls)) ls):
   thm
val LAST_MAP =
   |- ∀l f. l ≠ [] ⇒ (LAST (MAP f l) = f (LAST l)):
   thm
val LAST_REVERSE =
   |- ∀ls. ls ≠ [] ⇒ (LAST (REVERSE ls) = HD ls):
   thm
val LAST_SNOC =
   |- ∀x l. LAST (SNOC x l) = x:
   thm
val LAST_compute =
   |- (∀x. LAST [x] = x) ∧ ∀h1 h2 t. LAST (h1::h2::t) = LAST (h2::t):
   thm
val LENGTH =
   |- (LENGTH [] = 0) ∧ ∀h t. LENGTH (h::t) = SUC (LENGTH t):
   thm
val LENGTH_APPEND =
   |- ∀l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2:
   thm
val LENGTH_CONS =
   |- ∀l n. (LENGTH l = SUC n) ⇔ ∃h l'. (LENGTH l' = n) ∧ (l = h::l'):
   thm
val LENGTH_DROP =
   |- ∀n l. LENGTH (DROP n l) = LENGTH l − n:
   thm
val LENGTH_EQ_CONS =
   |- ∀P n.
     (∀l. (LENGTH l = SUC n) ⇒ P l) ⇔
     ∀l. (LENGTH l = n) ⇒ (λl. ∀x. P (x::l)) l:
   thm
val LENGTH_EQ_NIL =
   |- ∀P. (∀l. (LENGTH l = 0) ⇒ P l) ⇔ P []:
   thm
val LENGTH_EQ_NUM =
   |- (∀l. (LENGTH l = 0) ⇔ (l = [])) ∧
   (∀l n. (LENGTH l = SUC n) ⇔ ∃h l'. (LENGTH l' = n) ∧ (l = h::l')) ∧
   ∀l n1 n2.
     (LENGTH l = n1 + n2) ⇔
     ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2):
   thm
val LENGTH_EQ_NUM_compute =
   |- (∀l. (LENGTH l = 0) ⇔ (l = [])) ∧
   (∀l n.
      (LENGTH l = NUMERAL (BIT1 n)) ⇔
      ∃h l'. (LENGTH l' = NUMERAL (BIT1 n) − 1) ∧ (l = h::l')) ∧
   (∀l n.
      (LENGTH l = NUMERAL (BIT2 n)) ⇔
      ∃h l'. (LENGTH l' = NUMERAL (BIT1 n)) ∧ (l = h::l')) ∧
   ∀l n1 n2.
     (LENGTH l = n1 + n2) ⇔
     ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2):
   thm
val LENGTH_EQ_SUM =
   |- ∀l n1 n2.
     (LENGTH l = n1 + n2) ⇔
     ∃l1 l2. (LENGTH l1 = n1) ∧ (LENGTH l2 = n2) ∧ (l = l1 ++ l2):
   thm
val LENGTH_FILTER_LEQ_MONO =
   |- ∀P Q.
     (∀x. P x ⇒ Q x) ⇒ ∀ls. LENGTH (FILTER P ls) ≤ LENGTH (FILTER Q ls):
   thm
val LENGTH_FRONT_CONS =
   |- ∀x xs. LENGTH (FRONT (x::xs)) = LENGTH xs:
   thm
val LENGTH_GENLIST =
   |- ∀f n. LENGTH (GENLIST f n) = n:
   thm
val LENGTH_LEN =
   |- ∀L. LENGTH L = LEN L 0:
   thm
val LENGTH_LUPDATE =
   |- ∀x n ys. LENGTH (LUPDATE x n ys) = LENGTH ys:
   thm
val LENGTH_MAP =
   |- ∀l f. LENGTH (MAP f l) = LENGTH l:
   thm
val LENGTH_NIL =
   |- ∀l. (LENGTH l = 0) ⇔ (l = []):
   thm
val LENGTH_NIL_SYM =
   |- (0 = LENGTH l) ⇔ (l = []):
   thm
val LENGTH_REVERSE =
   |- ∀l. LENGTH (REVERSE l) = LENGTH l:
   thm
val LENGTH_SNOC =
   |- ∀x l. LENGTH (SNOC x l) = SUC (LENGTH l):
   thm
val LENGTH_TAKE =
   |- ∀n l. n ≤ LENGTH l ⇒ (LENGTH (TAKE n l) = n):
   thm
val LENGTH_TAKE_EQ =
   |- LENGTH (TAKE n xs) = if n ≤ LENGTH xs then n else LENGTH xs:
   thm
val LENGTH_TL =
   |- ∀l. 0 < LENGTH l ⇒ (LENGTH (TL l) = LENGTH l − 1):
   thm
val LENGTH_UNZIP =
   |- ∀pl.
     (LENGTH (FST (UNZIP pl)) = LENGTH pl) ∧
     (LENGTH (SND (UNZIP pl)) = LENGTH pl):
   thm
val LENGTH_ZIP =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     (LENGTH (ZIP (l1,l2)) = LENGTH l1) ∧
     (LENGTH (ZIP (l1,l2)) = LENGTH l2):
   thm
val LENGTH_dropWhile_LESS_EQ =
   |- ∀P ls. LENGTH (dropWhile P ls) ≤ LENGTH ls:
   thm
val LENGTH_o_REVERSE =
   |- (LENGTH ∘ REVERSE = LENGTH) ∧ (LENGTH ∘ REVERSE ∘ f = LENGTH ∘ f):
   thm
val LEN_DEF =
   |- (∀n. LEN [] n = n) ∧ ∀h t n. LEN (h::t) n = LEN t (n + 1):
   thm
val LEN_LENGTH_LEM =
   |- ∀L n. LEN L n = LENGTH L + n:
   thm
val LIST_APPLY_def =
   |- ∀fs xs. fs <*> xs = LIST_BIND fs (combin$C MAP xs):
   thm
val LIST_APPLY_o =
   |- [$o] <*> fs <*> gs <*> xs = fs <*> (gs <*> xs):
   thm
val LIST_BIND_APPEND =
   |- LIST_BIND (l1 ++ l2) f = LIST_BIND l1 f ++ LIST_BIND l2 f:
   thm
val LIST_BIND_ID =
   |- (LIST_BIND l (λx. x) = FLAT l) ∧ (LIST_BIND l I = FLAT l):
   thm
val LIST_BIND_LIST_BIND =
   |- LIST_BIND (LIST_BIND l g) f = LIST_BIND l (combin$C LIST_BIND f ∘ g):
   thm
val LIST_BIND_MAP =
   |- LIST_BIND (MAP f l) g = LIST_BIND l (g ∘ f):
   thm
val LIST_BIND_THM =
   |- (LIST_BIND [] f = []) ∧ (LIST_BIND (h::t) f = f h ++ LIST_BIND t f):
   thm
val LIST_BIND_def =
   |- ∀l f. LIST_BIND l f = FLAT (MAP f l):
   thm
val LIST_EQ =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ∧
     (∀x. x < LENGTH l1 ⇒ (EL x l1 = EL x l2)) ⇒
     (l1 = l2):
   thm
val LIST_EQ_MAP_PAIR =
   |- ∀l1 l2.
     (MAP FST l1 = MAP FST l2) ∧ (MAP SND l1 = MAP SND l2) ⇒ (l1 = l2):
   thm
val LIST_EQ_REWRITE =
   |- ∀l1 l2.
     (l1 = l2) ⇔
     (LENGTH l1 = LENGTH l2) ∧ ∀x. x < LENGTH l1 ⇒ (EL x l1 = EL x l2):
   thm
val LIST_IGNORE_BIND_def =
   |- ∀m1 m2. LIST_IGNORE_BIND m1 m2 = LIST_BIND m1 (K m2):
   thm
val LIST_LIFT2_def =
   |- ∀f xs ys. LIST_LIFT2 f xs ys = MAP f xs <*> ys:
   thm
val LIST_NOT_EQ =
   |- ∀l1 l2. l1 ≠ l2 ⇒ ∀h1 h2. h1::l1 ≠ h2::l2:
   thm
val LIST_REL_CONJ =
   |- LIST_REL (λa b. P a b ∧ Q a b) l1 l2 ⇔
   LIST_REL (λa b. P a b) l1 l2 ∧ LIST_REL (λa b. Q a b) l1 l2:
   thm
val LIST_REL_CONS1 =
   |- LIST_REL R (h::t) xs ⇔
   ∃h' t'. (xs = h'::t') ∧ R h h' ∧ LIST_REL R t t':
   thm
val LIST_REL_CONS2 =
   |- LIST_REL R xs (h::t) ⇔
   ∃h' t'. (xs = h'::t') ∧ R h' h ∧ LIST_REL R t' t:
   thm
val LIST_REL_EL_EQN =
   |- ∀R l1 l2.
     LIST_REL R l1 l2 ⇔
     (LENGTH l1 = LENGTH l2) ∧ ∀n. n < LENGTH l1 ⇒ R (EL n l1) (EL n l2):
   thm
val LIST_REL_EVERY_ZIP =
   |- ∀R l1 l2.
     LIST_REL R l1 l2 ⇔
     (LENGTH l1 = LENGTH l2) ∧ EVERY (UNCURRY R) (ZIP (l1,l2)):
   thm
val LIST_REL_LENGTH =
   |- ∀x y. LIST_REL R x y ⇒ (LENGTH x = LENGTH y):
   thm
val LIST_REL_MAP1 =
   |- LIST_REL R (MAP f l1) l2 ⇔ LIST_REL (R ∘ f) l1 l2:
   thm
val LIST_REL_MAP2 =
   |- LIST_REL (λa b. R a b) l1 (MAP f l2) ⇔
   LIST_REL (λa b. R a (f b)) l1 l2:
   thm
val LIST_REL_NIL =
   |- (LIST_REL R [] x ⇔ (x = [])) ∧ (LIST_REL R [] y ⇔ (y = [])):
   thm
val LIST_REL_cases =
   |- ∀R a0 a1.
     LIST_REL R a0 a1 ⇔
     (a0 = []) ∧ (a1 = []) ∨
     ∃h1 h2 t1 t2.
       (a0 = h1::t1) ∧ (a1 = h2::t2) ∧ R h1 h2 ∧ LIST_REL R t1 t2:
   thm
val LIST_REL_def =
   |- (LIST_REL R [] [] ⇔ T) ∧ (LIST_REL R (a::as) [] ⇔ F) ∧
   (LIST_REL R [] (b::bs) ⇔ F) ∧
   (LIST_REL R (a::as) (b::bs) ⇔ R a b ∧ LIST_REL R as bs):
   thm
val LIST_REL_ind =
   |- ∀R LIST_REL'.
     LIST_REL' [] [] ∧
     (∀h1 h2 t1 t2.
        R h1 h2 ∧ LIST_REL' t1 t2 ⇒ LIST_REL' (h1::t1) (h2::t2)) ⇒
     ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1:
   thm
val LIST_REL_mono =
   |- (∀x y. R1 x y ⇒ R2 x y) ⇒ LIST_REL R1 l1 l2 ⇒ LIST_REL R2 l1 l2:
   thm
val LIST_REL_rules =
   |- ∀R.
     LIST_REL R [] [] ∧
     ∀h1 h2 t1 t2.
       R h1 h2 ∧ LIST_REL R t1 t2 ⇒ LIST_REL R (h1::t1) (h2::t2):
   thm
val LIST_REL_strongind =
   |- ∀R LIST_REL'.
     LIST_REL' [] [] ∧
     (∀h1 h2 t1 t2.
        R h1 h2 ∧ LIST_REL R t1 t2 ∧ LIST_REL' t1 t2 ⇒
        LIST_REL' (h1::t1) (h2::t2)) ⇒
     ∀a0 a1. LIST_REL R a0 a1 ⇒ LIST_REL' a0 a1:
   thm
val LIST_REL_trans =
   |- ∀l1 l2 l3.
     (∀n.
        n < LENGTH l1 ∧ R (EL n l1) (EL n l2) ∧ R (EL n l2) (EL n l3) ⇒
        R (EL n l1) (EL n l3)) ∧ LIST_REL R l1 l2 ∧ LIST_REL R l2 l3 ⇒
     LIST_REL R l1 l3:
   thm
val LIST_TO_SET =
   |- (set [] = ∅) ∧ (set (h::t) = h INSERT set t):
   thm
val LIST_TO_SET_APPEND =
   |- ∀l1 l2. set (l1 ++ l2) = set l1 ∪ set l2:
   thm
val LIST_TO_SET_DEF =
   |- (∀x. set [] x ⇔ F) ∧ ∀h t x. set (h::t) x ⇔ (x = h) ∨ set t x:
   thm
val LIST_TO_SET_EQ_EMPTY =
   |- ((set l = ∅) ⇔ (l = [])) ∧ ((∅ = set l) ⇔ (l = [])):
   thm
val LIST_TO_SET_FILTER =
   |- set (FILTER P l) = {x | P x} ∩ set l:
   thm
val LIST_TO_SET_FLAT =
   |- ∀ls. set (FLAT ls) = BIGUNION (set (MAP set ls)):
   thm
val LIST_TO_SET_GENLIST =
   |- ∀f n. set (GENLIST f n) = IMAGE f (count n):
   thm
val LIST_TO_SET_MAP =
   |- ∀f l. set (MAP f l) = IMAGE f (set l):
   thm
val LIST_TO_SET_REVERSE =
   |- ∀ls. set (REVERSE ls) = set ls:
   thm
val LIST_TO_SET_SNOC =
   |- set (SNOC x ls) = x INSERT set ls:
   thm
val LIST_TO_SET_THM =
   |- (set [] = ∅) ∧ (set (h::t) = h INSERT set t):
   thm
val LLEX_CONG =
   |- ∀R l1 l2 R' l1' l2'.
     (l1 = l1') ∧ (l2 = l2') ∧
     (∀a b. MEM a l1' ∧ MEM b l2' ⇒ (R a b ⇔ R' a b)) ⇒
     (LLEX R l1 l2 ⇔ LLEX R' l1' l2'):
   thm
val LLEX_EL_THM =
   |- ∀R l1 l2.
     LLEX R l1 l2 ⇔
     ∃n.
       n ≤ LENGTH l1 ∧ n < LENGTH l2 ∧ (TAKE n l1 = TAKE n l2) ∧
       (n < LENGTH l1 ⇒ R (EL n l1) (EL n l2)):
   thm
val LLEX_MONO =
   |- (∀x y. R1 x y ⇒ R2 x y) ⇒ LLEX R1 x y ⇒ LLEX R2 x y:
   thm
val LLEX_NIL2 =
   |- ¬LLEX R l []:
   thm
val LLEX_THM =
   |- (¬LLEX R [] [] ∧ ¬LLEX R (h1::t1) []) ∧ LLEX R [] (h2::t2) ∧
   (LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ (h1 = h2) ∧ LLEX R t1 t2):
   thm
val LLEX_def =
   |- (∀R l2. LLEX R [] l2 ⇔ l2 ≠ []) ∧
   ∀R h1 t1 l2.
     LLEX R (h1::t1) l2 ⇔
     case l2 of
       [] => F
     | h2::t2 =>
         if R h1 h2 then T else if h1 = h2 then LLEX R t1 t2 else F:
   thm
val LLEX_not_WF =
   |- (∃a b. R a b) ⇒ ¬WF (LLEX R):
   thm
val LLEX_total =
   |- total (RC R) ⇒ total (RC (LLEX R)):
   thm
val LLEX_transitive =
   |- transitive R ⇒ transitive (LLEX R):
   thm
val LRC_MEM =
   |- LRC R ls x y ∧ MEM e ls ⇒ ∃z t. R e z ∧ LRC R t z y:
   thm
val LRC_MEM_right =
   |- LRC R (h::t) x y ∧ MEM e t ⇒ ∃z p. R z e ∧ LRC R p x z:
   thm
val LRC_def =
   |- (∀R x y. LRC R [] x y ⇔ (x = y)) ∧
   ∀R h t x y. LRC R (h::t) x y ⇔ (x = h) ∧ ∃z. R x z ∧ LRC R t z y:
   thm
val LUPDATE_LENGTH =
   |- ∀xs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys:
   thm
val LUPDATE_MAP =
   |- ∀x n l f. MAP f (LUPDATE x n l) = LUPDATE (f x) n (MAP f l):
   thm
val LUPDATE_NIL =
   |- ∀xs n x. (LUPDATE x n xs = []) ⇔ (xs = []):
   thm
val LUPDATE_SAME =
   |- ∀n ls. n < LENGTH ls ⇒ (LUPDATE (EL n ls) n ls = ls):
   thm
val LUPDATE_SEM =
   |- (∀e n l. LENGTH (LUPDATE e n l) = LENGTH l) ∧
   ∀e n l p.
     p < LENGTH l ⇒ (EL p (LUPDATE e n l) = if p = n then e else EL p l):
   thm
val LUPDATE_SNOC =
   |- ∀ys k x y.
     LUPDATE x k (SNOC y ys) =
     if k = LENGTH ys then SNOC x ys else SNOC y (LUPDATE x k ys):
   thm
val LUPDATE_SOME_MAP =
   |- ∀xs n f h.
     LUPDATE (SOME (f h)) n (MAP (OPTION_MAP f) xs) =
     MAP (OPTION_MAP f) (LUPDATE (SOME h) n xs):
   thm
val LUPDATE_compute =
   |- (∀e n. LUPDATE e n [] = []) ∧ (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
   (∀e n x l.
      LUPDATE e (NUMERAL (BIT1 n)) (x::l) =
      x::LUPDATE e (NUMERAL (BIT1 n) − 1) l) ∧
   ∀e n x l.
     LUPDATE e (NUMERAL (BIT2 n)) (x::l) =
     x::LUPDATE e (NUMERAL (BIT1 n)) l:
   thm
val LUPDATE_def =
   |- (∀e n. LUPDATE e n [] = []) ∧ (∀e x l. LUPDATE e 0 (x::l) = e::l) ∧
   ∀e n x l. LUPDATE e (SUC n) (x::l) = x::LUPDATE e n l:
   thm
val MAP =
   |- (∀f. MAP f [] = []) ∧ ∀f h t. MAP f (h::t) = f h::MAP f t:
   thm
val MAP2 =
   |- (∀f. MAP2 f [] [] = []) ∧
   ∀f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2:
   thm
val MAP2_CONG =
   |- ∀l1 l1' l2 l2' f f'.
     (l1 = l1') ∧ (l2 = l2') ∧
     (∀x y. MEM x l1' ∧ MEM y l2' ⇒ (f x y = f' x y)) ⇒
     (MAP2 f l1 l2 = MAP2 f' l1' l2'):
   thm
val MAP2_DEF =
   |- (∀t2 t1 h2 h1 f. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2) ∧
   (∀y f. MAP2 f [] y = []) ∧ ∀v5 v4 f. MAP2 f (v4::v5) [] = []:
   thm
val MAP2_MAP =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2)):
   thm
val MAP2_ZIP =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ∀f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2)):
   thm
val MAP2_ind =
   |- ∀P.
     (∀f h1 t1 h2 t2. P f t1 t2 ⇒ P f (h1::t1) (h2::t2)) ∧
     (∀f y. P f [] y) ∧ (∀f v4 v5. P f (v4::v5) []) ⇒
     ∀v v1 v2. P v v1 v2:
   thm
val MAP_APPEND =
   |- ∀f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2:
   thm
val MAP_APPEND_MAP_EQ =
   |- ∀xs ys.
     (MAP f1 xs ++ MAP g1 ys = MAP f2 xs ++ MAP g2 ys) ⇔
     (MAP f1 xs = MAP f2 xs) ∧ (MAP g1 ys = MAP g2 ys):
   thm
val MAP_CONG =
   |- ∀l1 l2 f f'.
     (l1 = l2) ∧ (∀x. MEM x l2 ⇒ (f x = f' x)) ⇒ (MAP f l1 = MAP f' l2):
   thm
val MAP_EQ_APPEND =
   |- (MAP f l = l1 ++ l2) ⇔
   ∃l10 l20. (l = l10 ++ l20) ∧ (l1 = MAP f l10) ∧ (l2 = MAP f l20):
   thm
val MAP_EQ_CONS =
   |- (MAP f l = h::t) ⇔ ∃x0 t0. (l = x0::t0) ∧ (h = f x0) ∧ (t = MAP f t0):
   thm
val MAP_EQ_EVERY2 =
   |- ∀f1 f2 l1 l2.
     (MAP f1 l1 = MAP f2 l2) ⇔
     (LENGTH l1 = LENGTH l2) ∧ LIST_REL (λx y. f1 x = f2 y) l1 l2:
   thm
val MAP_EQ_NIL =
   |- ∀l f. ((MAP f l = []) ⇔ (l = [])) ∧ (([] = MAP f l) ⇔ (l = [])):
   thm
val MAP_EQ_SING =
   |- (MAP f l = [x]) ⇔ ∃x0. (l = [x0]) ∧ (x = f x0):
   thm
val MAP_EQ_f =
   |- ∀f1 f2 l. (MAP f1 l = MAP f2 l) ⇔ ∀e. MEM e l ⇒ (f1 e = f2 e):
   thm
val MAP_FLAT =
   |- MAP f (FLAT l) = FLAT (MAP (MAP f) l):
   thm
val MAP_GENLIST =
   |- ∀f g n. MAP f (GENLIST g n) = GENLIST (f ∘ g) n:
   thm
val MAP_ID =
   |- (MAP (λx. x) l = l) ∧ (MAP I l = l):
   thm
val MAP_LIST_BIND =
   |- MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ∘ g):
   thm
val MAP_MAP_o =
   |- ∀f g l. MAP f (MAP g l) = MAP (f ∘ g) l:
   thm
val MAP_SNOC =
   |- ∀f x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l):
   thm
val MAP_TAKE =
   |- ∀f n l. MAP f (TAKE n l) = TAKE n (MAP f l):
   thm
val MAP_TL =
   |- ∀l f. ¬NULL l ⇒ (MAP f (TL l) = TL (MAP f l)):
   thm
val MAP_ZIP =
   |- (LENGTH l1 = LENGTH l2) ⇒
   (MAP FST (ZIP (l1,l2)) = l1) ∧ (MAP SND (ZIP (l1,l2)) = l2) ∧
   (MAP (f ∘ FST) (ZIP (l1,l2)) = MAP f l1) ∧
   (MAP (g ∘ SND) (ZIP (l1,l2)) = MAP g l2):
   thm
val MAP_ZIP_SAME =
   |- ∀ls f. MAP f (ZIP (ls,ls)) = MAP (λx. f (x,x)) ls:
   thm
val MAP_o =
   |- ∀f g. MAP (f ∘ g) = MAP f ∘ MAP g:
   thm
val MEM =
   |- (∀x. MEM x [] ⇔ F) ∧ ∀x h t. MEM x (h::t) ⇔ (x = h) ∨ MEM x t:
   thm
val MEM_APPEND =
   |- ∀e l1 l2. MEM e (l1 ++ l2) ⇔ MEM e l1 ∨ MEM e l2:
   thm
val MEM_APPEND_lemma =
   |- ∀a b c d x.
     (a ++ [x] ++ b = c ++ [x] ++ d) ∧ ¬MEM x b ∧ ¬MEM x a ⇒
     (a = c) ∧ (b = d):
   thm
val MEM_DROP =
   |- ∀x ls n.
     MEM x (DROP n ls) ⇔
     n < LENGTH ls ∧ (x = EL n ls) ∨ MEM x (DROP (SUC n) ls):
   thm
val MEM_EL =
   |- ∀l x. MEM x l ⇔ ∃n. n < LENGTH l ∧ (x = EL n l):
   thm
val MEM_FILTER =
   |- ∀P L x. MEM x (FILTER P L) ⇔ P x ∧ MEM x L:
   thm
val MEM_FLAT =
   |- ∀x L. MEM x (FLAT L) ⇔ ∃l. MEM l L ∧ MEM x l:
   thm
val MEM_GENLIST =
   |- MEM x (GENLIST f n) ⇔ ∃m. m < n ∧ (x = f m):
   thm
val MEM_LUPDATE =
   |- ∀l x y i.
     MEM x (LUPDATE y i l) ⇔
     i < LENGTH l ∧ (x = y) ∨ ∃j. j < LENGTH l ∧ i ≠ j ∧ (EL j l = x):
   thm
val MEM_LUPDATE_E =
   |- ∀l x y i. MEM x (LUPDATE y i l) ⇒ (x = y) ∨ MEM x l:
   thm
val MEM_MAP =
   |- ∀l f x. MEM x (MAP f l) ⇔ ∃y. (x = f y) ∧ MEM y l:
   thm
val MEM_REVERSE =
   |- ∀l x. MEM x (REVERSE l) ⇔ MEM x l:
   thm
val MEM_SET_TO_LIST =
   |- ∀s. FINITE s ⇒ ∀x. MEM x (SET_TO_LIST s) ⇔ x ∈ s:
   thm
val MEM_SNOC =
   |- ∀y x l. MEM y (SNOC x l) ⇔ (y = x) ∨ MEM y l:
   thm
val MEM_SPLIT =
   |- ∀x l. MEM x l ⇔ ∃l1 l2. l = l1 ++ x::l2:
   thm
val MEM_SPLIT_APPEND_first =
   |- MEM e l ⇔ ∃pfx sfx. (l = pfx ++ [e] ++ sfx) ∧ ¬MEM e pfx:
   thm
val MEM_SPLIT_APPEND_last =
   |- MEM e l ⇔ ∃pfx sfx. (l = pfx ++ [e] ++ sfx) ∧ ¬MEM e sfx:
   thm
val MEM_ZIP =
   |- ∀l1 l2 p.
     (LENGTH l1 = LENGTH l2) ⇒
     (MEM p (ZIP (l1,l2)) ⇔ ∃n. n < LENGTH l1 ∧ (p = (EL n l1,EL n l2))):
   thm
val MEM_ZIP_MEM_MAP =
   |- (LENGTH (FST ps) = LENGTH (SND ps)) ∧ MEM p (ZIP ps) ⇒
   MEM (FST p) (FST ps) ∧ MEM (SND p) (SND ps):
   thm
val MEM_dropWhile_IMP =
   |- ∀P ls x. MEM x (dropWhile P ls) ⇒ MEM x ls:
   thm
val MONO_EVERY =
   |- (∀x. P x ⇒ Q x) ⇒ EVERY P l ⇒ EVERY Q l:
   thm
val MONO_EXISTS =
   |- (∀x. P x ⇒ Q x) ⇒ EXISTS P l ⇒ EXISTS Q l:
   thm
val NOT_CONS_NIL =
   |- ∀a1 a0. a0::a1 ≠ []:
   thm
val NOT_EQ_LIST =
   |- ∀h1 h2. h1 ≠ h2 ⇒ ∀l1 l2. h1::l1 ≠ h2::l2:
   thm
val NOT_EVERY =
   |- ∀P l. ¬EVERY P l ⇔ EXISTS ($~ ∘ P) l:
   thm
val NOT_EXISTS =
   |- ∀P l. ¬EXISTS P l ⇔ EVERY ($~ ∘ P) l:
   thm
val NOT_NIL_CONS =
   |- ∀a1 a0. [] ≠ a0::a1:
   thm
val NOT_NIL_EQ_LENGTH_NOT_0 =
   |- x ≠ [] ⇔ 0 < LENGTH x:
   thm
val NOT_NULL_MEM =
   |- ∀l. ¬NULL l ⇔ ∃e. MEM e l:
   thm
val NRC_LRC =
   |- NRC R n x y ⇔ ∃ls. LRC R ls x y ∧ (LENGTH ls = n):
   thm
val NULL =
   |- NULL [] ∧ ∀h t. ¬NULL (h::t):
   thm
val NULL_DEF =
   |- (NULL [] ⇔ T) ∧ ∀h t. NULL (h::t) ⇔ F:
   thm
val NULL_EQ =
   |- ∀l. NULL l ⇔ (l = []):
   thm
val NULL_FILTER =
   |- ∀P ls. NULL (FILTER P ls) ⇔ ∀x. MEM x ls ⇒ ¬P x:
   thm
val NULL_GENLIST =
   |- ∀n f. NULL (GENLIST f n) ⇔ (n = 0):
   thm
val NULL_LENGTH =
   |- ∀l. NULL l ⇔ (LENGTH l = 0):
   thm
val OPT_MMAP_def =
   |- (∀f. OPT_MMAP f [] = SOME []) ∧
   ∀f h0 t0.
     OPT_MMAP f (h0::t0) =
     OPTION_BIND (f h0)
       (λh. OPTION_BIND (OPT_MMAP f t0) (λt. SOME (h::t))):
   thm
val PAD_LEFT =
   |- ∀c n s. PAD_LEFT c n s = GENLIST (K c) (n − LENGTH s) ++ s:
   thm
val PAD_RIGHT =
   |- ∀c n s. PAD_RIGHT c n s = s ++ GENLIST (K c) (n − LENGTH s):
   thm
val REVERSE_11 =
   |- ∀l1 l2. (REVERSE l1 = REVERSE l2) ⇔ (l1 = l2):
   thm
val REVERSE_APPEND =
   |- ∀l1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1:
   thm
val REVERSE_DEF =
   |- (REVERSE [] = []) ∧ ∀h t. REVERSE (h::t) = REVERSE t ++ [h]:
   thm
val REVERSE_EQ_NIL =
   |- (REVERSE l = []) ⇔ (l = []):
   thm
val REVERSE_EQ_SING =
   |- (REVERSE l = [e]) ⇔ (l = [e]):
   thm
val REVERSE_GENLIST =
   |- REVERSE (GENLIST f n) = GENLIST (λm. f (PRE n − m)) n:
   thm
val REVERSE_REV =
   |- ∀L. REVERSE L = REV L []:
   thm
val REVERSE_REVERSE =
   |- ∀l. REVERSE (REVERSE l) = l:
   thm
val REVERSE_SNOC =
   |- ∀x l. REVERSE (SNOC x l) = x::REVERSE l:
   thm
val REVERSE_SNOC_DEF =
   |- (REVERSE [] = []) ∧ ∀x l. REVERSE (x::l) = SNOC x (REVERSE l):
   thm
val REVERSE_o_REVERSE =
   |- REVERSE ∘ REVERSE ∘ f = f:
   thm
val REV_DEF =
   |- (∀acc. REV [] acc = acc) ∧ ∀h t acc. REV (h::t) acc = REV t (h::acc):
   thm
val REV_REVERSE_LEM =
   |- ∀L1 L2. REV L1 L2 = REVERSE L1 ++ L2:
   thm
val SET_TO_LIST_CARD =
   |- ∀s. FINITE s ⇒ (LENGTH (SET_TO_LIST s) = CARD s):
   thm
val SET_TO_LIST_EMPTY =
   |- SET_TO_LIST ∅ = []:
   thm
val SET_TO_LIST_IND =
   |- ∀P. (∀s. (FINITE s ∧ s ≠ ∅ ⇒ P (REST s)) ⇒ P s) ⇒ ∀v. P v:
   thm
val SET_TO_LIST_INV =
   |- ∀s. FINITE s ⇒ (set (SET_TO_LIST s) = s):
   thm
val SET_TO_LIST_IN_MEM =
   |- ∀s. FINITE s ⇒ ∀x. x ∈ s ⇔ MEM x (SET_TO_LIST s):
   thm
val SET_TO_LIST_SING =
   |- SET_TO_LIST {x} = [x]:
   thm
val SET_TO_LIST_THM =
   |- FINITE s ⇒
   (SET_TO_LIST s =
    if s = ∅ then [] else CHOICE s::SET_TO_LIST (REST s)):
   thm
val SET_TO_LIST_primitive_def =
   |- SET_TO_LIST =
   WFREC (@R. WF R ∧ ∀s. FINITE s ∧ s ≠ ∅ ⇒ R (REST s) s)
     (λSET_TO_LIST a.
        I
          (if FINITE a then
             if a = ∅ then [] else CHOICE a::SET_TO_LIST (REST a)
           else ARB)):
   thm
val SINGL_APPLY_MAP =
   |- [f] <*> l = MAP f l:
   thm
val SINGL_APPLY_PERMUTE =
   |- fs <*> [x] = [(λf. f x)] <*> fs:
   thm
val SINGL_LIST_APPLY_L =
   |- LIST_BIND [x] f = f x:
   thm
val SINGL_LIST_APPLY_R =
   |- LIST_BIND l (λx. [x]) = l:
   thm
val SINGL_SINGL_APPLY =
   |- [f] <*> [x] = [f x]:
   thm
val SNOC =
   |- (∀x. SNOC x [] = [x]) ∧ ∀x x' l. SNOC x (x'::l) = x'::SNOC x l:
   thm
val SNOC_11 =
   |- ∀x y a b. (SNOC x y = SNOC a b) ⇔ (x = a) ∧ (y = b):
   thm
val SNOC_APPEND =
   |- ∀x l. SNOC x l = l ++ [x]:
   thm
val SNOC_Axiom =
   |- ∀e f. ∃fn. (fn [] = e) ∧ ∀x l. fn (SNOC x l) = f x l (fn l):
   thm
val SNOC_CASES =
   |- ∀ll. (ll = []) ∨ ∃x l. ll = SNOC x l:
   thm
val SNOC_INDUCT =
   |- ∀P. P [] ∧ (∀l. P l ⇒ ∀x. P (SNOC x l)) ⇒ ∀l. P l:
   thm
val SUM =
   |- (SUM [] = 0) ∧ ∀h t. SUM (h::t) = h + SUM t:
   thm
val SUM_ACC_DEF =
   |- (∀acc. SUM_ACC [] acc = acc) ∧
   ∀h t acc. SUM_ACC (h::t) acc = SUM_ACC t (h + acc):
   thm
val SUM_ACC_SUM_LEM =
   |- ∀L n. SUM_ACC L n = SUM L + n:
   thm
val SUM_APPEND =
   |- ∀l1 l2. SUM (l1 ++ l2) = SUM l1 + SUM l2:
   thm
val SUM_IMAGE_LIST_TO_SET_upper_bound =
   |- ∀ls. ∑ f (set ls) ≤ SUM (MAP f ls):
   thm
val SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST =
   |- FINITE s ⇒ (∑ f s = SUM (MAP f (SET_TO_LIST s))):
   thm
val SUM_MAP_FOLDL =
   |- ∀ls. SUM (MAP f ls) = FOLDL (λa e. a + f e) 0 ls:
   thm
val SUM_MAP_MEM_bound =
   |- ∀f x ls. MEM x ls ⇒ f x ≤ SUM (MAP f ls):
   thm
val SUM_MAP_PLUS =
   |- ∀f g ls.
     SUM (MAP (λx. f x + g x) ls) = SUM (MAP f ls) + SUM (MAP g ls):
   thm
val SUM_MAP_PLUS_ZIP =
   |- ∀ls1 ls2.
     (LENGTH ls1 = LENGTH ls2) ∧ (∀x y. f (x,y) = g x + h y) ⇒
     (SUM (MAP f (ZIP (ls1,ls2))) = SUM (MAP g ls1) + SUM (MAP h ls2)):
   thm
val SUM_SNOC =
   |- ∀x l. SUM (SNOC x l) = SUM l + x:
   thm
val SUM_SUM_ACC =
   |- ∀L. SUM L = SUM_ACC L 0:
   thm
val SUM_eq_0 =
   |- ∀ls. (SUM ls = 0) ⇔ ∀x. MEM x ls ⇒ (x = 0):
   thm
val SWAP_REVERSE =
   |- ∀l1 l2. (l1 = REVERSE l2) ⇔ (l2 = REVERSE l1):
   thm
val SWAP_REVERSE_SYM =
   |- ∀l1 l2. (REVERSE l1 = l2) ⇔ (l1 = REVERSE l2):
   thm
val TAKE_0 =
   |- TAKE 0 l = []:
   thm
val TAKE_APPEND1 =
   |- ∀n. n ≤ LENGTH l1 ⇒ (TAKE n (l1 ++ l2) = TAKE n l1):
   thm
val TAKE_APPEND2 =
   |- ∀n.
     LENGTH l1 < n ⇒ (TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2):
   thm
val TAKE_DROP =
   |- ∀n l. TAKE n l ++ DROP n l = l:
   thm
val TAKE_LENGTH_ID =
   |- ∀l. TAKE (LENGTH l) l = l:
   thm
val TAKE_LENGTH_ID_rwt =
   |- ∀l m. (m = LENGTH l) ⇒ (TAKE m l = l):
   thm
val TAKE_LENGTH_TOO_LONG =
   |- ∀l n. LENGTH l ≤ n ⇒ (TAKE n l = l):
   thm
val TAKE_SUM =
   |- ∀n m l. TAKE (n + m) l = TAKE n l ++ TAKE m (DROP n l):
   thm
val TAKE_compute =
   |- (∀l. TAKE 0 l = []) ∧ (∀n. TAKE (NUMERAL (BIT1 n)) [] = []) ∧
   (∀n. TAKE (NUMERAL (BIT2 n)) [] = []) ∧
   (∀n h t.
      TAKE (NUMERAL (BIT1 n)) (h::t) =
      h::TAKE (NUMERAL (BIT1 n) − 1) t) ∧
   ∀n h t. TAKE (NUMERAL (BIT2 n)) (h::t) = h::TAKE (NUMERAL (BIT1 n)) t:
   thm
val TAKE_cons =
   |- 0 < n ⇒ (TAKE n (x::xs) = x::TAKE (n − 1) xs):
   thm
val TAKE_def =
   |- (∀n. TAKE n [] = []) ∧
   ∀n x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n − 1) xs:
   thm
val TAKE_nil =
   |- ∀n. TAKE n [] = []:
   thm
val TAKE_splitAtPki =
   |- TAKE n l = splitAtPki (K ∘ $= n) K l:
   thm
val TL =
   |- ∀h t. TL (h::t) = t:
   thm
val TL_GENLIST =
   |- ∀f n. TL (GENLIST f (SUC n)) = GENLIST (f ∘ SUC) n:
   thm
val TR2_EQ_rules_thm =
   |- (TR2 (M,Oi,Os) (exec cmd)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         ins (NS state (exec cmd)) (Out state (exec cmd)::outStream)) ⇔
    inputTest (inputInterpret x) ∧
    CFG2Interpret (M,Oi,Os)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)) ∧
   (TR2 (M,Oi,Os) (trap cmd)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         ins (NS state (trap cmd)) (Out state (trap cmd)::outStream)) ⇔
    inputTest (inputInterpret x) ∧
    CFG2Interpret (M,Oi,Os)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)) ∧
   (TR2 (M,Oi,Os) discard
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         (x::ins) state outStream)
      (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
         ins (NS state discard) (Out state discard::outStream)) ⇔
    ¬inputTest (inputInterpret x)):
   thm
val TR2_cases =
   |- ∀a0 a1 a2 a3.
     TR2 a0 a1 a2 a3 ⇔
     (∃inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        (a0 = (M,Oi,Os)) ∧ (a1 = exec cmd) ∧
        (a2 =
         CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream) ∧
        (a3 =
         CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret ins (NS state (exec cmd))
           (Out state (exec cmd)::outStream)) ∧
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)) ∨
     (∃inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        (a0 = (M,Oi,Os)) ∧ (a1 = trap cmd) ∧
        (a2 =
         CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream) ∧
        (a3 =
         CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret ins (NS state (trap cmd))
           (Out state (trap cmd)::outStream)) ∧
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)) ∨
     ∃inputInterpret certInterpret inputTest x NS M Oi Os Out state
        certs stateInterpret cmd ins outStream.
       (a0 = (M,Oi,Os)) ∧ (a1 = discard) ∧
       (a2 =
        CFG2 inputInterpret certInterpret inputTest certs stateInterpret
          (x::ins) state outStream) ∧
       (a3 =
        CFG2 inputInterpret certInterpret inputTest certs stateInterpret
          ins (NS state discard) (Out state discard::outStream)) ∧
       ¬inputTest (inputInterpret x):
   thm
val TR2_def =
   |- TR2 =
   (λa0 a1 a2 a3.
      ∀TR2'.
        (∀a0 a1 a2 a3.
           (∃inputInterpret certInterpret inputTest x NS M Oi Os Out
               state certs stateInterpret cmd ins outStream.
              (a0 = (M,Oi,Os)) ∧ (a1 = exec cmd) ∧
              (a2 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret (x::ins) state outStream) ∧
              (a3 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret ins (NS state (exec cmd))
                 (Out state (exec cmd)::outStream)) ∧
              inputTest (inputInterpret x) ∧
              CFG2Interpret (M,Oi,Os)
                (CFG2 inputInterpret certInterpret inputTest certs
                   stateInterpret (x::ins) state outStream)) ∨
           (∃inputInterpret certInterpret inputTest x NS M Oi Os Out
               state certs stateInterpret cmd ins outStream.
              (a0 = (M,Oi,Os)) ∧ (a1 = trap cmd) ∧
              (a2 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret (x::ins) state outStream) ∧
              (a3 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret ins (NS state (trap cmd))
                 (Out state (trap cmd)::outStream)) ∧
              inputTest (inputInterpret x) ∧
              CFG2Interpret (M,Oi,Os)
                (CFG2 inputInterpret certInterpret inputTest certs
                   stateInterpret (x::ins) state outStream)) ∨
           (∃inputInterpret certInterpret inputTest x NS M Oi Os Out
               state certs stateInterpret cmd ins outStream.
              (a0 = (M,Oi,Os)) ∧ (a1 = discard) ∧
              (a2 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret (x::ins) state outStream) ∧
              (a3 =
               CFG2 inputInterpret certInterpret inputTest certs
                 stateInterpret ins (NS state discard)
                 (Out state discard::outStream)) ∧
              ¬inputTest (inputInterpret x)) ⇒
           TR2' a0 a1 a2 a3) ⇒
        TR2' a0 a1 a2 a3):
   thm
val TR2_discard_cmd_rule =
   |- TR2 (M,Oi,Os) discard
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        ins (NS state discard) (Out state discard::outStream)) ⇔
   ¬inputTest (inputInterpret x):
   thm
val TR2_exec_cmd_rule =
   |- ∀inputInterpret certInterpret inputTest certs stateInterpret x cmd
      ins state outStream.
     (∀M Oi Os.
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        (M,Oi,Os) sat prop (SOME cmd)) ⇒
     ∀NS Out M Oi Os.
       TR2 (M,Oi,Os) (exec cmd)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret (x::ins) state outStream)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret ins (NS state (exec cmd))
            (Out state (exec cmd)::outStream)) ⇔
       inputTest (inputInterpret x) ∧
       CFG2Interpret (M,Oi,Os)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret (x::ins) state outStream) ∧
       (M,Oi,Os) sat prop (SOME cmd):
   thm
val TR2_iff_TR_discard_thm =
   |- ∀NS Out outStream state certs certs2 x ins ins2 stateInterpret
      inputInterpret certInterpret inputTest.
     TR2 (M,Oi,Os) discard
       (CFG2 inputInterpret certInterpret inputTest certs2
          stateInterpret (x::ins2) state outStream)
       (CFG2 inputInterpret certInterpret inputTest certs2
          stateInterpret ins2 (NS state discard)
          (Out state discard::outStream)) ⇔
     TR (M,Oi,Os) discard
       (CFG inputTest stateInterpret certs (inputInterpret x::ins) state
          outStream)
       (CFG inputTest stateInterpret certs ins (NS state discard)
          (Out state discard::outStream)):
   thm
val TR2_iff_TR_exec_thm =
   |- ∀inputInterpret certInterpret inputTest certs certs2 stateInterpret x
      P cmd ins ins2 state outStream.
     (inputInterpret x = P says prop (SOME cmd)) ⇒
     (MAP certInterpret certs2 = certs) ⇒
     (∀M Oi Os.
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterpret certs (inputInterpret x::ins)
             state outStream) ⇒
        (M,Oi,Os) sat prop (SOME cmd)) ⇒
     (∀M Oi Os.
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs2
             stateInterpret (x::ins2) state outStream) ⇒
        (M,Oi,Os) sat prop (SOME cmd)) ⇒
     ∀NS Out M Oi Os.
       TR2 (M,Oi,Os) (exec cmd)
         (CFG2 inputInterpret certInterpret inputTest certs2
            stateInterpret (x::ins2) state outStream)
         (CFG2 inputInterpret certInterpret inputTest certs2
            stateInterpret ins2 (NS state (exec cmd))
            (Out state (exec cmd)::outStream)) ⇔
       TR (M,Oi,Os) (exec cmd)
         (CFG inputTest stateInterpret certs (inputInterpret x::ins)
            state outStream)
         (CFG inputTest stateInterpret certs ins (NS state (exec cmd))
            (Out state (exec cmd)::outStream)):
   thm
val TR2_iff_TR_trap_thm =
   |- ∀inputInterpret certInterpret inputTest certs certs2 stateInterpret x
      P cmd ins ins2 state outStream.
     (inputInterpret x = P says prop (SOME cmd)) ⇒
     (MAP certInterpret certs2 = certs) ⇒
     (∀M Oi Os.
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterpret certs (inputInterpret x::ins)
             state outStream) ⇒
        (M,Oi,Os) sat prop NONE) ⇒
     (∀M Oi Os.
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs2
             stateInterpret (x::ins2) state outStream) ⇒
        (M,Oi,Os) sat prop NONE) ⇒
     ∀NS Out M Oi Os.
       TR2 (M,Oi,Os) (trap cmd)
         (CFG2 inputInterpret certInterpret inputTest certs2
            stateInterpret (x::ins2) state outStream)
         (CFG2 inputInterpret certInterpret inputTest certs2
            stateInterpret ins2 (NS state (trap cmd))
            (Out state (trap cmd)::outStream)) ⇔
       TR (M,Oi,Os) (trap cmd)
         (CFG inputTest stateInterpret certs (inputInterpret x::ins)
            state outStream)
         (CFG inputTest stateInterpret certs ins (NS state (trap cmd))
            (Out state (trap cmd)::outStream)):
   thm
val TR2_ind =
   |- ∀TR2'.
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        TR2' (M,Oi,Os) (exec cmd)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state (exec cmd))
             (Out state (exec cmd)::outStream))) ∧
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        TR2' (M,Oi,Os) (trap cmd)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state (trap cmd))
             (Out state (trap cmd)::outStream))) ∧
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        ¬inputTest (inputInterpret x) ⇒
        TR2' (M,Oi,Os) discard
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state discard)
             (Out state discard::outStream))) ⇒
     ∀a0 a1 a2 a3. TR2 a0 a1 a2 a3 ⇒ TR2' a0 a1 a2 a3:
   thm
val TR2_rules =
   |- (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state certs
       stateInterpret cmd ins outStream.
      inputTest (inputInterpret x) ∧
      CFG2Interpret (M,Oi,Os)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream) ⇒
      TR2 (M,Oi,Os) (exec cmd)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret ins (NS state (exec cmd))
           (Out state (exec cmd)::outStream))) ∧
   (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state certs
       stateInterpret cmd ins outStream.
      inputTest (inputInterpret x) ∧
      CFG2Interpret (M,Oi,Os)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream) ⇒
      TR2 (M,Oi,Os) (trap cmd)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret (x::ins) state outStream)
        (CFG2 inputInterpret certInterpret inputTest certs
           stateInterpret ins (NS state (trap cmd))
           (Out state (trap cmd)::outStream))) ∧
   ∀inputInterpret certInterpret inputTest x NS M Oi Os Out state certs
      stateInterpret cmd ins outStream.
     ¬inputTest (inputInterpret x) ⇒
     TR2 (M,Oi,Os) discard
       (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
          (x::ins) state outStream)
       (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
          ins (NS state discard) (Out state discard::outStream)):
   thm
val TR2_strongind =
   |- ∀TR2'.
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        TR2' (M,Oi,Os) (exec cmd)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state (exec cmd))
             (Out state (exec cmd)::outStream))) ∧
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret cmd ins outStream.
        inputTest (inputInterpret x) ∧
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        TR2' (M,Oi,Os) (trap cmd)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state (trap cmd))
             (Out state (trap cmd)::outStream))) ∧
     (∀inputInterpret certInterpret inputTest x NS M Oi Os Out state
         certs stateInterpret ins outStream.
        ¬inputTest (inputInterpret x) ⇒
        TR2' (M,Oi,Os) discard
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret ins (NS state discard)
             (Out state discard::outStream))) ⇒
     ∀a0 a1 a2 a3. TR2 a0 a1 a2 a3 ⇒ TR2' a0 a1 a2 a3:
   thm
val TR2_trap_cmd_rule =
   |- ∀inputInterpret certInterpret inputTest certs stateInterpret x cmd
      ins state outStream.
     (∀M Oi Os.
        CFG2Interpret (M,Oi,Os)
          (CFG2 inputInterpret certInterpret inputTest certs
             stateInterpret (x::ins) state outStream) ⇒
        (M,Oi,Os) sat prop NONE) ⇒
     ∀NS Out M Oi Os.
       TR2 (M,Oi,Os) (trap cmd)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret (x::ins) state outStream)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret ins (NS state (trap cmd))
            (Out state (trap cmd)::outStream)) ⇔
       inputTest (inputInterpret x) ∧
       CFG2Interpret (M,Oi,Os)
         (CFG2 inputInterpret certInterpret inputTest certs
            stateInterpret (x::ins) state outStream) ∧
       (M,Oi,Os) sat prop NONE:
   thm
val TR2rule0 =
   |- TR2 (M,Oi,Os) (exec cmd)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        ins (NS state (exec cmd)) (Out state (exec cmd)::outStream)) ⇔
   inputTest (inputInterpret x) ∧
   CFG2Interpret (M,Oi,Os)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream):
   thm
val TR2rule1 =
   |- TR2 (M,Oi,Os) (trap cmd)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        ins (NS state (trap cmd)) (Out state (trap cmd)::outStream)) ⇔
   inputTest (inputInterpret x) ∧
   CFG2Interpret (M,Oi,Os)
     (CFG2 inputInterpret certInterpret inputTest certs stateInterpret
        (x::ins) state outStream):
   thm
val TR_EQ_rules_thm =
   |- (TR (M,Oi,Os) (exec cmd)
      (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins)
         s outs)
      (CFG inputTest stateInterp certList ins (NS s (exec cmd))
         (Out s (exec cmd)::outs)) ⇔
    inputTest (P says prop (SOME cmd)) ∧
    CFGInterpret (M,Oi,Os)
      (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins)
         s outs)) ∧
   (TR (M,Oi,Os) (trap cmd)
      (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins)
         s outs)
      (CFG inputTest stateInterp certList ins (NS s (trap cmd))
         (Out s (trap cmd)::outs)) ⇔
    inputTest (P says prop (SOME cmd)) ∧
    CFGInterpret (M,Oi,Os)
      (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins)
         s outs)) ∧
   (TR (M,Oi,Os) discard
      (CFG inputTest stateInterp certList (x::ins) s outs)
      (CFG inputTest stateInterp certList ins (NS s discard)
         (Out s discard::outs)) ⇔ ¬inputTest x):
   thm
val TR_cases =
   |- ∀a0 a1 a2 a3.
     TR a0 a1 a2 a3 ⇔
     (∃inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        (a0 = (M,Oi,Os)) ∧ (a1 = exec cmd) ∧
        (a2 =
         CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs) ∧
        (a3 =
         CFG inputTest stateInterp certList ins (NS s (exec cmd))
           (Out s (exec cmd)::outs)) ∧
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)) ∨
     (∃inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        (a0 = (M,Oi,Os)) ∧ (a1 = trap cmd) ∧
        (a2 =
         CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs) ∧
        (a3 =
         CFG inputTest stateInterp certList ins (NS s (trap cmd))
           (Out s (trap cmd)::outs)) ∧
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)) ∨
     ∃inputTest NS M Oi Os Out s certList stateInterp cmd x ins outs.
       (a0 = (M,Oi,Os)) ∧ (a1 = discard) ∧
       (a2 = CFG inputTest stateInterp certList (x::ins) s outs) ∧
       (a3 =
        CFG inputTest stateInterp certList ins (NS s discard)
          (Out s discard::outs)) ∧ ¬inputTest x:
   thm
val TR_def =
   |- TR =
   (λa0 a1 a2 a3.
      ∀TR'.
        (∀a0 a1 a2 a3.
           (∃inputTest P NS M Oi Os Out s certList stateInterp cmd ins
               outs.
              (a0 = (M,Oi,Os)) ∧ (a1 = exec cmd) ∧
              (a2 =
               CFG inputTest stateInterp certList
                 (P says prop (SOME cmd)::ins) s outs) ∧
              (a3 =
               CFG inputTest stateInterp certList ins (NS s (exec cmd))
                 (Out s (exec cmd)::outs)) ∧
              inputTest (P says prop (SOME cmd)) ∧
              CFGInterpret (M,Oi,Os)
                (CFG inputTest stateInterp certList
                   (P says prop (SOME cmd)::ins) s outs)) ∨
           (∃inputTest P NS M Oi Os Out s certList stateInterp cmd ins
               outs.
              (a0 = (M,Oi,Os)) ∧ (a1 = trap cmd) ∧
              (a2 =
               CFG inputTest stateInterp certList
                 (P says prop (SOME cmd)::ins) s outs) ∧
              (a3 =
               CFG inputTest stateInterp certList ins (NS s (trap cmd))
                 (Out s (trap cmd)::outs)) ∧
              inputTest (P says prop (SOME cmd)) ∧
              CFGInterpret (M,Oi,Os)
                (CFG inputTest stateInterp certList
                   (P says prop (SOME cmd)::ins) s outs)) ∨
           (∃inputTest NS M Oi Os Out s certList stateInterp cmd x ins
               outs.
              (a0 = (M,Oi,Os)) ∧ (a1 = discard) ∧
              (a2 =
               CFG inputTest stateInterp certList (x::ins) s outs) ∧
              (a3 =
               CFG inputTest stateInterp certList ins (NS s discard)
                 (Out s discard::outs)) ∧ ¬inputTest x) ⇒
           TR' a0 a1 a2 a3) ⇒
        TR' a0 a1 a2 a3):
   thm
val TR_discard_cmd_rule =
   |- TR (M,Oi,Os) discard
     (CFG inputTest stateInterp certList (x::ins) s outs)
     (CFG inputTest stateInterp certList ins (NS s discard)
        (Out s discard::outs)) ⇔ ¬inputTest x:
   thm
val TR_exec_cmd_rule =
   |- ∀inputTest certList stateInterp P cmd ins s outs.
     (∀M Oi Os.
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        (M,Oi,Os) sat prop (SOME cmd)) ⇒
     ∀NS Out M Oi Os.
       TR (M,Oi,Os) (exec cmd)
         (CFG inputTest stateInterp certList
            (P says prop (SOME cmd)::ins) s outs)
         (CFG inputTest stateInterp certList ins (NS s (exec cmd))
            (Out s (exec cmd)::outs)) ⇔
       inputTest (P says prop (SOME cmd)) ∧
       CFGInterpret (M,Oi,Os)
         (CFG inputTest stateInterp certList
            (P says prop (SOME cmd)::ins) s outs) ∧
       (M,Oi,Os) sat prop (SOME cmd):
   thm
val TR_ind =
   |- ∀TR'.
     (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        TR' (M,Oi,Os) (exec cmd)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s (exec cmd))
             (Out s (exec cmd)::outs))) ∧
     (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        TR' (M,Oi,Os) (trap cmd)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s (trap cmd))
             (Out s (trap cmd)::outs))) ∧
     (∀inputTest NS M Oi Os Out s certList stateInterp cmd x ins outs.
        ¬inputTest x ⇒
        TR' (M,Oi,Os) discard
          (CFG inputTest stateInterp certList (x::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s discard)
             (Out s discard::outs))) ⇒
     ∀a0 a1 a2 a3. TR a0 a1 a2 a3 ⇒ TR' a0 a1 a2 a3:
   thm
val TR_rules =
   |- (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
      inputTest (P says prop (SOME cmd)) ∧
      CFGInterpret (M,Oi,Os)
        (CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs) ⇒
      TR (M,Oi,Os) (exec cmd)
        (CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs)
        (CFG inputTest stateInterp certList ins (NS s (exec cmd))
           (Out s (exec cmd)::outs))) ∧
   (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
      inputTest (P says prop (SOME cmd)) ∧
      CFGInterpret (M,Oi,Os)
        (CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs) ⇒
      TR (M,Oi,Os) (trap cmd)
        (CFG inputTest stateInterp certList
           (P says prop (SOME cmd)::ins) s outs)
        (CFG inputTest stateInterp certList ins (NS s (trap cmd))
           (Out s (trap cmd)::outs))) ∧
   ∀inputTest NS M Oi Os Out s certList stateInterp cmd x ins outs.
     ¬inputTest x ⇒
     TR (M,Oi,Os) discard
       (CFG inputTest stateInterp certList (x::ins) s outs)
       (CFG inputTest stateInterp certList ins (NS s discard)
          (Out s discard::outs)):
   thm
val TR_strongind =
   |- ∀TR'.
     (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        TR' (M,Oi,Os) (exec cmd)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s (exec cmd))
             (Out s (exec cmd)::outs))) ∧
     (∀inputTest P NS M Oi Os Out s certList stateInterp cmd ins outs.
        inputTest (P says prop (SOME cmd)) ∧
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        TR' (M,Oi,Os) (trap cmd)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s (trap cmd))
             (Out s (trap cmd)::outs))) ∧
     (∀inputTest NS M Oi Os Out s certList stateInterp x ins outs.
        ¬inputTest x ⇒
        TR' (M,Oi,Os) discard
          (CFG inputTest stateInterp certList (x::ins) s outs)
          (CFG inputTest stateInterp certList ins (NS s discard)
             (Out s discard::outs))) ⇒
     ∀a0 a1 a2 a3. TR a0 a1 a2 a3 ⇒ TR' a0 a1 a2 a3:
   thm
val TR_trap_cmd_rule =
   |- ∀inputTest stateInterp certList P cmd ins s outs.
     (∀M Oi Os.
        CFGInterpret (M,Oi,Os)
          (CFG inputTest stateInterp certList
             (P says prop (SOME cmd)::ins) s outs) ⇒
        (M,Oi,Os) sat prop NONE) ⇒
     ∀NS Out M Oi Os.
       TR (M,Oi,Os) (trap cmd)
         (CFG inputTest stateInterp certList
            (P says prop (SOME cmd)::ins) s outs)
         (CFG inputTest stateInterp certList ins (NS s (trap cmd))
            (Out s (trap cmd)::outs)) ⇔
       inputTest (P says prop (SOME cmd)) ∧
       CFGInterpret (M,Oi,Os)
         (CFG inputTest stateInterp certList
            (P says prop (SOME cmd)::ins) s outs) ∧
       (M,Oi,Os) sat prop NONE:
   thm
val TRrule0 =
   |- TR (M,Oi,Os) (exec cmd)
     (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins) s
        outs)
     (CFG inputTest stateInterp certList ins (NS s (exec cmd))
        (Out s (exec cmd)::outs)) ⇔
   inputTest (P says prop (SOME cmd)) ∧
   CFGInterpret (M,Oi,Os)
     (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins) s
        outs):
   thm
val TRrule1 =
   |- TR (M,Oi,Os) (trap cmd)
     (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins) s
        outs)
     (CFG inputTest stateInterp certList ins (NS s (trap cmd))
        (Out s (trap cmd)::outs)) ⇔
   inputTest (P says prop (SOME cmd)) ∧
   CFGInterpret (M,Oi,Os)
     (CFG inputTest stateInterp certList (P says prop (SOME cmd)::ins) s
        outs):
   thm
val UNION_APPEND =
   |- ∀l1 l2. set l1 ∪ set l2 = set (l1 ++ l2):
   thm
val UNZIP =
   |- (UNZIP [] = ([],[])) ∧
   ∀x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l)):
   thm
val UNZIP_MAP =
   |- ∀L. UNZIP L = (MAP FST L,MAP SND L):
   thm
val UNZIP_THM =
   |- (UNZIP [] = ([],[])) ∧
   (UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2))):
   thm
val UNZIP_ZIP =
   |- ∀l1 l2. (LENGTH l1 = LENGTH l2) ⇒ (UNZIP (ZIP (l1,l2)) = (l1,l2)):
   thm
val WF_LIST_PRED =
   |- WF (λL1 L2. ∃h. L2 = h::L1):
   thm
val ZIP =
   |- (ZIP ([],[]) = []) ∧
   ∀x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2):
   thm
val ZIP_DROP =
   |- ∀a b n.
     n ≤ LENGTH a ∧ (LENGTH a = LENGTH b) ⇒
     (ZIP (DROP n a,DROP n b) = DROP n (ZIP (a,b))):
   thm
val ZIP_EQ_NIL =
   |- ∀l1 l2.
     (LENGTH l1 = LENGTH l2) ⇒
     ((ZIP (l1,l2) = []) ⇔ (l1 = []) ∧ (l2 = [])):
   thm
val ZIP_GENLIST =
   |- ∀l f n.
     (LENGTH l = n) ⇒
     (ZIP (l,GENLIST f n) = GENLIST (λx. (EL x l,f x)) n):
   thm
val ZIP_MAP =
   |- ∀l1 l2 f1 f2.
     (LENGTH l1 = LENGTH l2) ⇒
     (ZIP (MAP f1 l1,l2) = MAP (λp. (f1 (FST p),SND p)) (ZIP (l1,l2))) ∧
     (ZIP (l1,MAP f2 l2) = MAP (λp. (FST p,f2 (SND p))) (ZIP (l1,l2))):
   thm
val ZIP_UNZIP =
   |- ∀l. ZIP (UNZIP l) = l:
   thm
val all_distinct_nub =
   |- ∀l. ALL_DISTINCT (nub l):
   thm
val configuration2_11 =
   |- ∀a0 a1 a2 a3 a4 a5 a6 a7 a0' a1' a2' a3' a4' a5' a6' a7'.
     (CFG2 a0 a1 a2 a3 a4 a5 a6 a7 =
      CFG2 a0' a1' a2' a3' a4' a5' a6' a7') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3') ∧ (a4 = a4') ∧
     (a5 = a5') ∧ (a6 = a6') ∧ (a7 = a7'):
   thm
val configuration2_Axiom =
   |- ∀f.
     ∃fn.
       ∀a0 a1 a2 a3 a4 a5 a6 a7.
         fn (CFG2 a0 a1 a2 a3 a4 a5 a6 a7) = f a0 a1 a2 a3 a4 a5 a6 a7:
   thm
val configuration2_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'configuration2' .
            (∀a0'.
               (∃a0 a1 a2 a3 a4 a5 a6 a7.
                  a0' =
                  (λa0 a1 a2 a3 a4 a5 a6 a7.
                     ind_type$CONSTR 0 (a0,a1,a2,a3,a4,a5,a6,a7)
                       (λn. ind_type$BOTTOM)) a0 a1 a2 a3 a4 a5 a6 a7) ⇒
               'configuration2' a0') ⇒
            'configuration2' a0') rep:
   thm
val configuration2_case_cong =
   |- ∀M M' f.
     (M = M') ∧
     (∀a0 a1 a2 a3 a4 a5 a6 a7.
        (M' = CFG2 a0 a1 a2 a3 a4 a5 a6 a7) ⇒
        (f a0 a1 a2 a3 a4 a5 a6 a7 = f' a0 a1 a2 a3 a4 a5 a6 a7)) ⇒
     (configuration2_CASE M f = configuration2_CASE M' f'):
   thm
val configuration2_case_def =
   |- ∀a0 a1 a2 a3 a4 a5 a6 a7 f.
     configuration2_CASE (CFG2 a0 a1 a2 a3 a4 a5 a6 a7) f =
     f a0 a1 a2 a3 a4 a5 a6 a7:
   thm
val configuration2_induction =
   |- ∀P. (∀f f0 f1 l f2 l0 s l1. P (CFG2 f f0 f1 l f2 l0 s l1)) ⇒ ∀c. P c:
   thm
val configuration2_nchotomy =
   |- ∀cc. ∃f f0 f1 l f2 l0 s l1. cc = CFG2 f f0 f1 l f2 l0 s l1:
   thm
val configuration2_one_one =
   |- ∀a0 a1 a2 a3 a4 a5 a6 a7 a0' a1' a2' a3' a4' a5' a6' a7'.
     (CFG2 a0 a1 a2 a3 a4 a5 a6 a7 =
      CFG2 a0' a1' a2' a3' a4' a5' a6' a7') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3') ∧ (a4 = a4') ∧
     (a5 = a5') ∧ (a6 = a6') ∧ (a7 = a7'):
   thm
val configuration2_size_def =
   |- ∀f f1 f2 f3 f4 f5 f6 f7 a0 a1 a2 a3 a4 a5 a6 a7.
     configuration2_size f f1 f2 f3 f4 f5 f6 f7
       (CFG2 a0 a1 a2 a3 a4 a5 a6 a7) =
     1 +
     (list_size f a3 + (list_size f4 a5 + (f7 a6 + list_size f5 a7))):
   thm
val configuration_11 =
   |- ∀a0 a1 a2 a3 a4 a5 a0' a1' a2' a3' a4' a5'.
     (CFG a0 a1 a2 a3 a4 a5 = CFG a0' a1' a2' a3' a4' a5') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3') ∧ (a4 = a4') ∧
     (a5 = a5'):
   thm
val configuration_Axiom =
   |- ∀f.
     ∃fn.
       ∀a0 a1 a2 a3 a4 a5.
         fn (CFG a0 a1 a2 a3 a4 a5) = f a0 a1 a2 a3 a4 a5:
   thm
val configuration_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'configuration' .
            (∀a0'.
               (∃a0 a1 a2 a3 a4 a5.
                  a0' =
                  (λa0 a1 a2 a3 a4 a5.
                     ind_type$CONSTR 0 (a0,a1,a2,a3,a4,a5)
                       (λn. ind_type$BOTTOM)) a0 a1 a2 a3 a4 a5) ⇒
               'configuration' a0') ⇒
            'configuration' a0') rep:
   thm
val configuration_case_cong =
   |- ∀M M' f.
     (M = M') ∧
     (∀a0 a1 a2 a3 a4 a5.
        (M' = CFG a0 a1 a2 a3 a4 a5) ⇒
        (f a0 a1 a2 a3 a4 a5 = f' a0 a1 a2 a3 a4 a5)) ⇒
     (configuration_CASE M f = configuration_CASE M' f'):
   thm
val configuration_case_def =
   |- ∀a0 a1 a2 a3 a4 a5 f.
     configuration_CASE (CFG a0 a1 a2 a3 a4 a5) f = f a0 a1 a2 a3 a4 a5:
   thm
val configuration_induction =
   |- ∀P. (∀f f0 l l0 s l1. P (CFG f f0 l l0 s l1)) ⇒ ∀c. P c:
   thm
val configuration_nchotomy =
   |- ∀cc. ∃f f0 l l0 s l1. cc = CFG f f0 l l0 s l1:
   thm
val configuration_one_one =
   |- ∀a0 a1 a2 a3 a4 a5 a0' a1' a2' a3' a4' a5'.
     (CFG a0 a1 a2 a3 a4 a5 = CFG a0' a1' a2' a3' a4' a5') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2') ∧ (a3 = a3') ∧ (a4 = a4') ∧
     (a5 = a5'):
   thm
val configuration_size_def =
   |- ∀f f1 f2 f3 f4 f5 a0 a1 a2 a3 a4 a5.
     configuration_size f f1 f2 f3 f4 f5 (CFG a0 a1 a2 a3 a4 a5) =
     1 +
     (list_size (Form_size (inst_size f) f4 f1 f2) a2 +
      (list_size (Form_size (inst_size f) f4 f1 f2) a3 +
       (f5 a4 + list_size f3 a5))):
   thm
val datatype_configuration =
   |- DATATYPE (configuration CFG):
   thm
val datatype_configuration2 =
   |- DATATYPE (configuration2 CFG2):
   thm
val datatype_inst =
   |- DATATYPE (inst SOME NONE):
   thm
val datatype_list =
   |- DATATYPE (list [] CONS):
   thm
val datatype_trType =
   |- DATATYPE (trType discard trap exec):
   thm
val dropWhile_APPEND_EVERY =
   |- ∀P l1 l2. EVERY P l1 ⇒ (dropWhile P (l1 ++ l2) = dropWhile P l2):
   thm
val dropWhile_APPEND_EXISTS =
   |- ∀P l1 l2.
     EXISTS ($~ ∘ P) l1 ⇒
     (dropWhile P (l1 ++ l2) = dropWhile P l1 ++ l2):
   thm
val dropWhile_def =
   |- (∀P. dropWhile P [] = []) ∧
   ∀P h t. dropWhile P (h::t) = if P h then dropWhile P t else h::t:
   thm
val dropWhile_eq_nil =
   |- ∀P ls. (dropWhile P ls = []) ⇔ EVERY P ls:
   thm
val dropWhile_splitAtPki =
   |- ∀P. dropWhile P = splitAtPki (combin$C (K ∘ $~ ∘ P)) (K I):
   thm
val el_append3 =
   |- ∀l1 x l2. EL (LENGTH l1) (l1 ++ [x] ++ l2) = x:
   thm
val every_zip_fst =
   |- ∀l1 l2 P.
     (LENGTH l1 = LENGTH l2) ⇒
     (EVERY (λx. P (FST x)) (ZIP (l1,l2)) ⇔ EVERY P l1):
   thm
val every_zip_snd =
   |- ∀l1 l2 P.
     (LENGTH l1 = LENGTH l2) ⇒
     (EVERY (λx. P (SND x)) (ZIP (l1,l2)) ⇔ EVERY P l2):
   thm
val exists_list_GENLIST =
   |- (∃ls. P ls) ⇔ ∃n f. P (GENLIST f n):
   thm
val inst_11 =
   |- ∀a a'. (SOME a = SOME a') ⇔ (a = a'):
   thm
val inst_Axiom =
   |- ∀f0 f1. ∃fn. (∀a. fn (SOME a) = f0 a) ∧ (fn NONE = f1):
   thm
val inst_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'inst' .
            (∀a0.
               (∃a.
                  a0 =
                  (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM)) a) ∨
               (a0 =
                ind_type$CONSTR (SUC 0) ARB (λn. ind_type$BOTTOM)) ⇒
               'inst' a0) ⇒
            'inst' a0) rep:
   thm
val inst_case_cong =
   |- ∀M M' f v.
     (M = M') ∧ (∀a. (M' = SOME a) ⇒ (f a = f' a)) ∧
     ((M' = NONE) ⇒ (v = v')) ⇒
     (inst_CASE M f v = inst_CASE M' f' v'):
   thm
val inst_case_def =
   |- (∀a f v. inst_CASE (SOME a) f v = f a) ∧ ∀f v. inst_CASE NONE f v = v:
   thm
val inst_distinct =
   |- ∀a. SOME a ≠ NONE:
   thm
val inst_distinct_clauses =
   |- ∀a. SOME a ≠ NONE:
   thm
val inst_induction =
   |- ∀P. (∀c. P (SOME c)) ∧ P NONE ⇒ ∀i. P i:
   thm
val inst_nchotomy =
   |- ∀ii. (∃c. ii = SOME c) ∨ (ii = NONE):
   thm
val inst_one_one =
   |- ∀a a'. (SOME a = SOME a') ⇔ (a = a'):
   thm
val inst_size_def =
   |- (∀f a. inst_size f (SOME a) = 1 + f a) ∧ ∀f. inst_size f NONE = 0:
   thm
val isPREFIX =
   |- (∀l. [] ≼ l ⇔ T) ∧
   ∀h t l. h::t ≼ l ⇔ case l of [] => F | h'::t' => (h = h') ∧ t ≼ t':
   thm
val isPREFIX_THM =
   |- ([] ≼ l ⇔ T) ∧ (h::t ≼ [] ⇔ F) ∧
   (h1::t1 ≼ h2::t2 ⇔ (h1 = h2) ∧ t1 ≼ t2):
   thm
val last_drop =
   |- ∀l n. n < LENGTH l ⇒ (LAST (DROP n l) = LAST l):
   thm
val length_nub_append =
   |- ∀l1 l2.
     LENGTH (nub (l1 ++ l2)) =
     LENGTH (nub l1) + LENGTH (nub (FILTER (λx. ¬MEM x l1) l2)):
   thm
val list_11 =
   |- ∀a0 a1 a0' a1'. (a0::a1 = a0'::a1') ⇔ (a0 = a0') ∧ (a1 = a1'):
   thm
val list_Axiom =
   |- ∀f0 f1. ∃fn. (fn [] = f0) ∧ ∀a0 a1. fn (a0::a1) = f1 a0 a1 (fn a1):
   thm
val list_Axiom_old =
   |- ∀x f. ∃!fn1. (fn1 [] = x) ∧ ∀h t. fn1 (h::t) = f (fn1 t) h t:
   thm
val list_CASES =
   |- ∀l. (l = []) ∨ ∃h t. l = h::t:
   thm
val list_INDUCT =
   |- ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l:
   thm
val list_INDUCT0 =
   |- ∀P. P [] ∧ (∀l. P l ⇒ ∀a. P (a::l)) ⇒ ∀l. P l:
   thm
val list_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'list' .
            (∀a0'.
               (a0' = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
               (∃a0 a1.
                  (a0' =
                   (λa0 a1.
                      ind_type$CONSTR (SUC 0) a0
                        (ind_type$FCONS a1 (λn. ind_type$BOTTOM))) a0
                     a1) ∧ 'list' a1) ⇒
               'list' a0') ⇒
            'list' a0') rep:
   thm
val list_case_compute =
   |- ∀l. list_CASE l b f = if NULL l then b else f (HD l) (TL l):
   thm
val list_case_cong =
   |- ∀M M' v f.
     (M = M') ∧ ((M' = []) ⇒ (v = v')) ∧
     (∀a0 a1. (M' = a0::a1) ⇒ (f a0 a1 = f' a0 a1)) ⇒
     (list_CASE M v f = list_CASE M' v' f'):
   thm
val list_case_def =
   |- (∀v f. list_CASE [] v f = v) ∧
   ∀a0 a1 v f. list_CASE (a0::a1) v f = f a0 a1:
   thm
val list_distinct =
   |- ∀a1 a0. [] ≠ a0::a1:
   thm
val list_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  bool | (TY, TY)fun | ind | TY itself | TY list | num |
                  one | TY option | (TY, TY)prod | TY recspace |
                  TY set | (TY, TY)sum | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT APPEND APPLICATIVE_FAPPLY ARB
  ASSOC Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED CARD CHOICE COMM
  COMPL COND CONS CR CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF
  DISJOINT DIV DIV2 DIVMOD DROP EL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2
  EVERYi EXISTS EXP EXT_POINT F FACT FAIL FCOMM FILTER FIND FINITE FLAT
  FOLDL FOLDL2 FOLDR FRONT FST FUNPOW FUNSET GENLIST GENLIST_AUX GSPEC
  HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_NONE IS_NUM_REP IS_SOME IS_SUM_REP ITSET Id IfCases K LAST LEAST
  LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND
  LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_TO_SET LLEX LRC LUPDATE
  LinearOrder MAP MAP2 MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID NIL
  NONE NOTIN NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND O ODD
  OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE
  OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2
  OPTION_MCOMP OPTREL OPT_MMAP OUTL OUTR OWHILE Order PAD_LEFT PAD_RIGHT
  PERMUTES PI POW PRE PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE
  PROD_SET PSUBSET PreOrder RC RCOMPL RDOM RDOM_DELETE RELPOW
  REL_RESTRICT REMPTY REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV S SC SET_TO_LIST SIGMA SIMP_REC SIMP_REC_REL SING SINGL SN SND
  SNOC SOME STRORD SUBSET SUC SUC_REP SUM SUM_ACC SUM_ALL SUM_IMAGE
  SUM_SET SURJ SWAP StrongLinearOrder StrongOrder T TAKE TC THE TL
  TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UPDATE W WCR WF
  WFP WFREC WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE
  \/ \\ _ inject_number antisymmetric approx bool_size case chooser
  count countable dest_rec diag diamond dropWhile enumerate equiv_on
  equivalence findq iBIT_cases internal_mult inv inv_image invtri
  invtri0 irreflexive isPREFIX itself_case lift2 listRel list_CASE
  list_size literal_case measure mk_rec napp nat_elim__magic ncons nf
  nfoldl nfst nlen nlistrec nmap nnil npair nsnd nub num_CASE
  num_to_pair o one one_CASE one_size option_ABS option_CASE option_REP
  option_size pair_CASE pair_size pair_to_num pairwise partition
  rcdiamond reflexive schroeder_close set some splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total transitive tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  isPREFIX
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  EVERY2             ->  LIST_REL
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  Id                 ->  =
  MEM                -> 
    (λ(h :α) (l :α list). bool$IN h (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val list_induction =
   |- ∀P. P [] ∧ (∀t. P t ⇒ ∀h. P (h::t)) ⇒ ∀l. P l:
   thm
val list_nchotomy =
   |- ∀l. (l = []) ∨ ∃h t. l = h::t:
   thm
val list_size_cong =
   |- ∀M N f f'.
     (M = N) ∧ (∀x. MEM x N ⇒ (f x = f' x)) ⇒
     (list_size f M = list_size f' N):
   thm
val list_size_def =
   |- (∀f. list_size f [] = 0) ∧
   ∀f a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1):
   thm
val list_to_set_diff =
   |- ∀l1 l2. set l2 DIFF set l1 = set (FILTER (λx. ¬MEM x l1) l2):
   thm
val lupdate_append =
   |- ∀x n l1 l2.
     n < LENGTH l1 ⇒ (LUPDATE x n (l1 ++ l2) = LUPDATE x n l1 ++ l2):
   thm
val lupdate_append2 =
   |- ∀v l1 x l2 l3.
     LUPDATE v (LENGTH l1) (l1 ++ [x] ++ l2) = l1 ++ [v] ++ l2:
   thm
val mem_exists_set =
   |- ∀x y l. MEM (x,y) l ⇒ ∃z. (x = FST z) ∧ MEM z l:
   thm
val nub_append =
   |- ∀l1 l2. nub (l1 ++ l2) = nub (FILTER (λx. ¬MEM x l2) l1) ++ nub l2:
   thm
val nub_def =
   |- (nub [] = []) ∧
   ∀x l. nub (x::l) = if MEM x l then nub l else x::nub l:
   thm
val nub_set =
   |- ∀l. set (nub l) = set l:
   thm
val splitAtPki_APPEND =
   |- ∀l1 l2 P k.
     EVERYi (λi. $~ ∘ P i) l1 ∧
     (0 < LENGTH l2 ⇒ P (LENGTH l1) (HD l2)) ⇒
     (splitAtPki P k (l1 ++ l2) = k l1 l2):
   thm
val splitAtPki_EQN =
   |- splitAtPki P k l =
   case OLEAST i. i < LENGTH l ∧ P i (EL i l) of
     NONE => k l []
   | SOME i => k (TAKE i l) (DROP i l):
   thm
val splitAtPki_def =
   |- (∀P k. splitAtPki P k [] = k [] []) ∧
   ∀P k h t.
     splitAtPki P k (h::t) =
     if P 0 h then k [] (h::t)
     else splitAtPki (P ∘ SUC) (λp s. k (h::p) s) t:
   thm
val ssm1_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool |
                  (TY, TY, TY, TY, TY, TY)configuration | (TY, TY)fun |
                  ind | TY inst | TY itself | TY list | num | one |
                  TY option | TY po | (TY, TY)prod | TY recspace |
                  TY set | (TY, TY)sum | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CFG CFGInterpret CHOICE COMM COMPL COND CONS COUNT_LIST
  COUNT_LIST_AUX CR CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF
  DISJOINT DIV DIV2 DIVMOD DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY
  EVERY2 EVERYi EXISTS EXP EXT_POINT Efn F FACT FAIL FCOMM FF FILTER
  FIND FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW
  FUNSET Form_CASE Form_size GENLIST GENLIST_AUX GSPEC GUESS_EXISTS
  GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP
  GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF
  INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT
  INTER INVOL ISL ISR IS_EL IS_NONE IS_NUM_REP IS_PREFIX
  IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST
  IS_SUFFIX IS_SUM_REP ITSET Id IfCases IntLevel_CASE IntLevel_size Jext
  K KS Kripke_CASE Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET
  LEX LINV LINV_OPT LIST_APPLY LIST_BIND LIST_ELEM_COUNT
  LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi LIST_TO_SET LLEX LRC
  LUPDATE Lifn LinearOrder Lsfn MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM
  MIN MIN_SET MOD MODEQ MONOID NIL NONE NOTIN NRC NULL NUMERAL NUMFST
  NUMLEFT NUMRIGHT NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL
  OPTION_APPLY OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND
  OPTION_JOIN OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL
  OUTL OUTR OWHILE Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV S SC SCANL SCANR
  SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL SIMP_REC
  SIMP_REC_REL SING SINGL SN SND SNOC SOME SOME_EL SPLITL SPLITP
  SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TR TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP
  UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder
  WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf
  antisymmetric approx bool_size case chooser configuration_CASE
  configuration_size controls count countable delN dest_rec diag diamond
  discard domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on
  equivalence exec findi findq fupdLast iBIT_cases iLab il imapKS impf
  inst_CASE inst_size internal_mult intpKS inv inv_image invtri invtri0
  irreflexive isPREFIX itself_case jKS lift2 listRel list_CASE list_size
  literal_case lt lte measure meet mk_rec napp nat_elim__magic ncons nf
  nfoldl nfst nlen nlistrec nmap nnil notf npair nsnd nub num_CASE
  num_to_pair o one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orf pair_CASE pair_size pair_to_num
  pairwise partition prod_PO prop quoting rcdiamond reflexive repPO reps
  sLab sat satList says schroeder_close set sl smapKS some speaks_for
  splitAtPki stmarker sum_CASE sum_size symmetric the_fun the_value
  total trType_CASE trType_size transitive trap tri trichotomous tri⁻¹
  unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE list_CASE option_CASE
    sum_CASE num_CASE pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val ssm2_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool |
                  (TY, TY, TY, TY, TY, TY)configuration |
                  (TY, TY, TY, TY, TY, TY, TY, TY)configuration2 |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  num | one | TY option | TY po | (TY, TY)prod |
                  TY recspace | TY set | (TY, TY)sum | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h) configuration2 = (α, β, γ, δ, ε, ζ, η, θ) ssm2$configuration2
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CFG CFG2 CFG2Interpret CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Cong DATATYPE
  DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL EMPTY
  EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Efn F FACT
  FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR FOLDRi
  FRONT FST FUNPOW FUNSET Form_CASE Form_size GENLIST GENLIST_AUX GSPEC
  GUESS_EXISTS GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL
  GUESS_FORALL_GAP GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN
  INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON
  INFINITE INJ INL INR INSERT INTER INVOL ISL ISR IS_EL IS_NONE
  IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN
  IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET Id IfCases IntLevel_CASE
  IntLevel_size Jext K KS Kripke_CASE Kripke_size LAST LASTN LEAST
  LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND
  LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi
  LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn MAP MAP2 MAPi
  MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID NIL NONE NOTIN
  NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O O1 ODD OLEAST
  ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE
  OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2
  OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Order PAD_LEFT
  PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED
  PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW
  PMATCH_ROW_COND PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ
  PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0
  PMATCH_ROW_magic_1 PMATCH_ROW_magic_2 PMATCH_ROW_magic_3
  PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PRE PREFIX PREIMAGE PRIM_REC
  PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE
  Princ_size RC RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV S SC SCANL SCANR
  SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL SIMP_REC
  SIMP_REC_REL SING SINGL SN SND SNOC SOME SOME_EL SPLITL SPLITP
  SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TR TR2 TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP
  UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder
  WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf
  antisymmetric approx bool_size case chooser configuration2_CASE
  configuration2_size configuration_CASE configuration_size controls
  count countable delN dest_rec diag diamond discard domi doms dropWhile
  enumerate eqf eqi eqn eqs equiv_on equivalence exec findi findq
  fupdLast iBIT_cases iLab il imapKS impf inst_CASE inst_size
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS lift2 listRel list_CASE list_size literal_case lt lte
  measure meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair nsnd nub num_CASE num_to_pair o one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf pair_CASE pair_size pair_to_num pairwise partition
  prod_PO prop quoting rcdiamond reflexive repPO reps sLab sat satList
  says schroeder_close set sl smapKS some speaks_for splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total trType_CASE
  trType_size transitive trap tri trichotomous tri⁻¹ unint univ
  wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration2_CASE configuration_CASE trType_CASE inst_CASE
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
type thm
val trType_11 =
   |- (∀a a'. (trap a = trap a') ⇔ (a = a')) ∧
   ∀a a'. (exec a = exec a') ⇔ (a = a'):
   thm
val trType_Axiom =
   |- ∀f0 f1 f2.
     ∃fn.
       (fn discard = f0) ∧ (∀a. fn (trap a) = f1 a) ∧
       ∀a. fn (exec a) = f2 a:
   thm
val trType_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'trType' .
            (∀a0.
               (a0 = ind_type$CONSTR 0 ARB (λn. ind_type$BOTTOM)) ∨
               (∃a.
                  a0 =
                  (λa. ind_type$CONSTR (SUC 0) a (λn. ind_type$BOTTOM))
                    a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC 0)) a
                       (λn. ind_type$BOTTOM)) a) ⇒
               'trType' a0) ⇒
            'trType' a0) rep:
   thm
val trType_case_cong =
   |- ∀M M' v f f1.
     (M = M') ∧ ((M' = discard) ⇒ (v = v')) ∧
     (∀a. (M' = trap a) ⇒ (f a = f' a)) ∧
     (∀a. (M' = exec a) ⇒ (f1 a = f1' a)) ⇒
     (trType_CASE M v f f1 = trType_CASE M' v' f' f1'):
   thm
val trType_case_def =
   |- (∀v f f1. trType_CASE discard v f f1 = v) ∧
   (∀a v f f1. trType_CASE (trap a) v f f1 = f a) ∧
   ∀a v f f1. trType_CASE (exec a) v f f1 = f1 a:
   thm
val trType_distinct =
   |- (∀a. discard ≠ trap a) ∧ (∀a. discard ≠ exec a) ∧
   ∀a' a. trap a ≠ exec a':
   thm
val trType_distinct_clauses =
   |- (∀a. discard ≠ trap a) ∧ (∀a. discard ≠ exec a) ∧
   ∀a' a. trap a ≠ exec a':
   thm
val trType_induction =
   |- ∀P. P discard ∧ (∀c. P (trap c)) ∧ (∀c. P (exec c)) ⇒ ∀t. P t:
   thm
val trType_nchotomy =
   |- ∀tt. (tt = discard) ∨ (∃c. tt = trap c) ∨ ∃c. tt = exec c:
   thm
val trType_one_one =
   |- (∀a a'. (trap a = trap a') ⇔ (a = a')) ∧
   ∀a a'. (exec a = exec a') ⇔ (a = a'):
   thm
val trType_size_def =
   |- (∀f. trType_size f discard = 0) ∧
   (∀f a. trType_size f (trap a) = 1 + f a) ∧
   ∀f a. trType_size f (exec a) = 1 + f a:
   thm
> val Alice_Operator_rejected_lemma =
   |- ¬inputOKr1
      (Name (Staff Alice) quoting Name (Role Operator) says
       prop (SOME cmd)):
   thm
val Bob_Commander_rejected_lemma =
   |- ¬inputOKr1
      (Name (Staff Bob) quoting Name (Role Commander) says
       prop (SOME cmd)):
   thm
val Bob_TR2_iff_TR_privcmd =
   |- ∀NS Out M Oi Os.
     TR2 (M,Oi,Os) (exec (PR privcmd))
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Operator) says
                    prop (SOME (PR privcmd)))))::ins2) s outs)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp ins2
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd) ins
          (NS s (exec (PR privcmd))) (Out s (exec (PR privcmd))::outs)):
   thm
val Carol_all_roles_rejected_lemma =
   |- ¬inputOKr1
      (Name (Staff Carol) quoting Name (Role role) says prop (SOME cmd)):
   thm
val Operator_Bob_exec_privcmd_justified_thm =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
          (Name (Staff Bob) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs)
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr1
       (Name (Staff Bob) quoting Name (Role Operator) says
        prop (SOME (PR privcmd))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
          (Name (Staff Bob) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs) ∧
     (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_Bob_exec_privcmd_justified_thm_r2 =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr2
       (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
        prop (SOME (PR privcmd))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
           prop (SOME (PR privcmd))::ins) s outs) ∧
     (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_Bob_privcmd_exec_privcmd_justified_thm =
   |- ∀NS Out M Oi Os.
     TR2 (M,Oi,Os) (exec (PR privcmd))
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (MSG Bob (Order Operator (PR privcmd))
             (sign (privK Bob)
                (hash (SOME (Order Operator (PR privcmd)))))::ins) s
          outs)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr2
       (MsgInterpret
          (MSG Bob (Order Operator (PR privcmd))
             (sign (privK Bob)
                (hash (SOME (Order Operator (PR privcmd))))))) ∧
     CFG2Interpret (M,Oi,Os)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (MSG Bob (Order Operator (PR privcmd))
             (sign (privK Bob)
                (hash (SOME (Order Operator (PR privcmd)))))::ins) s
          outs) ∧ (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_Bob_privcmd_exec_privcmd_justified_with_refinements_thm =
   |- ∀NS Out M Oi Os.
     TR2 (M,Oi,Os) (exec (PR privcmd))
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Operator) says
                    prop (SOME (PR privcmd)))))::ins) s outs)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr2
       (MsgInterpret
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Operator) says
                    prop (SOME (PR privcmd))))))) ∧
     CFG2Interpret (M,Oi,Os)
       (CFG2 MsgInterpret certificateInterpret inputOKr2
          (certificatesr3 npriv privcmd) SM0StateInterp
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Operator) says
                    prop (SOME (PR privcmd)))))::ins) s outs) ∧
     (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_exec_privcmd_justified_thm =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs)
       (CFG inputOK SM0StateInterp (certs npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOK (Name (Role Operator) says prop (SOME (PR privcmd))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs) ∧ (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_justified_privcmd_exec_thm =
   |- ∀NS Out M Oi Os cmd npriv privcmd ins s outs.
     inputOK (Name (Role Operator) says prop (SOME (PR privcmd))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs) ⇒
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs)
       (CFG inputOK SM0StateInterp (certs npriv privcmd) ins
          (NS s (exec (PR privcmd))) (Out s (exec (PR privcmd))::outs)):
   thm
val Operator_mapSM0inputOperatorBob_exec_privcmd_justified_thm =
   |- ∀s privcmd outs npriv ins NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
          (mapSM0inputOperatorBob
             (Name (Role Operator) says prop (SOME (PR privcmd)))::ins)
          s outs)
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr1
       (mapSM0inputOperatorBob
          (Name (Role Operator) says prop (SOME (PR privcmd)))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
          (mapSM0inputOperatorBob
             (Name (Role Operator) says prop (SOME (PR privcmd)))::ins)
          s outs) ∧ (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_mapSM0r1input_exec_privcmd_justifed_thm =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (mapSM0r1input
             (mapSM0inputOperatorBob
                (Name (Role Operator) says prop (SOME (PR privcmd))))::
               ins) s outs)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇔
     inputOKr2
       (mapSM0r1input
          (mapSM0inputOperatorBob
             (Name (Role Operator) says prop (SOME (PR privcmd))))) ∧
     CFGInterpret (M,Oi,Os)
       (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
          (mapSM0r1input
             (mapSM0inputOperatorBob
                (Name (Role Operator) says prop (SOME (PR privcmd))))::
               ins) s outs) ∧ (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_privcmd_lemma =
   |- CFGInterpret (M,Oi,Os)
     (CFG inputOK SM0StateInterp (certs npriv privcmd)
        (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
        outs) ⇒
   (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val Operator_privcmd_verified_thm =
   |- ∀NS Out M Oi Os.
     TR (M,Oi,Os) (exec (PR privcmd))
       (CFG inputOK SM0StateInterp (certs npriv privcmd)
          (Name (Role Operator) says prop (SOME (PR privcmd))::ins) s
          outs)
       (CFG inputOK SM0StateInterp (certs npriv privcmd) ins
          (NS s (exec (PR privcmd)))
          (Out s (exec (PR privcmd))::outs)) ⇒
     (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val SM0StateInterp_def =
   |- ∀state. SM0StateInterp state = TT:
   thm
val SM0_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | command |
                  (TY, TY, TY, TY, TY, TY)configuration | TY digest |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  npriv | num | one | TY option | output | TY pKey |
                  TY po | principal | privcmd | (TY, TY)prod |
                  TY recspace | role | TY set | staff | state |
                  (TY, TY)sum | symKey | TY symMsg | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander
  Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL
  EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea
  Efn Es F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL
  FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS KeyA KeyS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  Machine NIL NONE NOTIN NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT
  NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY
  OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN
  OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR
  OWHILE Operator Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PR PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV Role S SC SCANL
  SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL
  SIMP_REC SIMP_REC_REL SING SINGL SM0StateInterp SM0ns SM0out SN SND
  SNOC SOME SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TT TYPE_DEFINITION UNCURRY UNION
  UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC
  WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certs chooser
  command_CASE command_size configuration_CASE configuration_size
  controls count countable deciphP deciphS delN dest_rec diag diamond
  digest_CASE digest_size discard domi doms dropWhile enumerate eqf eqi
  eqn eqs equiv_on equivalence exec findi findq fupdLast hash iBIT_cases
  iLab il imapKS impf inputOK inst_CASE inst_size internal_mult intpKS
  inv inv_image invtri invtri0 irreflexive isPREFIX itself_case jKS
  launch lift2 listRel list_CASE list_size literal_case lt lte measure
  meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen nlistrec
  nmap nnil notf npair npriv2num npriv_CASE npriv_size nsnd nub
  num2npriv num2output num2privcmd num2role num2staff num2state num_CASE
  num_to_pair o off on one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orf output2num output_CASE
  output_size pKey_CASE pKey_size pair_CASE pair_size pair_to_num
  pairwise partition principal_CASE principal_size privK privcmd2num
  privcmd_CASE privcmd_size prod_PO prop pubK quoting rcdiamond
  reflexive repPO reps reset role2num role_CASE role_size sLab sat
  satList says schroeder_close set sign signVerify sl smapKS some
  speaks_for splitAtPki staff2num staff_CASE staff_size state2num
  state_CASE state_size status stmarker sum_CASE sum_size sym
  symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric the_fun
  the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE output_CASE state_CASE
    command_CASE npriv_CASE privcmd_CASE principal_CASE staff_CASE
    role_CASE authority_CASE digest_CASE asymMsg_CASE pKey_CASE
    symMsg_CASE symKey_CASE list_CASE option_CASE sum_CASE num_CASE
    pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val SM0ns_def =
   |- (SM0ns STBY (exec (PR reset)) = STBY) ∧
   (SM0ns STBY (exec (PR launch)) = ACTIVE) ∧
   (SM0ns STBY (exec (NP status)) = STBY) ∧
   (SM0ns ACTIVE (exec (PR reset)) = STBY) ∧
   (SM0ns ACTIVE (exec (PR launch)) = ACTIVE) ∧
   (SM0ns ACTIVE (exec (NP status)) = ACTIVE) ∧
   (SM0ns STBY (trap (PR reset)) = STBY) ∧
   (SM0ns STBY (trap (PR launch)) = STBY) ∧
   (SM0ns STBY (trap (NP status)) = STBY) ∧
   (SM0ns ACTIVE (trap (PR reset)) = ACTIVE) ∧
   (SM0ns ACTIVE (trap (PR launch)) = ACTIVE) ∧
   (SM0ns ACTIVE (trap (NP status)) = ACTIVE) ∧
   (SM0ns STBY discard = STBY) ∧ (SM0ns ACTIVE discard = ACTIVE):
   thm
val SM0ns_ind =
   |- ∀P.
     P STBY (exec (PR reset)) ∧ P STBY (exec (PR launch)) ∧
     P STBY (exec (NP status)) ∧ P ACTIVE (exec (PR reset)) ∧
     P ACTIVE (exec (PR launch)) ∧ P ACTIVE (exec (NP status)) ∧
     P STBY (trap (PR reset)) ∧ P STBY (trap (PR launch)) ∧
     P STBY (trap (NP status)) ∧ P ACTIVE (trap (PR reset)) ∧
     P ACTIVE (trap (PR launch)) ∧ P ACTIVE (trap (NP status)) ∧
     P STBY discard ∧ P ACTIVE discard ⇒
     ∀v v1. P v v1:
   thm
val SM0out_def =
   |- (SM0out STBY (exec (PR reset)) = off) ∧
   (SM0out STBY (exec (PR launch)) = on) ∧
   (SM0out STBY (exec (NP status)) = off) ∧
   (SM0out ACTIVE (exec (PR reset)) = off) ∧
   (SM0out ACTIVE (exec (PR launch)) = on) ∧
   (SM0out ACTIVE (exec (NP status)) = on) ∧
   (SM0out STBY (trap (PR reset)) = off) ∧
   (SM0out STBY (trap (PR launch)) = off) ∧
   (SM0out STBY (trap (NP status)) = off) ∧
   (SM0out ACTIVE (trap (PR reset)) = on) ∧
   (SM0out ACTIVE (trap (PR launch)) = on) ∧
   (SM0out ACTIVE (trap (NP status)) = on) ∧
   (SM0out STBY discard = off) ∧ (SM0out ACTIVE discard = on):
   thm
val SM0out_ind =
   |- ∀P.
     P STBY (exec (PR reset)) ∧ P STBY (exec (PR launch)) ∧
     P STBY (exec (NP status)) ∧ P ACTIVE (exec (PR reset)) ∧
     P ACTIVE (exec (PR launch)) ∧ P ACTIVE (exec (NP status)) ∧
     P STBY (trap (PR reset)) ∧ P STBY (trap (PR launch)) ∧
     P STBY (trap (NP status)) ∧ P ACTIVE (trap (PR reset)) ∧
     P ACTIVE (trap (PR launch)) ∧ P ACTIVE (trap (NP status)) ∧
     P STBY discard ∧ P ACTIVE discard ⇒
     ∀v v1. P v v1:
   thm
val SM0r1_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | command |
                  (TY, TY, TY, TY, TY, TY)configuration | TY digest |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  npriv | num | one | TY option | output | TY pKey |
                  TY po | principal | privcmd | (TY, TY)prod |
                  TY recspace | role | TY set | staff | state |
                  (TY, TY)sum | symKey | TY symMsg | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander
  Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL
  EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea
  Efn Es F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL
  FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS KeyA KeyS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  Machine NIL NONE NOTIN NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT
  NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY
  OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN
  OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR
  OWHILE Operator Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PR PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV Role S SC SCANL
  SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL
  SIMP_REC SIMP_REC_REL SING SINGL SM0StateInterp SM0ns SM0out SN SND
  SNOC SOME SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TT TYPE_DEFINITION UNCURRY UNION
  UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC
  WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certs certsr1 chooser
  command_CASE command_size configuration_CASE configuration_size
  controls count countable deciphP deciphS delN dest_rec diag diamond
  digest_CASE digest_size discard domi doms dropWhile enumerate eqf eqi
  eqn eqs equiv_on equivalence exec findi findq fupdLast hash iBIT_cases
  iLab il imapKS impf inputOK inputOKr1 inst_CASE inst_size
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS launch lift2 listRel list_CASE list_size literal_case
  lt lte mapSM0inputOperatorBob measure meet mk_rec napp nat_elim__magic
  ncons nf nfoldl nfst nlen nlistrec nmap nnil notf npair npriv2num
  npriv_CASE npriv_size nsnd nub num2npriv num2output num2privcmd
  num2role num2staff num2state num_CASE num_to_pair o off on one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf output2num output_CASE output_size pKey_CASE pKey_size
  pair_CASE pair_size pair_to_num pairwise partition principal_CASE
  principal_size privK privcmd2num privcmd_CASE privcmd_size prod_PO
  prop pubK quoting rcdiamond reflexive repPO reps reset role2num
  role_CASE role_size sLab sat satList says schroeder_close set sign
  signVerify sl smapKS some speaks_for splitAtPki staff2num staff_CASE
  staff_size state2num state_CASE state_size status stmarker sum_CASE
  sum_size sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric
  the_fun the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE output_CASE state_CASE
    command_CASE npriv_CASE privcmd_CASE principal_CASE staff_CASE
    role_CASE authority_CASE digest_CASE asymMsg_CASE pKey_CASE
    symMsg_CASE symKey_CASE list_CASE option_CASE sum_CASE num_CASE
    pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val SM0r2_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | command |
                  (TY, TY, TY, TY, TY, TY)configuration | TY digest |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  npriv | num | one | TY option | output | TY pKey |
                  TY po | principal | privcmd | (TY, TY)prod |
                  TY recspace | role | TY set | staff | state |
                  (TY, TY)sum | symKey | TY symMsg | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander
  Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL
  EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea
  Efn Es F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL
  FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS KeyA KeyS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  Machine NIL NONE NOTIN NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT
  NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY
  OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN
  OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR
  OWHILE Operator Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PR PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV Role S SC SCANL
  SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL
  SIMP_REC SIMP_REC_REL SING SINGL SM0StateInterp SM0ns SM0out SN SND
  SNOC SOME SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TT TYPE_DEFINITION UNCURRY UNION
  UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC
  WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certs certsr1 certsr2
  certsr2root certsr2signed chooser command_CASE command_size
  configuration_CASE configuration_size controls count countable deciphP
  deciphS delN dest_rec diag diamond digest_CASE digest_size discard
  domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on equivalence
  exec findi findq fupdLast hash iBIT_cases iLab il imapKS impf inputOK
  inputOKr1 inputOKr2 inst_CASE inst_size internal_mult intpKS inv
  inv_image invtri invtri0 irreflexive isPREFIX itself_case jKS launch
  lift2 listRel list_CASE list_size literal_case lt lte
  mapSM0inputOperatorBob mapSM0r1input measure meet mk_rec napp
  nat_elim__magic ncons nf nfoldl nfst nlen nlistrec nmap nnil notf
  npair npriv2num npriv_CASE npriv_size nsnd nub num2npriv num2output
  num2privcmd num2role num2staff num2state num_CASE num_to_pair o off on
  one one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf output2num output_CASE output_size pKey_CASE pKey_size
  pair_CASE pair_size pair_to_num pairwise partition principal_CASE
  principal_size privK privcmd2num privcmd_CASE privcmd_size prod_PO
  prop pubK quoting rcdiamond reflexive repPO reps reset role2num
  role_CASE role_size sLab sat satList says schroeder_close set sign
  signVerify sl smapKS some speaks_for splitAtPki staff2num staff_CASE
  staff_size state2num state_CASE state_size status stmarker sum_CASE
  sum_size sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric
  the_fun the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE output_CASE state_CASE
    command_CASE npriv_CASE privcmd_CASE principal_CASE staff_CASE
    role_CASE authority_CASE digest_CASE asymMsg_CASE pKey_CASE
    symMsg_CASE symKey_CASE list_CASE option_CASE sum_CASE num_CASE
    pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val SM0r3_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | (TY, TY)certificate | command |
                  (TY, TY, TY, TY, TY, TY)configuration |
                  (TY, TY, TY, TY, TY, TY, TY, TY)configuration2 |
                  TY digest | (TY, TY)fun | inMsg | ind | TY inst |
                  TY itself | TY list | npriv | num | one | TY option |
                  order | output | TY pKey | TY po | principal |
                  privcmd | (TY, TY)prod | TY recspace | role | TY set |
                  staff | state | (TY, TY)sum | symKey | TY symMsg |
                  TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  ('a, 'b) certificate = (α, β) certStructure$certificate
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h) configuration2 = (α, β, γ, δ, ε, ζ, η, θ) ssm2$configuration2
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  inMsg = inMsg$inMsg                                    
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  order = inMsg$order                                    
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFG2 CFG2Interpret
  CFGInterpret CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Carol Commander Cong DATATYPE DELETE DFUNSET DIFF DISJOINT
  DIV DIV2 DIVMOD DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2
  EVERYi EXISTS EXP EXT_POINT Ea Efn Es F FACT FAIL FCOMM FF FILTER FIND
  FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET
  Form_CASE Form_size GENLIST GENLIST_AUX GSPEC GUESS_EXISTS
  GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP
  GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF
  INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT
  INTER INVOL ISL ISR IS_EL IS_NONE IS_NUM_REP IS_PREFIX
  IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST
  IS_SUFFIX IS_SUM_REP ITSET Id IfCases IntLevel_CASE IntLevel_size Jext
  K KS KeyA KeyS Kripke_CASE Kripke_size LAST LASTN LEAST LEFT_ID LEN
  LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND LIST_ELEM_COUNT
  LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi LIST_TO_SET LLEX LRC
  LUPDATE Lifn LinearOrder Lsfn MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM
  MIN MIN_SET MOD MODEQ MONOID MSG Machine MsgInterpret NIL NONE NOTIN
  NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O O1 ODD
  OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE
  OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2
  OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Operator Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PR PRE
  PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET
  PSUBSET PreOrder Princ_CASE Princ_size RC RCOMPL RCert RDOM
  RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV Role S SC SCANL SCANR SCert SEG SET_TO_LIST SIGMA
  SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING
  SINGL SM0StateInterp SM0ns SM0out SN SND SNOC SOME SOME_EL SPLITL
  SPLITP SPLITP_AUX SPLITR STBY STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size Staff StrongLinearOrder StrongOrder Subset_PO T TAKE TC
  THE TL TL_T TR TR2 TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT
  UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE
  WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certificateInterpret
  certificate_CASE certificate_size certificatesr3 certs certsr1 certsr2
  certsr2root certsr2signed checkMsg checkcert chooser command_CASE
  command_size configuration2_CASE configuration2_size
  configuration_CASE configuration_size controls count countable deciphP
  deciphS delN dest_rec diag diamond digest_CASE digest_size discard
  domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on equivalence
  exec findi findq fupdLast hash iBIT_cases iLab il imapKS impf
  inMsg_CASE inMsg_size inputOK inputOKr1 inputOKr2 inst_CASE inst_size
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS launch lift2 listRel list_CASE list_size literal_case
  lt lte mapSM0inputOperatorBob mapSM0r1input measure meet mkRCert
  mkSCert mk_rec mkinMsg napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair npriv2num npriv_CASE npriv_size nsnd nub
  num2npriv num2output num2privcmd num2role num2staff num2state num_CASE
  num_to_pair o off on one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orderInterpret order_CASE
  order_size orf output2num output_CASE output_size pKey_CASE pKey_size
  pair_CASE pair_size pair_to_num pairwise partition principal_CASE
  principal_size privK privcmd2num privcmd_CASE privcmd_size prod_PO
  prop pubK quoting rcdiamond reflexive repPO reps reset role2num
  role_CASE role_size sLab sat satList says schroeder_close set sign
  signVerify sl smapKS some speaks_for splitAtPki staff2num staff_CASE
  staff_size state2num state_CASE state_size status stmarker sum_CASE
  sum_size sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric
  the_fun the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  Order              ->  inMsg$Order relation$Order
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    certificate_CASE inMsg_CASE order_CASE configuration2_CASE
    configuration_CASE trType_CASE inst_CASE Kripke_CASE Form_CASE
    SecLevel_CASE IntLevel_CASE Princ_CASE output_CASE state_CASE
    command_CASE npriv_CASE privcmd_CASE principal_CASE staff_CASE
    role_CASE authority_CASE digest_CASE asymMsg_CASE pKey_CASE
    symMsg_CASE symKey_CASE list_CASE option_CASE sum_CASE num_CASE
    pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val authority_11 =
   |- ∀a a'. (ca a = ca a') ⇔ (a = a'):
   thm
val authority_Axiom =
   |- ∀f. ∃fn. ∀a. fn (ca a) = f a:
   thm
val authority_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'authority' .
            (∀a0.
               (∃a.
                  a0 =
                  (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM)) a) ⇒
               'authority' a0) ⇒
            'authority' a0) rep:
   thm
val authority_case_cong =
   |- ∀M M' f.
     (M = M') ∧ (∀a. (M' = ca a) ⇒ (f a = f' a)) ⇒
     (authority_CASE M f = authority_CASE M' f'):
   thm
val authority_case_def =
   |- ∀a f. authority_CASE (ca a) f = f a:
   thm
val authority_induction =
   |- ∀P. (∀n. P (ca n)) ⇒ ∀a. P a:
   thm
val authority_nchotomy =
   |- ∀aa. ∃n. aa = ca n:
   thm
val authority_one_one =
   |- ∀a a'. (ca a = ca a') ⇔ (a = a'):
   thm
val authority_size_def =
   |- ∀a. authority_size (ca a) = 1 + a:
   thm
val certificatesr3_certsr2_map_thm =
   |- ∀npriv privcmd.
     MAP certificateInterpret (certificatesr3 npriv privcmd) =
     certsr2 npriv privcmd:
   thm
val certificatesr3_def =
   |- ∀npriv privcmd.
     certificatesr3 npriv privcmd =
     MAP mkRCert (certsr1 npriv privcmd ++ certsr2root npriv privcmd) ++
     MAP (mkSCert (ca 0)) (certsr2signed npriv privcmd):
   thm
val certs_def =
   |- ∀npriv privcmd.
     certs npriv privcmd =
     [Name (Role Operator) controls prop (SOME (NP npriv));
      Name (Role Operator) controls prop (SOME (PR privcmd));
      Name (Role Commander) controls prop (SOME (NP npriv));
      Name (Role Commander) says prop (SOME (PR privcmd)) impf
      prop NONE]:
   thm
val certsr1_def =
   |- ∀npriv privcmd.
     certsr1 npriv privcmd =
     certs npriv privcmd ++
     [reps (Name (Staff Alice)) (Name (Role Commander))
        (prop (SOME (NP npriv)));
      reps (Name (Staff Bob)) (Name (Role Operator))
        (prop (SOME (PR privcmd)));
      reps (Name (Staff Bob)) (Name (Role Operator))
        (prop (SOME (NP npriv)))]:
   thm
val certsr2_def =
   |- ∀npriv privcmd.
     certsr2 npriv privcmd =
     certsr1 npriv privcmd ++ certsr2root npriv privcmd ++
     certsr2signed npriv privcmd:
   thm
val certsr2root_def =
   |- ∀npriv privcmd.
     certsr2root npriv privcmd =
     [Name (KeyA (pubK (ca 0))) speaks_for Name (Authority (ca 0));
      Name (Authority (ca 0)) controls
      Name (KeyS (pubK Bob)) speaks_for Name (Staff Bob);
      Name (Authority (ca 0)) controls
      Name (KeyS (pubK Alice)) speaks_for Name (Staff Alice)]:
   thm
val certsr2signed_def =
   |- ∀npriv privcmd.
     certsr2signed npriv privcmd =
     [Name (KeyA (pubK (ca 0))) says
      Name (KeyS (pubK Bob)) speaks_for Name (Staff Bob);
      Name (KeyA (pubK (ca 0))) says
      Name (KeyS (pubK Alice)) speaks_for Name (Staff Alice)]:
   thm
val datatype_authority =
   |- DATATYPE (authority ca):
   thm
val datatype_principal =
   |- DATATYPE (principal Staff Authority Role KeyS KeyA Machine):
   thm
val datatype_role =
   |- DATATYPE (role Commander Operator):
   thm
val datatype_staff =
   |- DATATYPE (staff Alice Bob Carol):
   thm
val inputOK_TT_reject_lemma =
   |- ¬inputOK TT:
   thm
val inputOK_cmd_reject_lemma =
   |- ∀cmd. ¬inputOK (prop (SOME cmd)):
   thm
val inputOK_def =
   |- (inputOK (Name (Role Operator) says prop (SOME cmd)) ⇔ T) ∧
   (inputOK (Name (Role Commander) says prop (SOME cmd)) ⇔ T) ∧
   (inputOK TT ⇔ F) ∧ (inputOK FF ⇔ F) ∧ (inputOK (prop v) ⇔ F) ∧
   (inputOK (notf v1) ⇔ F) ∧ (inputOK (v2 andf v3) ⇔ F) ∧
   (inputOK (v4 orf v5) ⇔ F) ∧ (inputOK (v6 impf v7) ⇔ F) ∧
   (inputOK (v8 eqf v9) ⇔ F) ∧ (inputOK (v10 says TT) ⇔ F) ∧
   (inputOK (v10 says FF) ⇔ F) ∧
   (inputOK (Name (Staff v144) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name (Authority v145) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name (KeyS v147) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name (KeyA v148) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name (Machine v149) says prop (SOME v142)) ⇔ F) ∧
   (inputOK (Name v132 says prop NONE) ⇔ F) ∧
   (inputOK (v133 meet v134 says prop v66) ⇔ F) ∧
   (inputOK (v135 quoting v136 says prop v66) ⇔ F) ∧
   (inputOK (v10 says notf v67) ⇔ F) ∧
   (inputOK (v10 says (v68 andf v69)) ⇔ F) ∧
   (inputOK (v10 says (v70 orf v71)) ⇔ F) ∧
   (inputOK (v10 says (v72 impf v73)) ⇔ F) ∧
   (inputOK (v10 says (v74 eqf v75)) ⇔ F) ∧
   (inputOK (v10 says v76 says v77) ⇔ F) ∧
   (inputOK (v10 says v78 speaks_for v79) ⇔ F) ∧
   (inputOK (v10 says v80 controls v81) ⇔ F) ∧
   (inputOK (v10 says reps v82 v83 v84) ⇔ F) ∧
   (inputOK (v10 says v85 domi v86) ⇔ F) ∧
   (inputOK (v10 says v87 eqi v88) ⇔ F) ∧
   (inputOK (v10 says v89 doms v90) ⇔ F) ∧
   (inputOK (v10 says v91 eqs v92) ⇔ F) ∧
   (inputOK (v10 says v93 eqn v94) ⇔ F) ∧
   (inputOK (v10 says v95 lte v96) ⇔ F) ∧
   (inputOK (v10 says v97 lt v98) ⇔ F) ∧
   (inputOK (v12 speaks_for v13) ⇔ F) ∧
   (inputOK (v14 controls v15) ⇔ F) ∧ (inputOK (reps v16 v17 v18) ⇔ F) ∧
   (inputOK (v19 domi v20) ⇔ F) ∧ (inputOK (v21 eqi v22) ⇔ F) ∧
   (inputOK (v23 doms v24) ⇔ F) ∧ (inputOK (v25 eqs v26) ⇔ F) ∧
   (inputOK (v27 eqn v28) ⇔ F) ∧ (inputOK (v29 lte v30) ⇔ F) ∧
   (inputOK (v31 lt v32) ⇔ F):
   thm
val inputOK_ind =
   |- ∀P.
     (∀cmd. P (Name (Role Operator) says prop (SOME cmd))) ∧
     (∀cmd. P (Name (Role Commander) says prop (SOME cmd))) ∧ P TT ∧
     P FF ∧ (∀v. P (prop v)) ∧ (∀v1. P (notf v1)) ∧
     (∀v2 v3. P (v2 andf v3)) ∧ (∀v4 v5. P (v4 orf v5)) ∧
     (∀v6 v7. P (v6 impf v7)) ∧ (∀v8 v9. P (v8 eqf v9)) ∧
     (∀v10. P (v10 says TT)) ∧ (∀v10. P (v10 says FF)) ∧
     (∀v144 v142. P (Name (Staff v144) says prop (SOME v142))) ∧
     (∀v145 v142. P (Name (Authority v145) says prop (SOME v142))) ∧
     (∀v147 v142. P (Name (KeyS v147) says prop (SOME v142))) ∧
     (∀v148 v142. P (Name (KeyA v148) says prop (SOME v142))) ∧
     (∀v149 v142. P (Name (Machine v149) says prop (SOME v142))) ∧
     (∀v132. P (Name v132 says prop NONE)) ∧
     (∀v133 v134 v66. P (v133 meet v134 says prop v66)) ∧
     (∀v135 v136 v66. P (v135 quoting v136 says prop v66)) ∧
     (∀v10 v67. P (v10 says notf v67)) ∧
     (∀v10 v68 v69. P (v10 says (v68 andf v69))) ∧
     (∀v10 v70 v71. P (v10 says (v70 orf v71))) ∧
     (∀v10 v72 v73. P (v10 says (v72 impf v73))) ∧
     (∀v10 v74 v75. P (v10 says (v74 eqf v75))) ∧
     (∀v10 v76 v77. P (v10 says v76 says v77)) ∧
     (∀v10 v78 v79. P (v10 says v78 speaks_for v79)) ∧
     (∀v10 v80 v81. P (v10 says v80 controls v81)) ∧
     (∀v10 v82 v83 v84. P (v10 says reps v82 v83 v84)) ∧
     (∀v10 v85 v86. P (v10 says v85 domi v86)) ∧
     (∀v10 v87 v88. P (v10 says v87 eqi v88)) ∧
     (∀v10 v89 v90. P (v10 says v89 doms v90)) ∧
     (∀v10 v91 v92. P (v10 says v91 eqs v92)) ∧
     (∀v10 v93 v94. P (v10 says v93 eqn v94)) ∧
     (∀v10 v95 v96. P (v10 says v95 lte v96)) ∧
     (∀v10 v97 v98. P (v10 says v97 lt v98)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val inputOK_primitive_def =
   |- inputOK =
   WFREC (@R. WF R)
     (λinputOK a.
        case a of
          TT => I F
        | FF => I F
        | prop v33 => I F
        | notf v34 => I F
        | v35 andf v36 => I F
        | v37 orf v38 => I F
        | v39 impf v40 => I F
        | v41 eqf v42 => I F
        | v43 says TT => I F
        | v43 says FF => I F
        | Name (Staff v150) says prop (SOME v143) => I F
        | Name (Authority v151) says prop (SOME v143) => I F
        | Name (Role v152) says prop (SOME v143) => I T
        | Name (KeyS v153) says prop (SOME v143) => I F
        | Name (KeyA v154) says prop (SOME v143) => I F
        | Name (Machine v155) says prop (SOME v143) => I F
        | Name v137 says prop NONE => I F
        | v138 meet v139 says prop v99 => I F
        | v140 quoting v141 says prop v99 => I F
        | v43 says notf v100 => I F
        | v43 says (v101 andf v102) => I F
        | v43 says (v103 orf v104) => I F
        | v43 says (v105 impf v106) => I F
        | v43 says (v107 eqf v108) => I F
        | v43 says v109 says v110 => I F
        | v43 says v111 speaks_for v112 => I F
        | v43 says v113 controls v114 => I F
        | v43 says reps v115 v116 v117 => I F
        | v43 says v118 domi v119 => I F
        | v43 says v120 eqi v121 => I F
        | v43 says v122 doms v123 => I F
        | v43 says v124 eqs v125 => I F
        | v43 says v126 eqn v127 => I F
        | v43 says v128 lte v129 => I F
        | v43 says v130 lt v131 => I F
        | v45 speaks_for v46 => I F
        | v47 controls v48 => I F
        | reps v49 v50 v51 => I F
        | v52 domi v53 => I F
        | v54 eqi v55 => I F
        | v56 doms v57 => I F
        | v58 eqs v59 => I F
        | v60 eqn v61 => I F
        | v62 lte v63 => I F
        | v64 lt v65 => I F):
   thm
val inputOK_staff_rejected_lemma =
   |- ∀P cmd. ¬inputOK (Name (Staff P) says prop (SOME cmd)):
   thm
val inputOKr1_TT_reject_lemma =
   |- ¬inputOKr1 TT:
   thm
val inputOKr1_cmd_reject_lemma =
   |- ∀cmd. ¬inputOKr1 (prop (SOME cmd)):
   thm
val inputOKr1_def =
   |- (inputOKr1
      (Name (Staff Bob) quoting Name (Role Operator) says
       prop (SOME cmd)) ⇔ T) ∧
   (inputOKr1
      (Name (Staff Alice) quoting Name (Role Commander) says
       prop (SOME cmd)) ⇔ T) ∧ (inputOKr1 TT ⇔ F) ∧ (inputOKr1 FF ⇔ F) ∧
   (inputOKr1 (prop v) ⇔ F) ∧ (inputOKr1 (notf v1) ⇔ F) ∧
   (inputOKr1 (v2 andf v3) ⇔ F) ∧ (inputOKr1 (v4 orf v5) ⇔ F) ∧
   (inputOKr1 (v6 impf v7) ⇔ F) ∧ (inputOKr1 (v8 eqf v9) ⇔ F) ∧
   (inputOKr1 (v10 says TT) ⇔ F) ∧ (inputOKr1 (v10 says FF) ⇔ F) ∧
   (inputOKr1 (Name v132 says prop v66) ⇔ F) ∧
   (inputOKr1 (v133 meet v134 says prop v66) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (Staff v164) says prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (Authority v165) says prop (SOME v142)) ⇔
    F) ∧
   (inputOKr1
      (Name (Staff Bob) quoting Name (Role Commander) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Staff Carol) quoting Name (Role Commander) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Staff Alice) quoting Name (Role Operator) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Staff Carol) quoting Name (Role Operator) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Authority v177) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Role v178) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (KeyS v179) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (KeyA v180) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name (Machine v181) quoting Name (Role v166) says
       prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (KeyS v167) says prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (KeyA v168) says prop (SOME v142)) ⇔ F) ∧
   (inputOKr1
      (Name v154 quoting Name (Machine v169) says prop (SOME v142)) ⇔
    F) ∧
   (inputOKr1 (v155 meet v156 quoting Name v144 says prop (SOME v142)) ⇔
    F) ∧
   (inputOKr1
      ((v157 quoting v158) quoting Name v144 says prop (SOME v142)) ⇔
    F) ∧
   (inputOKr1 (v135 quoting v145 meet v146 says prop (SOME v142)) ⇔ F) ∧
   (inputOKr1 (v135 quoting v147 quoting v148 says prop (SOME v142)) ⇔
    F) ∧ (inputOKr1 (v135 quoting v136 says prop NONE) ⇔ F) ∧
   (inputOKr1 (v10 says notf v67) ⇔ F) ∧
   (inputOKr1 (v10 says (v68 andf v69)) ⇔ F) ∧
   (inputOKr1 (v10 says (v70 orf v71)) ⇔ F) ∧
   (inputOKr1 (v10 says (v72 impf v73)) ⇔ F) ∧
   (inputOKr1 (v10 says (v74 eqf v75)) ⇔ F) ∧
   (inputOKr1 (v10 says v76 says v77) ⇔ F) ∧
   (inputOKr1 (v10 says v78 speaks_for v79) ⇔ F) ∧
   (inputOKr1 (v10 says v80 controls v81) ⇔ F) ∧
   (inputOKr1 (v10 says reps v82 v83 v84) ⇔ F) ∧
   (inputOKr1 (v10 says v85 domi v86) ⇔ F) ∧
   (inputOKr1 (v10 says v87 eqi v88) ⇔ F) ∧
   (inputOKr1 (v10 says v89 doms v90) ⇔ F) ∧
   (inputOKr1 (v10 says v91 eqs v92) ⇔ F) ∧
   (inputOKr1 (v10 says v93 eqn v94) ⇔ F) ∧
   (inputOKr1 (v10 says v95 lte v96) ⇔ F) ∧
   (inputOKr1 (v10 says v97 lt v98) ⇔ F) ∧
   (inputOKr1 (v12 speaks_for v13) ⇔ F) ∧
   (inputOKr1 (v14 controls v15) ⇔ F) ∧
   (inputOKr1 (reps v16 v17 v18) ⇔ F) ∧ (inputOKr1 (v19 domi v20) ⇔ F) ∧
   (inputOKr1 (v21 eqi v22) ⇔ F) ∧ (inputOKr1 (v23 doms v24) ⇔ F) ∧
   (inputOKr1 (v25 eqs v26) ⇔ F) ∧ (inputOKr1 (v27 eqn v28) ⇔ F) ∧
   (inputOKr1 (v29 lte v30) ⇔ F) ∧ (inputOKr1 (v31 lt v32) ⇔ F):
   thm
val inputOKr1_ind =
   |- ∀P.
     (∀cmd.
        P
          (Name (Staff Bob) quoting Name (Role Operator) says
           prop (SOME cmd))) ∧
     (∀cmd.
        P
          (Name (Staff Alice) quoting Name (Role Commander) says
           prop (SOME cmd))) ∧ P TT ∧ P FF ∧ (∀v. P (prop v)) ∧
     (∀v1. P (notf v1)) ∧ (∀v2 v3. P (v2 andf v3)) ∧
     (∀v4 v5. P (v4 orf v5)) ∧ (∀v6 v7. P (v6 impf v7)) ∧
     (∀v8 v9. P (v8 eqf v9)) ∧ (∀v10. P (v10 says TT)) ∧
     (∀v10. P (v10 says FF)) ∧
     (∀v132 v66. P (Name v132 says prop v66)) ∧
     (∀v133 v134 v66. P (v133 meet v134 says prop v66)) ∧
     (∀v154 v164 v142.
        P (Name v154 quoting Name (Staff v164) says prop (SOME v142))) ∧
     (∀v154 v165 v142.
        P
          (Name v154 quoting Name (Authority v165) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Bob) quoting Name (Role Commander) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Carol) quoting Name (Role Commander) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Alice) quoting Name (Role Operator) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Carol) quoting Name (Role Operator) says
           prop (SOME v142))) ∧
     (∀v177 v166 v142.
        P
          (Name (Authority v177) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v178 v166 v142.
        P
          (Name (Role v178) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v179 v166 v142.
        P
          (Name (KeyS v179) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v180 v166 v142.
        P
          (Name (KeyA v180) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v181 v166 v142.
        P
          (Name (Machine v181) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v154 v167 v142.
        P (Name v154 quoting Name (KeyS v167) says prop (SOME v142))) ∧
     (∀v154 v168 v142.
        P (Name v154 quoting Name (KeyA v168) says prop (SOME v142))) ∧
     (∀v154 v169 v142.
        P
          (Name v154 quoting Name (Machine v169) says
           prop (SOME v142))) ∧
     (∀v155 v156 v144 v142.
        P (v155 meet v156 quoting Name v144 says prop (SOME v142))) ∧
     (∀v157 v158 v144 v142.
        P
          ((v157 quoting v158) quoting Name v144 says
           prop (SOME v142))) ∧
     (∀v135 v145 v146 v142.
        P (v135 quoting v145 meet v146 says prop (SOME v142))) ∧
     (∀v135 v147 v148 v142.
        P (v135 quoting v147 quoting v148 says prop (SOME v142))) ∧
     (∀v135 v136. P (v135 quoting v136 says prop NONE)) ∧
     (∀v10 v67. P (v10 says notf v67)) ∧
     (∀v10 v68 v69. P (v10 says (v68 andf v69))) ∧
     (∀v10 v70 v71. P (v10 says (v70 orf v71))) ∧
     (∀v10 v72 v73. P (v10 says (v72 impf v73))) ∧
     (∀v10 v74 v75. P (v10 says (v74 eqf v75))) ∧
     (∀v10 v76 v77. P (v10 says v76 says v77)) ∧
     (∀v10 v78 v79. P (v10 says v78 speaks_for v79)) ∧
     (∀v10 v80 v81. P (v10 says v80 controls v81)) ∧
     (∀v10 v82 v83 v84. P (v10 says reps v82 v83 v84)) ∧
     (∀v10 v85 v86. P (v10 says v85 domi v86)) ∧
     (∀v10 v87 v88. P (v10 says v87 eqi v88)) ∧
     (∀v10 v89 v90. P (v10 says v89 doms v90)) ∧
     (∀v10 v91 v92. P (v10 says v91 eqs v92)) ∧
     (∀v10 v93 v94. P (v10 says v93 eqn v94)) ∧
     (∀v10 v95 v96. P (v10 says v95 lte v96)) ∧
     (∀v10 v97 v98. P (v10 says v97 lt v98)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val inputOKr1_primitive_def =
   |- inputOKr1 =
   WFREC (@R. WF R)
     (λinputOKr1 a.
        case a of
          TT => I F
        | FF => I F
        | prop v33 => I F
        | notf v34 => I F
        | v35 andf v36 => I F
        | v37 orf v38 => I F
        | v39 impf v40 => I F
        | v41 eqf v42 => I F
        | v43 says TT => I F
        | v43 says FF => I F
        | Name v137 says prop v99 => I F
        | v138 meet v139 says prop v99 => I F
        | Name v159 quoting Name (Staff v170) says prop (SOME cmd) =>
            I F
        | Name v159 quoting Name (Authority v171) says
          prop (SOME cmd) =>
            I F
        | Name (Staff Alice) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I T
        | Name (Staff Bob) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I F
        | Name (Staff Carol) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I F
        | Name (Staff Alice) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I F
        | Name (Staff Bob) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I T
        | Name (Staff Carol) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I F
        | Name (Authority v183) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name (Role v184) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS v185) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name (KeyA v186) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name (Machine v187) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I F
        | Name v159 quoting Name (KeyS v173) says prop (SOME cmd) => I F
        | Name v159 quoting Name (KeyA v174) says prop (SOME cmd) => I F
        | Name v159 quoting Name (Machine v175) says prop (SOME cmd) =>
            I F
        | v160 meet v161 quoting Name v149 says prop (SOME cmd) => I F
        | (v162 quoting v163) quoting Name v149 says prop (SOME cmd) =>
            I F
        | v140 quoting v150 meet v151 says prop (SOME cmd) => I F
        | v140 quoting v152 quoting v153 says prop (SOME cmd) => I F
        | v140 quoting v141 says prop NONE => I F
        | v43 says notf v100 => I F
        | v43 says (v101 andf v102) => I F
        | v43 says (v103 orf v104) => I F
        | v43 says (v105 impf v106) => I F
        | v43 says (v107 eqf v108) => I F
        | v43 says v109 says v110 => I F
        | v43 says v111 speaks_for v112 => I F
        | v43 says v113 controls v114 => I F
        | v43 says reps v115 v116 v117 => I F
        | v43 says v118 domi v119 => I F
        | v43 says v120 eqi v121 => I F
        | v43 says v122 doms v123 => I F
        | v43 says v124 eqs v125 => I F
        | v43 says v126 eqn v127 => I F
        | v43 says v128 lte v129 => I F
        | v43 says v130 lt v131 => I F
        | v45 speaks_for v46 => I F
        | v47 controls v48 => I F
        | reps v49 v50 v51 => I F
        | v52 domi v53 => I F
        | v54 eqi v55 => I F
        | v56 doms v57 => I F
        | v58 eqs v59 => I F
        | v60 eqn v61 => I F
        | v62 lte v63 => I F
        | v64 lt v65 => I F):
   thm
val inputOKr1_staff_rejected_lemma =
   |- ∀P cmd. ¬inputOKr1 (Name (Staff P) says prop (SOME cmd)):
   thm
val inputOKr2_def =
   |- (inputOKr2
      (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
       prop (SOME cmd)) ⇔ T) ∧
   (inputOKr2
      (Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
       prop (SOME cmd)) ⇔ T) ∧ (inputOKr2 TT ⇔ F) ∧ (inputOKr2 FF ⇔ F) ∧
   (inputOKr2 (prop v) ⇔ F) ∧ (inputOKr2 (notf v1) ⇔ F) ∧
   (inputOKr2 (v2 andf v3) ⇔ F) ∧ (inputOKr2 (v4 orf v5) ⇔ F) ∧
   (inputOKr2 (v6 impf v7) ⇔ F) ∧ (inputOKr2 (v8 eqf v9) ⇔ F) ∧
   (inputOKr2 (Name v66 says v11) ⇔ F) ∧
   (inputOKr2 (v67 meet v68 says v11) ⇔ F) ∧
   (inputOKr2 (Name (Staff v86) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (Name (Authority v87) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (Name (Role v88) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Staff v112) says v11) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Authority v113) says v11) ⇔
    F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says TT) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says FF) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK Bob)) quoting Name (Role Commander) says
       prop (SOME v190)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK Carol)) quoting Name (Role Commander) says
       prop (SOME v190)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK Alice)) quoting Name (Role Operator) says
       prop (SOME v190)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK Carol)) quoting Name (Role Operator) says
       prop (SOME v190)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says prop NONE) ⇔
    F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says notf v125) ⇔
    F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       (v126 andf v127)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       (v128 orf v129)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       (v130 impf v131)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       (v132 eqf v133)) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v134 says
       v135) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       v136 speaks_for v137) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       v138 controls v139) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says
       reps v140 v141 v142) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v143 domi
       v144) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v145 eqi
       v146) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v147 doms
       v148) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v149 eqs
       v150) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v151 eqn
       v152) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v153 lte
       v154) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Role v114) says v155 lt
       v156) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (KeyS v115) says v11) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (KeyA v116) says v11) ⇔ F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting Name (Machine v117) says v11) ⇔
    F) ∧
   (inputOKr2 (Name (KeyS (pubK v98)) quoting v103 meet v104 says v11) ⇔
    F) ∧
   (inputOKr2
      (Name (KeyS (pubK v98)) quoting v105 quoting v106 says v11) ⇔ F) ∧
   (inputOKr2 (Name (KeyS (privK v99)) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (Name (KeyA v90) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (Name (Machine v91) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (v77 meet v78 quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 ((v79 quoting v80) quoting v70 says v11) ⇔ F) ∧
   (inputOKr2 (v12 speaks_for v13) ⇔ F) ∧
   (inputOKr2 (v14 controls v15) ⇔ F) ∧
   (inputOKr2 (reps v16 v17 v18) ⇔ F) ∧ (inputOKr2 (v19 domi v20) ⇔ F) ∧
   (inputOKr2 (v21 eqi v22) ⇔ F) ∧ (inputOKr2 (v23 doms v24) ⇔ F) ∧
   (inputOKr2 (v25 eqs v26) ⇔ F) ∧ (inputOKr2 (v27 eqn v28) ⇔ F) ∧
   (inputOKr2 (v29 lte v30) ⇔ F) ∧ (inputOKr2 (v31 lt v32) ⇔ F):
   thm
val inputOKr2_ind =
   |- ∀P.
     (∀cmd.
        P
          (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
           prop (SOME cmd))) ∧
     (∀cmd.
        P
          (Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
           prop (SOME cmd))) ∧ P TT ∧ P FF ∧ (∀v. P (prop v)) ∧
     (∀v1. P (notf v1)) ∧ (∀v2 v3. P (v2 andf v3)) ∧
     (∀v4 v5. P (v4 orf v5)) ∧ (∀v6 v7. P (v6 impf v7)) ∧
     (∀v8 v9. P (v8 eqf v9)) ∧ (∀v66 v11. P (Name v66 says v11)) ∧
     (∀v67 v68 v11. P (v67 meet v68 says v11)) ∧
     (∀v86 v70 v11. P (Name (Staff v86) quoting v70 says v11)) ∧
     (∀v87 v70 v11. P (Name (Authority v87) quoting v70 says v11)) ∧
     (∀v88 v70 v11. P (Name (Role v88) quoting v70 says v11)) ∧
     (∀v98 v112 v11.
        P (Name (KeyS (pubK v98)) quoting Name (Staff v112) says v11)) ∧
     (∀v98 v113 v11.
        P
          (Name (KeyS (pubK v98)) quoting Name (Authority v113) says
           v11)) ∧
     (∀v98 v114.
        P (Name (KeyS (pubK v98)) quoting Name (Role v114) says TT)) ∧
     (∀v98 v114.
        P (Name (KeyS (pubK v98)) quoting Name (Role v114) says FF)) ∧
     (∀v190.
        P
          (Name (KeyS (pubK Bob)) quoting Name (Role Commander) says
           prop (SOME v190))) ∧
     (∀v190.
        P
          (Name (KeyS (pubK Carol)) quoting Name (Role Commander) says
           prop (SOME v190))) ∧
     (∀v190.
        P
          (Name (KeyS (pubK Alice)) quoting Name (Role Operator) says
           prop (SOME v190))) ∧
     (∀v190.
        P
          (Name (KeyS (pubK Carol)) quoting Name (Role Operator) says
           prop (SOME v190))) ∧
     (∀v98 v114.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           prop NONE)) ∧
     (∀v98 v114 v125.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           notf v125)) ∧
     (∀v98 v114 v126 v127.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           (v126 andf v127))) ∧
     (∀v98 v114 v128 v129.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           (v128 orf v129))) ∧
     (∀v98 v114 v130 v131.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           (v130 impf v131))) ∧
     (∀v98 v114 v132 v133.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           (v132 eqf v133))) ∧
     (∀v98 v114 v134 v135.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v134 says v135)) ∧
     (∀v98 v114 v136 v137.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v136 speaks_for v137)) ∧
     (∀v98 v114 v138 v139.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v138 controls v139)) ∧
     (∀v98 v114 v140 v141 v142.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           reps v140 v141 v142)) ∧
     (∀v98 v114 v143 v144.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v143 domi v144)) ∧
     (∀v98 v114 v145 v146.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v145 eqi
           v146)) ∧
     (∀v98 v114 v147 v148.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says
           v147 doms v148)) ∧
     (∀v98 v114 v149 v150.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v149 eqs
           v150)) ∧
     (∀v98 v114 v151 v152.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v151 eqn
           v152)) ∧
     (∀v98 v114 v153 v154.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v153 lte
           v154)) ∧
     (∀v98 v114 v155 v156.
        P
          (Name (KeyS (pubK v98)) quoting Name (Role v114) says v155 lt
           v156)) ∧
     (∀v98 v115 v11.
        P (Name (KeyS (pubK v98)) quoting Name (KeyS v115) says v11)) ∧
     (∀v98 v116 v11.
        P (Name (KeyS (pubK v98)) quoting Name (KeyA v116) says v11)) ∧
     (∀v98 v117 v11.
        P
          (Name (KeyS (pubK v98)) quoting Name (Machine v117) says
           v11)) ∧
     (∀v98 v103 v104 v11.
        P (Name (KeyS (pubK v98)) quoting v103 meet v104 says v11)) ∧
     (∀v98 v105 v106 v11.
        P (Name (KeyS (pubK v98)) quoting v105 quoting v106 says v11)) ∧
     (∀v99 v70 v11. P (Name (KeyS (privK v99)) quoting v70 says v11)) ∧
     (∀v90 v70 v11. P (Name (KeyA v90) quoting v70 says v11)) ∧
     (∀v91 v70 v11. P (Name (Machine v91) quoting v70 says v11)) ∧
     (∀v77 v78 v70 v11. P (v77 meet v78 quoting v70 says v11)) ∧
     (∀v79 v80 v70 v11. P ((v79 quoting v80) quoting v70 says v11)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val inputOKr2_primitive_def =
   |- inputOKr2 =
   WFREC (@R. WF R)
     (λinputOKr2 a.
        case a of
          TT => I F
        | FF => I F
        | prop v33 => I F
        | notf v34 => I F
        | v35 andf v36 => I F
        | v37 orf v38 => I F
        | v39 impf v40 => I F
        | v41 eqf v42 => I F
        | Name v71 says v44 => I F
        | v72 meet v73 says v44 => I F
        | Name (Staff v92) quoting v75 says v44 => I F
        | Name (Authority v93) quoting v75 says v44 => I F
        | Name (Role v94) quoting v75 says v44 => I F
        | Name (KeyS (pubK v100)) quoting Name (Staff v118) says v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Authority v119) says
          v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says TT =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says FF =>
            I F
        | Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I T
        | Name (KeyS (pubK Bob)) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS (pubK Carol)) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS (pubK Alice)) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I T
        | Name (KeyS (pubK Carol)) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          prop NONE =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          notf v158 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          (v159 andf v160) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          (v161 orf v162) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          (v163 impf v164) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          (v165 eqf v166) =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v167 says v168 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v169 speaks_for v170 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v171 controls v172 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          reps v173 v174 v175 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v176 domi v177 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v178 eqi
          v179 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says
          v180 doms v181 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v182 eqs
          v183 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v184 eqn
          v185 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v186 lte
          v187 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Role v120) says v188 lt
          v189 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (KeyS v121) says v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (KeyA v122) says v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting Name (Machine v123) says
          v44 =>
            I F
        | Name (KeyS (pubK v100)) quoting v108 meet v109 says v44 => I F
        | Name (KeyS (pubK v100)) quoting v110 quoting v111 says v44 =>
            I F
        | Name (KeyS (privK v101)) quoting v75 says v44 => I F
        | Name (KeyA v96) quoting v75 says v44 => I F
        | Name (Machine v97) quoting v75 says v44 => I F
        | v82 meet v83 quoting v75 says v44 => I F
        | (v84 quoting v85) quoting v75 says v44 => I F
        | v45 speaks_for v46 => I F
        | v47 controls v48 => I F
        | reps v49 v50 v51 => I F
        | v52 domi v53 => I F
        | v54 eqi v55 => I F
        | v56 doms v57 => I F
        | v58 eqs v59 => I F
        | v60 eqn v61 => I F
        | v62 lte v63 => I F
        | v64 lt v65 => I F):
   thm
val mapSM0_Bob_Operator_privcmd_lemma =
   |- CFGInterpret (M,Oi,Os)
     (CFG inputOKr1 SM0StateInterp (certsr1 npriv privcmd)
        (mapSM0inputOperatorBob
           (Name (Role Operator) says prop (SOME (PR privcmd)))::ins) s
        outs) ⇒
   (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val mapSM0inputOperatorBob_def =
   |- (mapSM0inputOperatorBob (Name (Role Operator) says prop (SOME cmd)) =
    Name (Staff Bob) quoting Name (Role Operator) says
    prop (SOME cmd)) ∧
   (mapSM0inputOperatorBob
      (Name (Role Commander) says prop (SOME cmd)) =
    Name (Staff Alice) quoting Name (Role Commander) says
    prop (SOME cmd)) ∧ (mapSM0inputOperatorBob TT = TT) ∧
   (mapSM0inputOperatorBob FF = TT) ∧
   (mapSM0inputOperatorBob (prop v) = TT) ∧
   (mapSM0inputOperatorBob (notf v1) = TT) ∧
   (mapSM0inputOperatorBob (v2 andf v3) = TT) ∧
   (mapSM0inputOperatorBob (v4 orf v5) = TT) ∧
   (mapSM0inputOperatorBob (v6 impf v7) = TT) ∧
   (mapSM0inputOperatorBob (v8 eqf v9) = TT) ∧
   (mapSM0inputOperatorBob (v10 says TT) = TT) ∧
   (mapSM0inputOperatorBob (v10 says FF) = TT) ∧
   (mapSM0inputOperatorBob (Name (Staff v144) says prop (SOME v142)) =
    TT) ∧
   (mapSM0inputOperatorBob
      (Name (Authority v145) says prop (SOME v142)) =
    TT) ∧
   (mapSM0inputOperatorBob (Name (KeyS v147) says prop (SOME v142)) =
    TT) ∧
   (mapSM0inputOperatorBob (Name (KeyA v148) says prop (SOME v142)) =
    TT) ∧
   (mapSM0inputOperatorBob (Name (Machine v149) says prop (SOME v142)) =
    TT) ∧ (mapSM0inputOperatorBob (Name v132 says prop NONE) = TT) ∧
   (mapSM0inputOperatorBob (v133 meet v134 says prop v66) = TT) ∧
   (mapSM0inputOperatorBob (v135 quoting v136 says prop v66) = TT) ∧
   (mapSM0inputOperatorBob (v10 says notf v67) = TT) ∧
   (mapSM0inputOperatorBob (v10 says (v68 andf v69)) = TT) ∧
   (mapSM0inputOperatorBob (v10 says (v70 orf v71)) = TT) ∧
   (mapSM0inputOperatorBob (v10 says (v72 impf v73)) = TT) ∧
   (mapSM0inputOperatorBob (v10 says (v74 eqf v75)) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v76 says v77) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v78 speaks_for v79) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v80 controls v81) = TT) ∧
   (mapSM0inputOperatorBob (v10 says reps v82 v83 v84) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v85 domi v86) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v87 eqi v88) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v89 doms v90) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v91 eqs v92) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v93 eqn v94) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v95 lte v96) = TT) ∧
   (mapSM0inputOperatorBob (v10 says v97 lt v98) = TT) ∧
   (mapSM0inputOperatorBob (v12 speaks_for v13) = TT) ∧
   (mapSM0inputOperatorBob (v14 controls v15) = TT) ∧
   (mapSM0inputOperatorBob (reps v16 v17 v18) = TT) ∧
   (mapSM0inputOperatorBob (v19 domi v20) = TT) ∧
   (mapSM0inputOperatorBob (v21 eqi v22) = TT) ∧
   (mapSM0inputOperatorBob (v23 doms v24) = TT) ∧
   (mapSM0inputOperatorBob (v25 eqs v26) = TT) ∧
   (mapSM0inputOperatorBob (v27 eqn v28) = TT) ∧
   (mapSM0inputOperatorBob (v29 lte v30) = TT) ∧
   (mapSM0inputOperatorBob (v31 lt v32) = TT):
   thm
val mapSM0inputOperatorBob_ind =
   |- ∀P.
     (∀cmd. P (Name (Role Operator) says prop (SOME cmd))) ∧
     (∀cmd. P (Name (Role Commander) says prop (SOME cmd))) ∧ P TT ∧
     P FF ∧ (∀v. P (prop v)) ∧ (∀v1. P (notf v1)) ∧
     (∀v2 v3. P (v2 andf v3)) ∧ (∀v4 v5. P (v4 orf v5)) ∧
     (∀v6 v7. P (v6 impf v7)) ∧ (∀v8 v9. P (v8 eqf v9)) ∧
     (∀v10. P (v10 says TT)) ∧ (∀v10. P (v10 says FF)) ∧
     (∀v144 v142. P (Name (Staff v144) says prop (SOME v142))) ∧
     (∀v145 v142. P (Name (Authority v145) says prop (SOME v142))) ∧
     (∀v147 v142. P (Name (KeyS v147) says prop (SOME v142))) ∧
     (∀v148 v142. P (Name (KeyA v148) says prop (SOME v142))) ∧
     (∀v149 v142. P (Name (Machine v149) says prop (SOME v142))) ∧
     (∀v132. P (Name v132 says prop NONE)) ∧
     (∀v133 v134 v66. P (v133 meet v134 says prop v66)) ∧
     (∀v135 v136 v66. P (v135 quoting v136 says prop v66)) ∧
     (∀v10 v67. P (v10 says notf v67)) ∧
     (∀v10 v68 v69. P (v10 says (v68 andf v69))) ∧
     (∀v10 v70 v71. P (v10 says (v70 orf v71))) ∧
     (∀v10 v72 v73. P (v10 says (v72 impf v73))) ∧
     (∀v10 v74 v75. P (v10 says (v74 eqf v75))) ∧
     (∀v10 v76 v77. P (v10 says v76 says v77)) ∧
     (∀v10 v78 v79. P (v10 says v78 speaks_for v79)) ∧
     (∀v10 v80 v81. P (v10 says v80 controls v81)) ∧
     (∀v10 v82 v83 v84. P (v10 says reps v82 v83 v84)) ∧
     (∀v10 v85 v86. P (v10 says v85 domi v86)) ∧
     (∀v10 v87 v88. P (v10 says v87 eqi v88)) ∧
     (∀v10 v89 v90. P (v10 says v89 doms v90)) ∧
     (∀v10 v91 v92. P (v10 says v91 eqs v92)) ∧
     (∀v10 v93 v94. P (v10 says v93 eqn v94)) ∧
     (∀v10 v95 v96. P (v10 says v95 lte v96)) ∧
     (∀v10 v97 v98. P (v10 says v97 lt v98)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val mapSM0inputOperatorBob_primitive_def =
   |- mapSM0inputOperatorBob =
   WFREC (@R. WF R)
     (λmapSM0inputOperatorBob a.
        case a of
          TT => I TT
        | FF => I TT
        | prop v33 => I TT
        | notf v34 => I TT
        | v35 andf v36 => I TT
        | v37 orf v38 => I TT
        | v39 impf v40 => I TT
        | v41 eqf v42 => I TT
        | v43 says TT => I TT
        | v43 says FF => I TT
        | Name (Staff v150) says prop (SOME cmd) => I TT
        | Name (Authority v151) says prop (SOME cmd) => I TT
        | Name (Role Commander) says prop (SOME cmd) =>
            I
              (Name (Staff Alice) quoting Name (Role Commander) says
               prop (SOME cmd))
        | Name (Role Operator) says prop (SOME cmd) =>
            I
              (Name (Staff Bob) quoting Name (Role Operator) says
               prop (SOME cmd))
        | Name (KeyS v153) says prop (SOME cmd) => I TT
        | Name (KeyA v154) says prop (SOME cmd) => I TT
        | Name (Machine v155) says prop (SOME cmd) => I TT
        | Name v137 says prop NONE => I TT
        | v138 meet v139 says prop v99 => I TT
        | v140 quoting v141 says prop v99 => I TT
        | v43 says notf v100 => I TT
        | v43 says (v101 andf v102) => I TT
        | v43 says (v103 orf v104) => I TT
        | v43 says (v105 impf v106) => I TT
        | v43 says (v107 eqf v108) => I TT
        | v43 says v109 says v110 => I TT
        | v43 says v111 speaks_for v112 => I TT
        | v43 says v113 controls v114 => I TT
        | v43 says reps v115 v116 v117 => I TT
        | v43 says v118 domi v119 => I TT
        | v43 says v120 eqi v121 => I TT
        | v43 says v122 doms v123 => I TT
        | v43 says v124 eqs v125 => I TT
        | v43 says v126 eqn v127 => I TT
        | v43 says v128 lte v129 => I TT
        | v43 says v130 lt v131 => I TT
        | v45 speaks_for v46 => I TT
        | v47 controls v48 => I TT
        | reps v49 v50 v51 => I TT
        | v52 domi v53 => I TT
        | v54 eqi v55 => I TT
        | v56 doms v57 => I TT
        | v58 eqs v59 => I TT
        | v60 eqn v61 => I TT
        | v62 lte v63 => I TT
        | v64 lt v65 => I TT):
   thm
val mapSM0r1_Bob_Operator_privcmd_lemma =
   |- CFGInterpret (M,Oi,Os)
     (CFG inputOKr2 SM0StateInterp (certsr2 npriv privcmd)
        (mapSM0r1input
           (mapSM0inputOperatorBob
              (Name (Role Operator) says prop (SOME (PR privcmd))))::
             ins) s outs) ⇒
   (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val mapSM0r1input_def =
   |- (mapSM0r1input
      (Name (Staff Bob) quoting Name (Role Operator) says
       prop (SOME cmd)) =
    Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
    prop (SOME cmd)) ∧
   (mapSM0r1input
      (Name (Staff Alice) quoting Name (Role Commander) says
       prop (SOME cmd)) =
    Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
    prop (SOME cmd)) ∧ (mapSM0r1input TT = TT) ∧
   (mapSM0r1input FF = TT) ∧ (mapSM0r1input (prop v) = TT) ∧
   (mapSM0r1input (notf v1) = TT) ∧ (mapSM0r1input (v2 andf v3) = TT) ∧
   (mapSM0r1input (v4 orf v5) = TT) ∧
   (mapSM0r1input (v6 impf v7) = TT) ∧
   (mapSM0r1input (v8 eqf v9) = TT) ∧
   (mapSM0r1input (v10 says TT) = TT) ∧
   (mapSM0r1input (v10 says FF) = TT) ∧
   (mapSM0r1input (Name v132 says prop v66) = TT) ∧
   (mapSM0r1input (v133 meet v134 says prop v66) = TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (Staff v164) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (Authority v165) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Staff Bob) quoting Name (Role Commander) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Staff Carol) quoting Name (Role Commander) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Staff Alice) quoting Name (Role Operator) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Staff Carol) quoting Name (Role Operator) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Authority v177) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Role v178) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (KeyS v179) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (KeyA v180) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name (Machine v181) quoting Name (Role v166) says
       prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (KeyS v167) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (KeyA v168) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (Name v154 quoting Name (Machine v169) says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (v155 meet v156 quoting Name v144 says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      ((v157 quoting v158) quoting Name v144 says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input (v135 quoting v145 meet v146 says prop (SOME v142)) =
    TT) ∧
   (mapSM0r1input
      (v135 quoting v147 quoting v148 says prop (SOME v142)) =
    TT) ∧ (mapSM0r1input (v135 quoting v136 says prop NONE) = TT) ∧
   (mapSM0r1input (v10 says notf v67) = TT) ∧
   (mapSM0r1input (v10 says (v68 andf v69)) = TT) ∧
   (mapSM0r1input (v10 says (v70 orf v71)) = TT) ∧
   (mapSM0r1input (v10 says (v72 impf v73)) = TT) ∧
   (mapSM0r1input (v10 says (v74 eqf v75)) = TT) ∧
   (mapSM0r1input (v10 says v76 says v77) = TT) ∧
   (mapSM0r1input (v10 says v78 speaks_for v79) = TT) ∧
   (mapSM0r1input (v10 says v80 controls v81) = TT) ∧
   (mapSM0r1input (v10 says reps v82 v83 v84) = TT) ∧
   (mapSM0r1input (v10 says v85 domi v86) = TT) ∧
   (mapSM0r1input (v10 says v87 eqi v88) = TT) ∧
   (mapSM0r1input (v10 says v89 doms v90) = TT) ∧
   (mapSM0r1input (v10 says v91 eqs v92) = TT) ∧
   (mapSM0r1input (v10 says v93 eqn v94) = TT) ∧
   (mapSM0r1input (v10 says v95 lte v96) = TT) ∧
   (mapSM0r1input (v10 says v97 lt v98) = TT) ∧
   (mapSM0r1input (v12 speaks_for v13) = TT) ∧
   (mapSM0r1input (v14 controls v15) = TT) ∧
   (mapSM0r1input (reps v16 v17 v18) = TT) ∧
   (mapSM0r1input (v19 domi v20) = TT) ∧
   (mapSM0r1input (v21 eqi v22) = TT) ∧
   (mapSM0r1input (v23 doms v24) = TT) ∧
   (mapSM0r1input (v25 eqs v26) = TT) ∧
   (mapSM0r1input (v27 eqn v28) = TT) ∧
   (mapSM0r1input (v29 lte v30) = TT) ∧
   (mapSM0r1input (v31 lt v32) = TT):
   thm
val mapSM0r1input_ind =
   |- ∀P.
     (∀cmd.
        P
          (Name (Staff Bob) quoting Name (Role Operator) says
           prop (SOME cmd))) ∧
     (∀cmd.
        P
          (Name (Staff Alice) quoting Name (Role Commander) says
           prop (SOME cmd))) ∧ P TT ∧ P FF ∧ (∀v. P (prop v)) ∧
     (∀v1. P (notf v1)) ∧ (∀v2 v3. P (v2 andf v3)) ∧
     (∀v4 v5. P (v4 orf v5)) ∧ (∀v6 v7. P (v6 impf v7)) ∧
     (∀v8 v9. P (v8 eqf v9)) ∧ (∀v10. P (v10 says TT)) ∧
     (∀v10. P (v10 says FF)) ∧
     (∀v132 v66. P (Name v132 says prop v66)) ∧
     (∀v133 v134 v66. P (v133 meet v134 says prop v66)) ∧
     (∀v154 v164 v142.
        P (Name v154 quoting Name (Staff v164) says prop (SOME v142))) ∧
     (∀v154 v165 v142.
        P
          (Name v154 quoting Name (Authority v165) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Bob) quoting Name (Role Commander) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Carol) quoting Name (Role Commander) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Alice) quoting Name (Role Operator) says
           prop (SOME v142))) ∧
     (∀v142.
        P
          (Name (Staff Carol) quoting Name (Role Operator) says
           prop (SOME v142))) ∧
     (∀v177 v166 v142.
        P
          (Name (Authority v177) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v178 v166 v142.
        P
          (Name (Role v178) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v179 v166 v142.
        P
          (Name (KeyS v179) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v180 v166 v142.
        P
          (Name (KeyA v180) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v181 v166 v142.
        P
          (Name (Machine v181) quoting Name (Role v166) says
           prop (SOME v142))) ∧
     (∀v154 v167 v142.
        P (Name v154 quoting Name (KeyS v167) says prop (SOME v142))) ∧
     (∀v154 v168 v142.
        P (Name v154 quoting Name (KeyA v168) says prop (SOME v142))) ∧
     (∀v154 v169 v142.
        P
          (Name v154 quoting Name (Machine v169) says
           prop (SOME v142))) ∧
     (∀v155 v156 v144 v142.
        P (v155 meet v156 quoting Name v144 says prop (SOME v142))) ∧
     (∀v157 v158 v144 v142.
        P
          ((v157 quoting v158) quoting Name v144 says
           prop (SOME v142))) ∧
     (∀v135 v145 v146 v142.
        P (v135 quoting v145 meet v146 says prop (SOME v142))) ∧
     (∀v135 v147 v148 v142.
        P (v135 quoting v147 quoting v148 says prop (SOME v142))) ∧
     (∀v135 v136. P (v135 quoting v136 says prop NONE)) ∧
     (∀v10 v67. P (v10 says notf v67)) ∧
     (∀v10 v68 v69. P (v10 says (v68 andf v69))) ∧
     (∀v10 v70 v71. P (v10 says (v70 orf v71))) ∧
     (∀v10 v72 v73. P (v10 says (v72 impf v73))) ∧
     (∀v10 v74 v75. P (v10 says (v74 eqf v75))) ∧
     (∀v10 v76 v77. P (v10 says v76 says v77)) ∧
     (∀v10 v78 v79. P (v10 says v78 speaks_for v79)) ∧
     (∀v10 v80 v81. P (v10 says v80 controls v81)) ∧
     (∀v10 v82 v83 v84. P (v10 says reps v82 v83 v84)) ∧
     (∀v10 v85 v86. P (v10 says v85 domi v86)) ∧
     (∀v10 v87 v88. P (v10 says v87 eqi v88)) ∧
     (∀v10 v89 v90. P (v10 says v89 doms v90)) ∧
     (∀v10 v91 v92. P (v10 says v91 eqs v92)) ∧
     (∀v10 v93 v94. P (v10 says v93 eqn v94)) ∧
     (∀v10 v95 v96. P (v10 says v95 lte v96)) ∧
     (∀v10 v97 v98. P (v10 says v97 lt v98)) ∧
     (∀v12 v13. P (v12 speaks_for v13)) ∧
     (∀v14 v15. P (v14 controls v15)) ∧
     (∀v16 v17 v18. P (reps v16 v17 v18)) ∧
     (∀v19 v20. P (v19 domi v20)) ∧ (∀v21 v22. P (v21 eqi v22)) ∧
     (∀v23 v24. P (v23 doms v24)) ∧ (∀v25 v26. P (v25 eqs v26)) ∧
     (∀v27 v28. P (v27 eqn v28)) ∧ (∀v29 v30. P (v29 lte v30)) ∧
     (∀v31 v32. P (v31 lt v32)) ⇒
     ∀v. P v:
   thm
val mapSM0r1input_primitive_def =
   |- mapSM0r1input =
   WFREC (@R. WF R)
     (λmapSM0r1input a.
        case a of
          TT => I TT
        | FF => I TT
        | prop v33 => I TT
        | notf v34 => I TT
        | v35 andf v36 => I TT
        | v37 orf v38 => I TT
        | v39 impf v40 => I TT
        | v41 eqf v42 => I TT
        | v43 says TT => I TT
        | v43 says FF => I TT
        | Name v137 says prop v99 => I TT
        | v138 meet v139 says prop v99 => I TT
        | Name v159 quoting Name (Staff v170) says prop (SOME cmd) =>
            I TT
        | Name v159 quoting Name (Authority v171) says
          prop (SOME cmd) =>
            I TT
        | Name (Staff Alice) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I
              (Name (KeyS (pubK Alice)) quoting
               Name (Role Commander) says prop (SOME cmd))
        | Name (Staff Bob) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I TT
        | Name (Staff Carol) quoting Name (Role Commander) says
          prop (SOME cmd) =>
            I TT
        | Name (Staff Alice) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I TT
        | Name (Staff Bob) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I
              (Name (KeyS (pubK Bob)) quoting Name (Role Operator) says
               prop (SOME cmd))
        | Name (Staff Carol) quoting Name (Role Operator) says
          prop (SOME cmd) =>
            I TT
        | Name (Authority v183) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name (Role v184) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name (KeyS v185) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name (KeyA v186) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name (Machine v187) quoting Name (Role v172) says
          prop (SOME cmd) =>
            I TT
        | Name v159 quoting Name (KeyS v173) says prop (SOME cmd) =>
            I TT
        | Name v159 quoting Name (KeyA v174) says prop (SOME cmd) =>
            I TT
        | Name v159 quoting Name (Machine v175) says prop (SOME cmd) =>
            I TT
        | v160 meet v161 quoting Name v149 says prop (SOME cmd) => I TT
        | (v162 quoting v163) quoting Name v149 says prop (SOME cmd) =>
            I TT
        | v140 quoting v150 meet v151 says prop (SOME cmd) => I TT
        | v140 quoting v152 quoting v153 says prop (SOME cmd) => I TT
        | v140 quoting v141 says prop NONE => I TT
        | v43 says notf v100 => I TT
        | v43 says (v101 andf v102) => I TT
        | v43 says (v103 orf v104) => I TT
        | v43 says (v105 impf v106) => I TT
        | v43 says (v107 eqf v108) => I TT
        | v43 says v109 says v110 => I TT
        | v43 says v111 speaks_for v112 => I TT
        | v43 says v113 controls v114 => I TT
        | v43 says reps v115 v116 v117 => I TT
        | v43 says v118 domi v119 => I TT
        | v43 says v120 eqi v121 => I TT
        | v43 says v122 doms v123 => I TT
        | v43 says v124 eqs v125 => I TT
        | v43 says v126 eqn v127 => I TT
        | v43 says v128 lte v129 => I TT
        | v43 says v130 lt v131 => I TT
        | v45 speaks_for v46 => I TT
        | v47 controls v48 => I TT
        | reps v49 v50 v51 => I TT
        | v52 domi v53 => I TT
        | v54 eqi v55 => I TT
        | v56 doms v57 => I TT
        | v58 eqs v59 => I TT
        | v60 eqn v61 => I TT
        | v62 lte v63 => I TT
        | v64 lt v65 => I TT):
   thm
val mkinMsg_SM0r2_Bob_Operator_privcmd_lemma =
   |- CFG2Interpret (M,Oi,Os)
     (CFG2 MsgInterpret certificateInterpret inputOKr2
        (certificatesr3 npriv privcmd) SM0StateInterp
        (mkinMsg
           (mapSM0r1input
              (mapSM0inputOperatorBob
                 (Name (Role Operator) says
                  prop (SOME (PR privcmd)))))::ins) s outs) ⇒
   (M,Oi,Os) sat prop (SOME (PR privcmd)):
   thm
val num2role_11 =
   |- ∀r r'. r < 2 ⇒ r' < 2 ⇒ ((num2role r = num2role r') ⇔ (r = r')):
   thm
val num2role_ONTO =
   |- ∀a. ∃r. (a = num2role r) ∧ r < 2:
   thm
val num2role_role2num =
   |- ∀a. num2role (role2num a) = a:
   thm
val num2role_thm =
   |- (num2role 0 = Commander) ∧ (num2role 1 = Operator):
   thm
val num2staff_11 =
   |- ∀r r'. r < 3 ⇒ r' < 3 ⇒ ((num2staff r = num2staff r') ⇔ (r = r')):
   thm
val num2staff_ONTO =
   |- ∀a. ∃r. (a = num2staff r) ∧ r < 3:
   thm
val num2staff_staff2num =
   |- ∀a. num2staff (staff2num a) = a:
   thm
val num2staff_thm =
   |- (num2staff 0 = Alice) ∧ (num2staff 1 = Bob) ∧ (num2staff 2 = Carol):
   thm
val principal_11 =
   |- (∀a a'. (Staff a = Staff a') ⇔ (a = a')) ∧
   (∀a a'. (Authority a = Authority a') ⇔ (a = a')) ∧
   (∀a a'. (Role a = Role a') ⇔ (a = a')) ∧
   (∀a a'. (KeyS a = KeyS a') ⇔ (a = a')) ∧
   (∀a a'. (KeyA a = KeyA a') ⇔ (a = a')) ∧
   ∀a a'. (Machine a = Machine a') ⇔ (a = a'):
   thm
val principal_Axiom =
   |- ∀f0 f1 f2 f3 f4 f5.
     ∃fn.
       (∀a. fn (Staff a) = f0 a) ∧ (∀a. fn (Authority a) = f1 a) ∧
       (∀a. fn (Role a) = f2 a) ∧ (∀a. fn (KeyS a) = f3 a) ∧
       (∀a. fn (KeyA a) = f4 a) ∧ ∀a. fn (Machine a) = f5 a:
   thm
val principal_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0.
          ∀'principal' .
            (∀a0.
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR 0 (a,ARB,ARB,ARB,ARB,ARB)
                       (λn. ind_type$BOTTOM)) a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC 0) (ARB,a,ARB,ARB,ARB,ARB)
                       (λn. ind_type$BOTTOM)) a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC 0))
                       (ARB,ARB,a,ARB,ARB,ARB) (λn. ind_type$BOTTOM))
                    a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC (SUC 0)))
                       (ARB,ARB,ARB,a,ARB,ARB) (λn. ind_type$BOTTOM))
                    a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC (SUC (SUC 0))))
                       (ARB,ARB,ARB,ARB,a,ARB) (λn. ind_type$BOTTOM))
                    a) ∨
               (∃a.
                  a0 =
                  (λa.
                     ind_type$CONSTR (SUC (SUC (SUC (SUC (SUC 0)))))
                       (ARB,ARB,ARB,ARB,ARB,a) (λn. ind_type$BOTTOM))
                    a) ⇒
               'principal' a0) ⇒
            'principal' a0) rep:
   thm
val principal_case_cong =
   |- ∀M M' f f1 f2 f3 f4 f5.
     (M = M') ∧ (∀a. (M' = Staff a) ⇒ (f a = f' a)) ∧
     (∀a. (M' = Authority a) ⇒ (f1 a = f1' a)) ∧
     (∀a. (M' = Role a) ⇒ (f2 a = f2' a)) ∧
     (∀a. (M' = KeyS a) ⇒ (f3 a = f3' a)) ∧
     (∀a. (M' = KeyA a) ⇒ (f4 a = f4' a)) ∧
     (∀a. (M' = Machine a) ⇒ (f5 a = f5' a)) ⇒
     (principal_CASE M f f1 f2 f3 f4 f5 =
      principal_CASE M' f' f1' f2' f3' f4' f5'):
   thm
val principal_case_def =
   |- (∀a f f1 f2 f3 f4 f5.
      principal_CASE (Staff a) f f1 f2 f3 f4 f5 = f a) ∧
   (∀a f f1 f2 f3 f4 f5.
      principal_CASE (Authority a) f f1 f2 f3 f4 f5 = f1 a) ∧
   (∀a f f1 f2 f3 f4 f5.
      principal_CASE (Role a) f f1 f2 f3 f4 f5 = f2 a) ∧
   (∀a f f1 f2 f3 f4 f5.
      principal_CASE (KeyS a) f f1 f2 f3 f4 f5 = f3 a) ∧
   (∀a f f1 f2 f3 f4 f5.
      principal_CASE (KeyA a) f f1 f2 f3 f4 f5 = f4 a) ∧
   ∀a f f1 f2 f3 f4 f5.
     principal_CASE (Machine a) f f1 f2 f3 f4 f5 = f5 a:
   thm
val principal_distinct =
   |- (∀a' a. Staff a ≠ Authority a') ∧ (∀a' a. Staff a ≠ Role a') ∧
   (∀a' a. Staff a ≠ KeyS a') ∧ (∀a' a. Staff a ≠ KeyA a') ∧
   (∀a' a. Staff a ≠ Machine a') ∧ (∀a' a. Authority a ≠ Role a') ∧
   (∀a' a. Authority a ≠ KeyS a') ∧ (∀a' a. Authority a ≠ KeyA a') ∧
   (∀a' a. Authority a ≠ Machine a') ∧ (∀a' a. Role a ≠ KeyS a') ∧
   (∀a' a. Role a ≠ KeyA a') ∧ (∀a' a. Role a ≠ Machine a') ∧
   (∀a' a. KeyS a ≠ KeyA a') ∧ (∀a' a. KeyS a ≠ Machine a') ∧
   ∀a' a. KeyA a ≠ Machine a':
   thm
val principal_distinct_clauses =
   |- (∀a' a. Staff a ≠ Authority a') ∧ (∀a' a. Staff a ≠ Role a') ∧
   (∀a' a. Staff a ≠ KeyS a') ∧ (∀a' a. Staff a ≠ KeyA a') ∧
   (∀a' a. Staff a ≠ Machine a') ∧ (∀a' a. Authority a ≠ Role a') ∧
   (∀a' a. Authority a ≠ KeyS a') ∧ (∀a' a. Authority a ≠ KeyA a') ∧
   (∀a' a. Authority a ≠ Machine a') ∧ (∀a' a. Role a ≠ KeyS a') ∧
   (∀a' a. Role a ≠ KeyA a') ∧ (∀a' a. Role a ≠ Machine a') ∧
   (∀a' a. KeyS a ≠ KeyA a') ∧ (∀a' a. KeyS a ≠ Machine a') ∧
   ∀a' a. KeyA a ≠ Machine a':
   thm
val principal_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY)asymMsg | authority | bool | TY digest |
                  (TY, TY)fun | ind | TY itself | TY list | num | one |
                  TY option | TY pKey | principal | (TY, TY)prod |
                  TY recspace | role | TY set | staff | (TY, TY)sum |
                  symKey | TY symMsg | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a pKey = α cipher$pKey                               
  principal = principal$principal                        
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CHOICE COMM COMPL COND CONS
  COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander Cong DATATYPE
  DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL EMPTY
  EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea Es F
  FACT FAIL FCOMM FILTER FIND FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR
  FOLDRi FRONT FST FUNPOW FUNSET GENLIST GENLIST_AUX GSPEC GUESS_EXISTS
  GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP
  GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF
  INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT
  INTER INVOL ISL ISR IS_EL IS_NONE IS_NUM_REP IS_PREFIX
  IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST
  IS_SUFFIX IS_SUM_REP ITSET Id IfCases K KeyA KeyS LAST LASTN LEAST
  LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND
  LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi
  LIST_TO_SET LLEX LRC LUPDATE LinearOrder MAP MAP2 MAPi MAPi_ACC MAX
  MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID Machine NIL NONE NOTIN NRC
  NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND O ODD OLEAST ONE_ONE ONTO
  OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE OPTION_GUARD
  OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2 OPTION_MCOMP
  OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Operator Order PAD_LEFT
  PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED
  PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW
  PMATCH_ROW_COND PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ
  PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0
  PMATCH_ROW_magic_1 PMATCH_ROW_magic_2 PMATCH_ROW_magic_3
  PMATCH_ROW_magic_4 PMATCH_magic_1 POW PRE PREFIX PREIMAGE PRIM_REC
  PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder RC RCOMPL
  RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ
  RELPOW REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST
  RESTRICT RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL
  RES_SELECT REV REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT
  RSUBSET RTC RUNION RUNIV Role S SC SCANL SCANR SEG SET_TO_LIST SIGMA
  SIMPLE_GUESS_EXISTS SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING
  SINGL SN SND SNOC SOME SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP Staff StrongLinearOrder StrongOrder T TAKE TC THE TL TL_T
  TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
  UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder WeakOrder
  ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number antisymmetric approx
  asymMsg_CASE asymMsg_size authority_CASE authority_size bool_size ca
  case chooser count countable deciphP deciphS delN dest_rec diag
  diamond digest_CASE digest_size dropWhile enumerate equiv_on
  equivalence findi findq fupdLast hash iBIT_cases internal_mult inv
  inv_image invtri invtri0 irreflexive isPREFIX itself_case lift2
  listRel list_CASE list_size literal_case measure mk_rec napp
  nat_elim__magic ncons nf nfoldl nfst nlen nlistrec nmap nnil npair
  nsnd nub num2role num2staff num_CASE num_to_pair o one one_CASE
  one_size option_ABS option_CASE option_REP option_size pKey_CASE
  pKey_size pair_CASE pair_size pair_to_num pairwise partition
  principal_CASE principal_size privK pubK rcdiamond reflexive role2num
  role_CASE role_size schroeder_close set sign signVerify some
  splitAtPki staff2num staff_CASE staff_size stmarker sum_CASE sum_size
  sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric the_fun
  the_value total transitive tri trichotomous tri⁻¹ unint univ
  wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    principal_CASE staff_CASE role_CASE authority_CASE digest_CASE
    asymMsg_CASE pKey_CASE symMsg_CASE symKey_CASE list_CASE option_CASE
    sum_CASE num_CASE pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val principal_induction =
   |- ∀P.
     (∀s. P (Staff s)) ∧ (∀a. P (Authority a)) ∧ (∀r. P (Role r)) ∧
     (∀p. P (KeyS p)) ∧ (∀p. P (KeyA p)) ∧ (∀n. P (Machine n)) ⇒
     ∀p. P p:
   thm
val principal_nchotomy =
   |- ∀pp.
     (∃s. pp = Staff s) ∨ (∃a. pp = Authority a) ∨ (∃r. pp = Role r) ∨
     (∃p. pp = KeyS p) ∨ (∃p. pp = KeyA p) ∨ ∃n. pp = Machine n:
   thm
val principal_one_one =
   |- (∀a a'. (Staff a = Staff a') ⇔ (a = a')) ∧
   (∀a a'. (Authority a = Authority a') ⇔ (a = a')) ∧
   (∀a a'. (Role a = Role a') ⇔ (a = a')) ∧
   (∀a a'. (KeyS a = KeyS a') ⇔ (a = a')) ∧
   (∀a a'. (KeyA a = KeyA a') ⇔ (a = a')) ∧
   ∀a a'. (Machine a = Machine a') ⇔ (a = a'):
   thm
val principal_size_def =
   |- (∀a. principal_size (Staff a) = 1 + staff_size a) ∧
   (∀a. principal_size (Authority a) = 1 + authority_size a) ∧
   (∀a. principal_size (Role a) = 1 + role_size a) ∧
   (∀a. principal_size (KeyS a) = 1 + pKey_size staff_size a) ∧
   (∀a. principal_size (KeyA a) = 1 + pKey_size authority_size a) ∧
   ∀a. principal_size (Machine a) = 1 + a:
   thm
val role2num_11 =
   |- ∀a a'. (role2num a = role2num a') ⇔ (a = a'):
   thm
val role2num_ONTO =
   |- ∀r. r < 2 ⇔ ∃a. r = role2num a:
   thm
val role2num_num2role =
   |- ∀r. r < 2 ⇔ (role2num (num2role r) = r):
   thm
val role2num_thm =
   |- (role2num Commander = 0) ∧ (role2num Operator = 1):
   thm
val role_Axiom =
   |- ∀x0 x1. ∃f. (f Commander = x0) ∧ (f Operator = x1):
   thm
val role_BIJ =
   |- (∀a. num2role (role2num a) = a) ∧
   ∀r. (λn. n < 2) r ⇔ (role2num (num2role r) = r):
   thm
val role_CASE =
   |- ∀x v0 v1.
     (case x of Commander => v0 | Operator => v1) =
     (λm. if m = 0 then v0 else v1) (role2num x):
   thm
val role_EQ_role =
   |- ∀a a'. (a = a') ⇔ (role2num a = role2num a'):
   thm
val role_TY_DEF =
   |- ∃rep. TYPE_DEFINITION (λn. n < 2) rep:
   thm
val role_case_cong =
   |- ∀M M' v0 v1.
     (M = M') ∧ ((M' = Commander) ⇒ (v0 = v0')) ∧
     ((M' = Operator) ⇒ (v1 = v1')) ⇒
     ((case M of Commander => v0 | Operator => v1) =
      case M' of Commander => v0' | Operator => v1'):
   thm
val role_case_def =
   |- (∀v0 v1. (case Commander of Commander => v0 | Operator => v1) = v0) ∧
   ∀v0 v1. (case Operator of Commander => v0 | Operator => v1) = v1:
   thm
val role_distinct =
   |- Commander ≠ Operator:
   thm
val role_distinct_clauses =
   |- Commander ≠ Operator:
   thm
val role_induction =
   |- ∀P. P Commander ∧ P Operator ⇒ ∀a. P a:
   thm
val role_nchotomy =
   |- ∀a. (a = Commander) ∨ (a = Operator):
   thm
val role_size_def =
   |- ∀x. role_size x = 0:
   thm
val staff2num_11 =
   |- ∀a a'. (staff2num a = staff2num a') ⇔ (a = a'):
   thm
val staff2num_ONTO =
   |- ∀r. r < 3 ⇔ ∃a. r = staff2num a:
   thm
val staff2num_num2staff =
   |- ∀r. r < 3 ⇔ (staff2num (num2staff r) = r):
   thm
val staff2num_thm =
   |- (staff2num Alice = 0) ∧ (staff2num Bob = 1) ∧ (staff2num Carol = 2):
   thm
val staff_Axiom =
   |- ∀x0 x1 x2. ∃f. (f Alice = x0) ∧ (f Bob = x1) ∧ (f Carol = x2):
   thm
val staff_BIJ =
   |- (∀a. num2staff (staff2num a) = a) ∧
   ∀r. (λn. n < 3) r ⇔ (staff2num (num2staff r) = r):
   thm
val staff_CASE =
   |- ∀x v0 v1 v2.
     (case x of Alice => v0 | Bob => v1 | Carol => v2) =
     (λm. if m < 1 then v0 else if m = 1 then v1 else v2) (staff2num x):
   thm
val staff_EQ_staff =
   |- ∀a a'. (a = a') ⇔ (staff2num a = staff2num a'):
   thm
val staff_TY_DEF =
   |- ∃rep. TYPE_DEFINITION (λn. n < 3) rep:
   thm
val staff_case_cong =
   |- ∀M M' v0 v1 v2.
     (M = M') ∧ ((M' = Alice) ⇒ (v0 = v0')) ∧
     ((M' = Bob) ⇒ (v1 = v1')) ∧ ((M' = Carol) ⇒ (v2 = v2')) ⇒
     ((case M of Alice => v0 | Bob => v1 | Carol => v2) =
      case M' of Alice => v0' | Bob => v1' | Carol => v2'):
   thm
val staff_case_def =
   |- (∀v0 v1 v2.
      (case Alice of Alice => v0 | Bob => v1 | Carol => v2) = v0) ∧
   (∀v0 v1 v2.
      (case Bob of Alice => v0 | Bob => v1 | Carol => v2) = v1) ∧
   ∀v0 v1 v2. (case Carol of Alice => v0 | Bob => v1 | Carol => v2) = v2:
   thm
val staff_distinct =
   |- Alice ≠ Bob ∧ Alice ≠ Carol ∧ Bob ≠ Carol:
   thm
val staff_distinct_clauses =
   |- Alice ≠ Bob ∧ Alice ≠ Carol ∧ Bob ≠ Carol:
   thm
val staff_induction =
   |- ∀P. P Alice ∧ P Bob ∧ P Carol ⇒ ∀a. P a:
   thm
val staff_nchotomy =
   |- ∀a. (a = Alice) ∨ (a = Bob) ∨ (a = Carol):
   thm
val staff_size_def =
   |- ∀x. staff_size x = 0:
   thm
type thm
> val MAP_certificateInterpret_mkRCert_thm =
   |- ∀formList. MAP certificateInterpret (MAP mkRCert formList) = formList:
   thm
val MAP_certificateInterpret_mkSCert_thm =
   |- ∀formList auth.
     MAP certificateInterpret (MAP (mkSCert auth) formList) = formList:
   thm
val MsgInterpretOK =
   |- ∀staff role command.
     MsgInterpret
       (MSG staff (Order role command)
          (sign (privK staff) (hash (SOME (Order role command))))) =
     Name (KeyS (pubK staff)) quoting Name (Role role) says
     prop (SOME command):
   thm
val MsgInterpret_def =
   |- MsgInterpret (MSG staff (Order role command) signature) =
   if checkMsg (MSG staff (Order role command) signature) then
     Name (KeyS (pubK staff)) quoting Name (Role role) says
     prop (SOME command)
   else TT:
   thm
val MsgInterpret_ind =
   |- ∀P.
     (∀staff role command signature.
        P (MSG staff (Order role command) signature)) ⇒
     ∀v. P v:
   thm
val MsgInterpret_inverts_mkinMsg_thm =
   |- ∀staff role command.
     MsgInterpret
       (mkinMsg
          (Name (KeyS (pubK staff)) quoting Name (Role role) says
           prop (SOME command))) =
     Name (KeyS (pubK staff)) quoting Name (Role role) says
     prop (SOME command):
   thm
val MsgInterpret_primitive_def =
   |- MsgInterpret =
   WFREC (@R. WF R)
     (λMsgInterpret a.
        case a of
          MSG staff (Order role command) signature =>
            I
              (if
                 checkMsg (MSG staff (Order role command) signature)
               then
                 Name (KeyS (pubK staff)) quoting Name (Role role) says
                 prop (SOME command)
               else TT)):
   thm
val certStructure_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | (TY, TY)certificate | command |
                  (TY, TY, TY, TY, TY, TY)configuration | TY digest |
                  (TY, TY)fun | ind | TY inst | TY itself | TY list |
                  npriv | num | one | TY option | output | TY pKey |
                  TY po | principal | privcmd | (TY, TY)prod |
                  TY recspace | role | TY set | staff | state |
                  (TY, TY)sum | symKey | TY symMsg | TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  ('a, 'b) certificate = (α, β) certStructure$certificate
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFGInterpret CHOICE COMM COMPL
  COND CONS COUNT_LIST COUNT_LIST_AUX CR CROSS CURRY Carol Commander
  Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD DROP EL ELL
  EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP EXT_POINT Ea
  Efn Es F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT FOLDL
  FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS KeyA KeyS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  Machine NIL NONE NOTIN NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT
  NUMSND Name O O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY
  OPTION_BIND OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN
  OPTION_MAP OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR
  OWHILE Operator Order PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH
  PMATCH_EQUIV_ROWS PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN
  PMATCH_INCOMPLETE PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND
  PMATCH_ROW_COND_EX PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT
  PMATCH_ROW_REDUNDANT PMATCH_ROW_magic_0 PMATCH_ROW_magic_1
  PMATCH_ROW_magic_2 PMATCH_ROW_magic_3 PMATCH_ROW_magic_4
  PMATCH_magic_1 PO POW PR PRE PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN
  PROD_ALL PROD_IMAGE PROD_SET PSUBSET PreOrder Princ_CASE Princ_size RC
  RCOMPL RCert RDOM RDOM_DELETE REDUNDANT_ROWS_INFOS_CONJ
  REDUNDANT_ROWS_INFOS_DISJ RELPOW REL_RESTRICT REMPTY REPLICATE REP_num
  REP_prod REP_sum REST RESTRICT RES_ABSTRACT RES_EXISTS
  RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV REVERSE RIGHT_ID RINTER
  RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION RUNIV Role S SC SCANL
  SCANR SCert SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TT TYPE_DEFINITION UNCURRY UNION
  UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP WFREC
  WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ \\
  _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case certificateInterpret
  certificate_CASE certificate_size checkcert chooser command_CASE
  command_size configuration_CASE configuration_size controls count
  countable deciphP deciphS delN dest_rec diag diamond digest_CASE
  digest_size discard domi doms dropWhile enumerate eqf eqi eqn eqs
  equiv_on equivalence exec findi findq fupdLast hash iBIT_cases iLab il
  imapKS impf inst_CASE inst_size internal_mult intpKS inv inv_image
  invtri invtri0 irreflexive isPREFIX itself_case jKS launch lift2
  listRel list_CASE list_size literal_case lt lte measure meet mkRCert
  mkSCert mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen nlistrec
  nmap nnil notf npair npriv2num npriv_CASE npriv_size nsnd nub
  num2npriv num2output num2privcmd num2role num2staff num2state num_CASE
  num_to_pair o off on one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orf output2num output_CASE
  output_size pKey_CASE pKey_size pair_CASE pair_size pair_to_num
  pairwise partition principal_CASE principal_size privK privcmd2num
  privcmd_CASE privcmd_size prod_PO prop pubK quoting rcdiamond
  reflexive repPO reps reset role2num role_CASE role_size sLab sat
  satList says schroeder_close set sign signVerify sl smapKS some
  speaks_for splitAtPki staff2num staff_CASE staff_size state2num
  state_CASE state_size status stmarker sum_CASE sum_size sym
  symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric the_fun
  the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    certificate_CASE configuration_CASE trType_CASE inst_CASE
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    output_CASE state_CASE command_CASE npriv_CASE privcmd_CASE
    principal_CASE staff_CASE role_CASE authority_CASE digest_CASE
    asymMsg_CASE pKey_CASE symMsg_CASE symKey_CASE list_CASE option_CASE
    sum_CASE num_CASE pair_CASE itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val certificateInterpretRCert_thm =
   |- ∀formula. certificateInterpret (RCert formula) = formula:
   thm
val certificateInterpretSCert_thm =
   |- ∀formula auth.
     certificateInterpret
       (SCert (KeyA (pubK auth)) formula
          (sign (privK auth) (hash (SOME formula)))) =
     formula:
   thm
val certificateInterpret_def =
   |- (certificateInterpret (RCert formula) =
    if checkcert (RCert formula) then formula else TT) ∧
   (certificateInterpret (SCert (KeyA (pubK auth)) formula signature) =
    if checkcert (SCert (KeyA (pubK auth)) formula signature) then
      formula
    else TT):
   thm
val certificateInterpret_ind =
   |- ∀P.
     (∀formula. P (RCert formula)) ∧
     (∀auth formula signature.
        P (SCert (KeyA (pubK auth)) formula signature)) ∧
     (∀v5 v15 v16. P (SCert (Staff v5) v15 v16)) ∧
     (∀v7 v17 v18. P (SCert (Authority v7) v17 v18)) ∧
     (∀v9 v19 v20. P (SCert (Role v9) v19 v20)) ∧
     (∀v11 v21 v22. P (SCert (KeyS v11) v21 v22)) ∧
     (∀v25 v26 v27. P (SCert (KeyA (privK v25)) v26 v27)) ∧
     (∀v14 v28 v29. P (SCert (Machine v14) v28 v29)) ⇒
     ∀v. P v:
   thm
val certificateInterpret_mkRCert_thm =
   |- ∀formula. certificateInterpret (mkRCert formula) = formula:
   thm
val certificateInterpret_mkSCert_thm =
   |- ∀formula auth. certificateInterpret (mkSCert auth formula) = formula:
   thm
val certificateInterpret_primitive_def =
   |- certificateInterpret =
   WFREC (@R. WF R)
     (λcertificateInterpret a.
        case a of
          RCert formula =>
            I (if checkcert (RCert formula) then formula else TT)
        | SCert (Staff v4) formula' signature => ARB
        | SCert (Authority v6) formula' signature => ARB
        | SCert (Role v8) formula' signature => ARB
        | SCert (KeyS v10) formula' signature => ARB
        | SCert (KeyA (pubK auth)) formula' signature =>
            I
              (if
                 checkcert (SCert (KeyA (pubK auth)) formula' signature)
               then
                 formula'
               else TT)
        | SCert (KeyA (privK v24)) formula' signature => ARB
        | SCert (Machine v13) formula' signature => ARB):
   thm
val certificate_11 =
   |- (∀a a'. (RCert a = RCert a') ⇔ (a = a')) ∧
   ∀a0 a1 a2 a0' a1' a2'.
     (SCert a0 a1 a2 = SCert a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2'):
   thm
val certificate_Axiom =
   |- ∀f0 f1.
     ∃fn.
       (∀a. fn (RCert a) = f0 a) ∧
       ∀a0 a1 a2. fn (SCert a0 a1 a2) = f1 a0 a1 a2:
   thm
val certificate_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'certificate' .
            (∀a0'.
               (∃a.
                  a0' =
                  (λa.
                     ind_type$CONSTR 0 (a,ARB,ARB)
                       (λn. ind_type$BOTTOM)) a) ∨
               (∃a0 a1 a2.
                  a0' =
                  (λa0 a1 a2.
                     ind_type$CONSTR (SUC 0) (a1,a0,a2)
                       (λn. ind_type$BOTTOM)) a0 a1 a2) ⇒
               'certificate' a0') ⇒
            'certificate' a0') rep:
   thm
val certificate_case_cong =
   |- ∀M M' f f1.
     (M = M') ∧ (∀a. (M' = RCert a) ⇒ (f a = f' a)) ∧
     (∀a0 a1 a2. (M' = SCert a0 a1 a2) ⇒ (f1 a0 a1 a2 = f1' a0 a1 a2)) ⇒
     (certificate_CASE M f f1 = certificate_CASE M' f' f1'):
   thm
val certificate_case_def =
   |- (∀a f f1. certificate_CASE (RCert a) f f1 = f a) ∧
   ∀a0 a1 a2 f f1. certificate_CASE (SCert a0 a1 a2) f f1 = f1 a0 a1 a2:
   thm
val certificate_distinct =
   |- ∀a2 a1 a0 a. RCert a ≠ SCert a0 a1 a2:
   thm
val certificate_distinct_thm =
   |- ∀a2 a1 a0 a. RCert a ≠ SCert a0 a1 a2:
   thm
val certificate_induction =
   |- ∀P. (∀F. P (RCert F)) ∧ (∀p F a. P (SCert p F a)) ⇒ ∀c. P c:
   thm
val certificate_nchotomy =
   |- ∀cc. (∃F. cc = RCert F) ∨ ∃p F a. cc = SCert p F a:
   thm
val certificate_one_one =
   |- (∀a a'. (RCert a = RCert a') ⇔ (a = a')) ∧
   ∀a0 a1 a2 a0' a1' a2'.
     (SCert a0 a1 a2 = SCert a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2'):
   thm
val certificate_size_def =
   |- (∀f f1 a.
      certificate_size f f1 (RCert a) =
      1 + Form_size (inst_size command_size) principal_size f f1 a) ∧
   ∀f f1 a0 a1 a2.
     certificate_size f f1 (SCert a0 a1 a2) =
     1 +
     (principal_size a0 +
      (Form_size (inst_size command_size) principal_size f f1 a1 +
       asymMsg_size
         (digest_size
            (Form_size (inst_size command_size) principal_size f f1))
         authority_size a2)):
   thm
val checkMsgOK =
   |- checkMsg (MSG staff order (sign (privK staff) (hash (SOME order)))):
   thm
val checkMsg_def =
   |- ∀staff order signature.
     checkMsg (MSG staff order signature) ⇔
     signVerify (pubK staff) signature (SOME order):
   thm
val checkcert_def =
   |- (checkcert (RCert formula) ⇔ T) ∧
   (checkcert (SCert (KeyA (pubK auth)) formula signature) ⇔
    signVerify (pubK auth) signature (SOME formula)):
   thm
val checkcert_ind =
   |- ∀P.
     (∀formula. P (RCert formula)) ∧
     (∀auth formula signature.
        P (SCert (KeyA (pubK auth)) formula signature)) ∧
     (∀v5 v15 v16. P (SCert (Staff v5) v15 v16)) ∧
     (∀v7 v17 v18. P (SCert (Authority v7) v17 v18)) ∧
     (∀v9 v19 v20. P (SCert (Role v9) v19 v20)) ∧
     (∀v11 v21 v22. P (SCert (KeyS v11) v21 v22)) ∧
     (∀v25 v26 v27. P (SCert (KeyA (privK v25)) v26 v27)) ∧
     (∀v14 v28 v29. P (SCert (Machine v14) v28 v29)) ⇒
     ∀v. P v:
   thm
val checkcert_primitive_def =
   |- checkcert =
   WFREC (@R. WF R)
     (λcheckcert a.
        case a of
          RCert formula => I T
        | SCert (Staff v4) formula' signature => ARB
        | SCert (Authority v6) formula' signature => ARB
        | SCert (Role v8) formula' signature => ARB
        | SCert (KeyS v10) formula' signature => ARB
        | SCert (KeyA (pubK auth)) formula' signature =>
            I (signVerify (pubK auth) signature (SOME formula'))
        | SCert (KeyA (privK v24)) formula' signature => ARB
        | SCert (Machine v13) formula' signature => ARB):
   thm
val datatype_certificate =
   |- DATATYPE (certificate RCert SCert):
   thm
val datatype_inMsg =
   |- DATATYPE (inMsg MSG):
   thm
val datatype_order =
   |- DATATYPE (order Order):
   thm
val inMsg_11 =
   |- ∀a0 a1 a2 a0' a1' a2'.
     (MSG a0 a1 a2 = MSG a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2'):
   thm
val inMsg_Axiom =
   |- ∀f. ∃fn. ∀a0 a1 a2. fn (MSG a0 a1 a2) = f a0 a1 a2:
   thm
val inMsg_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'inMsg' .
            (∀a0'.
               (∃a0 a1 a2.
                  a0' =
                  (λa0 a1 a2.
                     ind_type$CONSTR 0 (a0,a1,a2) (λn. ind_type$BOTTOM))
                    a0 a1 a2) ⇒
               'inMsg' a0') ⇒
            'inMsg' a0') rep:
   thm
val inMsg_case_cong =
   |- ∀M M' f.
     (M = M') ∧
     (∀a0 a1 a2. (M' = MSG a0 a1 a2) ⇒ (f a0 a1 a2 = f' a0 a1 a2)) ⇒
     (inMsg_CASE M f = inMsg_CASE M' f'):
   thm
val inMsg_case_def =
   |- ∀a0 a1 a2 f. inMsg_CASE (MSG a0 a1 a2) f = f a0 a1 a2:
   thm
val inMsg_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | (TY, TY)asymMsg | authority |
                  bool | command |
                  (TY, TY, TY, TY, TY, TY)configuration |
                  (TY, TY, TY, TY, TY, TY, TY, TY)configuration2 |
                  TY digest | (TY, TY)fun | inMsg | ind | TY inst |
                  TY itself | TY list | npriv | num | one | TY option |
                  order | output | TY pKey | TY po | principal |
                  privcmd | (TY, TY)prod | TY recspace | role | TY set |
                  staff | state | (TY, TY)sum | symKey | TY symMsg |
                  TY trType | unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  ('a, 'b) asymMsg = (α, β) cipher$asymMsg             
  authority = principal$authority                        
  bool = min$bool                                        
  command = m0Types$command                              
  ('a, 'b, 'c, 'd, 'e, 'f) configuration = (α, β, γ, δ, ε, ζ) ssm1$configuration
  ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h) configuration2 = (α, β, γ, δ, ε, ζ, η, θ) ssm2$configuration2
  'a digest = α cipher$digest                           
  ('a, 'b) fun = (α, β) min$fun                        
  inMsg = inMsg$inMsg                                    
  ind = min$ind                                          
  'a inst = α ssm1$inst                                 
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  npriv = m0Types$npriv                                  
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  order = inMsg$order                                    
  output = m0Types$output                                
  'a pKey = α cipher$pKey                               
  'a po = α aclfoundation$po                            
  principal = principal$principal                        
  privcmd = m0Types$privcmd                              
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  role = principal$role                                  
  'a set = (α, min$bool) min$fun                         (not printed)
  staff = principal$staff                                
  state = m0Types$state                                  
  ('a, 'b) sum = (α, β) sum$sum                        
  symKey = cipher$symKey                                 
  'a symMsg = α cipher$symMsg                           
  'a trType = α ssm1$trType                             
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ACTIVE ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev Alice Authority BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
  BUTFIRSTN BUTLAST BUTLASTN Bob CARD CFG CFG2 CFG2Interpret
  CFGInterpret CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Carol Commander Cong DATATYPE DELETE DFUNSET DIFF DISJOINT
  DIV DIV2 DIVMOD DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2
  EVERYi EXISTS EXP EXT_POINT Ea Efn Es F FACT FAIL FCOMM FF FILTER FIND
  FINITE FIRSTN FLAT FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET
  Form_CASE Form_size GENLIST GENLIST_AUX GSPEC GUESS_EXISTS
  GUESS_EXISTS_GAP GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP
  GUESS_FORALL_POINT HD HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF
  INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT
  INTER INVOL ISL ISR IS_EL IS_NONE IS_NUM_REP IS_PREFIX
  IS_REDUNDANT_ROWS_INFO IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST
  IS_SUFFIX IS_SUM_REP ITSET Id IfCases IntLevel_CASE IntLevel_size Jext
  K KS KeyA KeyS Kripke_CASE Kripke_size LAST LASTN LEAST LEFT_ID LEN
  LENGTH LET LEX LINV LINV_OPT LIST_APPLY LIST_BIND LIST_ELEM_COUNT
  LIST_IGNORE_BIND LIST_LIFT2 LIST_REL LIST_RELi LIST_TO_SET LLEX LRC
  LUPDATE Lifn LinearOrder Lsfn MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM
  MIN MIN_SET MOD MODEQ MONOID MSG Machine MsgInterpret NIL NONE NOTIN
  NP NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O O1 ODD
  OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND OPTION_CHOICE
  OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP OPTION_MAP2
  OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Operator Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PR PRE
  PREFIX PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET
  PSUBSET PreOrder Princ_CASE Princ_size RC RCOMPL RDOM RDOM_DELETE
  REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV Role S SC SCANL SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STBY
  STRONGEST_REDUNDANT_ROWS_INFO STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD
  SUBSET SUC SUC_REP SUFFIX SUM SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ
  SWAP SecLevel_CASE SecLevel_size Staff StrongLinearOrder StrongOrder
  Subset_PO T TAKE TC THE TL TL_T TR TR2 TT TYPE_DEFINITION UNCURRY
  UNION UNIV UNIV_POINT UNZIP UNZIP_FST UNZIP_SND UPDATE W WCR WF WFP
  WFREC WHILE WeakLinearOrder WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/
  \\ _ inject_number andf antisymmetric approx asymMsg_CASE asymMsg_size
  authority_CASE authority_size bool_size ca case checkMsg chooser
  command_CASE command_size configuration2_CASE configuration2_size
  configuration_CASE configuration_size controls count countable deciphP
  deciphS delN dest_rec diag diamond digest_CASE digest_size discard
  domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on equivalence
  exec findi findq fupdLast hash iBIT_cases iLab il imapKS impf
  inMsg_CASE inMsg_size inst_CASE inst_size internal_mult intpKS inv
  inv_image invtri invtri0 irreflexive isPREFIX itself_case jKS launch
  lift2 listRel list_CASE list_size literal_case lt lte measure meet
  mk_rec mkinMsg napp nat_elim__magic ncons nf nfoldl nfst nlen nlistrec
  nmap nnil notf npair npriv2num npriv_CASE npriv_size nsnd nub
  num2npriv num2output num2privcmd num2role num2staff num2state num_CASE
  num_to_pair o off on one one_CASE one_size one_weakorder option_ABS
  option_CASE option_REP option_size orderInterpret order_CASE
  order_size orf output2num output_CASE output_size pKey_CASE pKey_size
  pair_CASE pair_size pair_to_num pairwise partition principal_CASE
  principal_size privK privcmd2num privcmd_CASE privcmd_size prod_PO
  prop pubK quoting rcdiamond reflexive repPO reps reset role2num
  role_CASE role_size sLab sat satList says schroeder_close set sign
  signVerify sl smapKS some speaks_for splitAtPki staff2num staff_CASE
  staff_size state2num state_CASE state_size status stmarker sum_CASE
  sum_size sym symKey_CASE symKey_size symMsg_CASE symMsg_size symmetric
  the_fun the_value total trType_CASE trType_size transitive trap tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NONE               ->  ssm1$NONE option$NONE
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  Order              ->  inMsg$Order relation$Order
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME               ->  ssm1$SOME option$SOME
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    inMsg_CASE order_CASE configuration2_CASE configuration_CASE
    trType_CASE inst_CASE Kripke_CASE Form_CASE SecLevel_CASE
    IntLevel_CASE Princ_CASE output_CASE state_CASE command_CASE
    npriv_CASE privcmd_CASE principal_CASE staff_CASE role_CASE
    authority_CASE digest_CASE asymMsg_CASE pKey_CASE symMsg_CASE
    symKey_CASE list_CASE option_CASE sum_CASE num_CASE pair_CASE
    itself_case literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val inMsg_induction =
   |- ∀P. (∀s $o a. P (MSG s $o a)) ⇒ ∀i. P i:
   thm
val inMsg_nchotomy =
   |- ∀ii. ∃s $o a. ii = MSG s $o a:
   thm
val inMsg_one_one =
   |- ∀a0 a1 a2 a0' a1' a2'.
     (MSG a0 a1 a2 = MSG a0' a1' a2') ⇔
     (a0 = a0') ∧ (a1 = a1') ∧ (a2 = a2'):
   thm
val inMsg_size_def =
   |- ∀a0 a1 a2.
     inMsg_size (MSG a0 a1 a2) =
     1 +
     (staff_size a0 +
      (order_size a1 +
       asymMsg_size (digest_size order_size) staff_size a2)):
   thm
val mkRCert_def =
   |- ∀formula. mkRCert formula = RCert formula:
   thm
val mkSCert_def =
   |- ∀auth formula.
     mkSCert auth formula =
     SCert (KeyA (pubK auth)) formula
       (sign (privK auth) (hash (SOME formula))):
   thm
val mkinMsg_def =
   |- mkinMsg
     (Name (KeyS (pubK staff)) quoting Name (Role role) says
      prop (SOME command)) =
   MSG staff (Order role command)
     (sign (privK staff) (hash (SOME (Order role command)))):
   thm
val mkinMsg_ind =
   |- ∀P.
     (∀staff role command.
        P
          (Name (KeyS (pubK staff)) quoting Name (Role role) says
           prop (SOME command))) ∧ P TT ∧ P FF ∧ (∀v1. P (prop v1)) ∧
     (∀v3. P (notf v3)) ∧ (∀v6 v7. P (v6 andf v7)) ∧
     (∀v10 v11. P (v10 orf v11)) ∧ (∀v14 v15. P (v14 impf v15)) ∧
     (∀v18 v19. P (v18 eqf v19)) ∧ (∀v129. P (v129 says TT)) ∧
     (∀v130. P (v130 says FF)) ∧
     (∀v132 v139. P (Name v132 says prop v139)) ∧
     (∀v135 v136 v140. P (v135 meet v136 says prop v140)) ∧
     (∀v171 v161 command.
        P
          (Name v171 quoting Name (Staff v161) says
           prop (SOME command))) ∧
     (∀v172 v163 command.
        P
          (Name v172 quoting Name (Authority v163) says
           prop (SOME command))) ∧
     (∀v174 v184 command.
        P
          (Name (Staff v174) quoting Name (Role v184) says
           prop (SOME command))) ∧
     (∀v176 v185 command.
        P
          (Name (Authority v176) quoting Name (Role v185) says
           prop (SOME command))) ∧
     (∀v178 v186 command.
        P
          (Name (Role v178) quoting Name (Role v186) says
           prop (SOME command))) ∧
     (∀v189 role command.
        P
          (Name (KeyS (privK v189)) quoting Name (Role role) says
           prop (SOME command))) ∧
     (∀v181 v190 command.
        P
          (Name (KeyA v181) quoting Name (Role v190) says
           prop (SOME command))) ∧
     (∀v183 v191 command.
        P
          (Name (Machine v183) quoting Name (Role v191) says
           prop (SOME command))) ∧
     (∀v192 v166 command.
        P
          (Name v192 quoting Name (KeyS v166) says
           prop (SOME command))) ∧
     (∀v193 v168 command.
        P
          (Name v193 quoting Name (KeyA v168) says
           prop (SOME command))) ∧
     (∀v194 v170 command.
        P
          (Name v194 quoting Name (Machine v170) says
           prop (SOME command))) ∧
     (∀v154 v155 v195 v196.
        P (v154 meet v155 quoting Name v195 says prop (SOME v196))) ∧
     (∀v158 v159 v197 v198.
        P
          ((v158 quoting v159) quoting Name v197 says
           prop (SOME v198))) ∧
     (∀v200 v145 v146 v199.
        P (v200 quoting v145 meet v146 says prop (SOME v199))) ∧
     (∀v202 v149 v150 v201.
        P (v202 quoting v149 quoting v150 says prop (SOME v201))) ∧
     (∀v203 v204. P (v203 quoting v204 says prop NONE)) ∧
     (∀v205 v66. P (v205 says notf v66)) ∧
     (∀v206 v69 v70. P (v206 says (v69 andf v70))) ∧
     (∀v207 v73 v74. P (v207 says (v73 orf v74))) ∧
     (∀v208 v77 v78. P (v208 says (v77 impf v78))) ∧
     (∀v209 v81 v82. P (v209 says (v81 eqf v82))) ∧
     (∀v210 v85 v86. P (v210 says v85 says v86)) ∧
     (∀v211 v89 v90. P (v211 says v89 speaks_for v90)) ∧
     (∀v212 v93 v94. P (v212 says v93 controls v94)) ∧
     (∀v213 v98 v99 v100. P (v213 says reps v98 v99 v100)) ∧
     (∀v214 v103 v104. P (v214 says v103 domi v104)) ∧
     (∀v215 v107 v108. P (v215 says v107 eqi v108)) ∧
     (∀v216 v111 v112. P (v216 says v111 doms v112)) ∧
     (∀v217 v115 v116. P (v217 says v115 eqs v116)) ∧
     (∀v218 v119 v120. P (v218 says v119 eqn v120)) ∧
     (∀v219 v123 v124. P (v219 says v123 lte v124)) ∧
     (∀v220 v127 v128. P (v220 says v127 lt v128)) ∧
     (∀v24 v25. P (v24 speaks_for v25)) ∧
     (∀v28 v29. P (v28 controls v29)) ∧
     (∀v33 v34 v35. P (reps v33 v34 v35)) ∧
     (∀v38 v39. P (v38 domi v39)) ∧ (∀v42 v43. P (v42 eqi v43)) ∧
     (∀v46 v47. P (v46 doms v47)) ∧ (∀v50 v51. P (v50 eqs v51)) ∧
     (∀v54 v55. P (v54 eqn v55)) ∧ (∀v58 v59. P (v58 lte v59)) ∧
     (∀v62 v63. P (v62 lt v63)) ⇒
     ∀v. P v:
   thm
val mkinMsg_primitive_def =
   |- mkinMsg =
   WFREC (@R. WF R)
     (λmkinMsg a.
        case a of
          TT => ARB
        | FF => ARB
        | prop v => ARB
        | notf v2 => ARB
        | v4 andf v5 => ARB
        | v8 orf v9 => ARB
        | v12 impf v13 => ARB
        | v16 eqf v17 => ARB
        | v20 says TT => ARB
        | v20 says FF => ARB
        | Name v131 says prop v64 => ARB
        | v133 meet v134 says prop v64 => ARB
        | Name v151 quoting Name (Staff v160) says
          prop (SOME command) =>
            ARB
        | Name v151 quoting Name (Authority v162) says
          prop (SOME command) =>
            ARB
        | Name (Staff v173) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (Authority v175) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (Role v177) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (KeyS (pubK staff)) quoting Name (Role role) says
          prop (SOME command) =>
            I
              (MSG staff (Order role command)
                 (sign (privK staff)
                    (hash (SOME (Order role command)))))
        | Name (KeyS (privK v188)) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (KeyA v180) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name (Machine v182) quoting Name (Role role) says
          prop (SOME command) =>
            ARB
        | Name v151 quoting Name (KeyS v165) says prop (SOME command) =>
            ARB
        | Name v151 quoting Name (KeyA v167) says prop (SOME command) =>
            ARB
        | Name v151 quoting Name (Machine v169) says
          prop (SOME command) =>
            ARB
        | v152 meet v153 quoting Name v142 says prop (SOME command) =>
            ARB
        | (v156 quoting v157) quoting Name v142 says
          prop (SOME command) =>
            ARB
        | v137 quoting v143 meet v144 says prop (SOME command) => ARB
        | v137 quoting v147 quoting v148 says prop (SOME command) => ARB
        | v137 quoting v138 says prop NONE => ARB
        | v20 says notf v65 => ARB
        | v20 says (v67 andf v68) => ARB
        | v20 says (v71 orf v72) => ARB
        | v20 says (v75 impf v76) => ARB
        | v20 says (v79 eqf v80) => ARB
        | v20 says v83 says v84 => ARB
        | v20 says v87 speaks_for v88 => ARB
        | v20 says v91 controls v92 => ARB
        | v20 says reps v95 v96 v97 => ARB
        | v20 says v101 domi v102 => ARB
        | v20 says v105 eqi v106 => ARB
        | v20 says v109 doms v110 => ARB
        | v20 says v113 eqs v114 => ARB
        | v20 says v117 eqn v118 => ARB
        | v20 says v121 lte v122 => ARB
        | v20 says v125 lt v126 => ARB
        | v22 speaks_for v23 => ARB
        | v26 controls v27 => ARB
        | reps v30 v31 v32 => ARB
        | v36 domi v37 => ARB
        | v40 eqi v41 => ARB
        | v44 doms v45 => ARB
        | v48 eqs v49 => ARB
        | v52 eqn v53 => ARB
        | v56 lte v57 => ARB
        | v60 lt v61 => ARB):
   thm
val orderInterpret_def =
   |- ∀role command.
     orderInterpret (Order role command) =
     Name (Role role) says prop (SOME command):
   thm
val order_11 =
   |- ∀a0 a1 a0' a1'.
     (Order a0 a1 = Order a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1'):
   thm
val order_Axiom =
   |- ∀f. ∃fn. ∀a0 a1. fn (Order a0 a1) = f a0 a1:
   thm
val order_TY_DEF =
   |- ∃rep.
     TYPE_DEFINITION
       (λa0'.
          ∀'order' .
            (∀a0'.
               (∃a0 a1.
                  a0' =
                  (λa0 a1.
                     ind_type$CONSTR 0 (a0,a1) (λn. ind_type$BOTTOM)) a0
                    a1) ⇒
               'order' a0') ⇒
            'order' a0') rep:
   thm
val order_case_cong =
   |- ∀M M' f.
     (M = M') ∧ (∀a0 a1. (M' = Order a0 a1) ⇒ (f a0 a1 = f' a0 a1)) ⇒
     (order_CASE M f = order_CASE M' f'):
   thm
val order_case_def =
   |- ∀a0 a1 f. order_CASE (Order a0 a1) f = f a0 a1:
   thm
val order_induction =
   |- ∀P. (∀r c. P (Order r c)) ⇒ ∀ $o. P $o:
   thm
val order_nchotomy =
   |- ∀oo. ∃r c. oo = Order r c:
   thm
val order_one_one =
   |- ∀a0 a1 a0' a1'.
     (Order a0 a1 = Order a0' a1') ⇔ (a0 = a0') ∧ (a1 = a1'):
   thm
val order_size_def =
   |- ∀a0 a1.
     order_size (Order a0 a1) = 1 + (role_size a0 + command_size a1):
   thm
type thm
> val ACL_AND_SAYS_LR_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_AND_SAYS_RL_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_ASSUM = fn: term -> thm
val ACL_ASSUM2 = fn: term -> term -> term -> thm
val ACL_CONJ = fn: thm -> thm -> thm
val ACL_CONJ_TAC = fn: 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_CONTROLS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DC_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DISJ1 = fn: term -> thm -> thm
val ACL_DISJ1_TAC = fn: 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DISJ2 = fn: term -> thm -> thm
val ACL_DISJ2_TAC = fn: 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DN = fn: thm -> thm
val ACL_DOMI_TRANS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_DOMS_TRANS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_HS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_IDEMP_SPEAKS_FOR_TAC = fn: 'a * term -> 'b list * ('c -> thm)
val ACL_IL_DOMI_TAC = fn:
   term -> term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_MONO_SPEAKS_FOR_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_MP = fn: thm -> thm -> thm
val ACL_MP_SAYS_TAC = fn: 'a * term -> 'b list * ('c -> thm)
val ACL_MP_TAC = fn: thm -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_MT = fn: thm -> thm -> thm
val ACL_QUOTING_LR_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_QUOTING_RL_TAC = fn:
   'a * term -> ('a * term) list * (thm list -> thm)
val ACL_REPS_TAC = fn:
   term -> term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_REP_SAYS_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_SAYS_TAC = fn: 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_SIMP1 = fn: thm -> thm
val ACL_SIMP2 = fn: thm -> thm
val ACL_SPEAKS_FOR_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val ACL_TAUT = fn: term -> thm
val ACL_TAUT_TAC = fn: tactic
val ACL_TRANS_SPEAKS_FOR_TAC = fn:
   term -> 'a * term -> ('a * term) list * (thm list -> thm)
val AND_SAYS_LR = fn: thm -> thm
val AND_SAYS_RL = fn: thm -> thm
val And_Says =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P meet Q says f eqf P says f andf Q says f:
   thm
val And_Says_Eq =
   |- (M,Oi,Os) sat P meet Q says f ⇔ (M,Oi,Os) sat P says f andf Q says f:
   thm
val CONTROLS = fn: thm -> thm -> thm
val Conjunction =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 ⇒ (M,Oi,Os) sat f2 ⇒ (M,Oi,Os) sat f1 andf f2:
   thm
val Controls =
   |- ∀M Oi Os P f.
     (M,Oi,Os) sat P says f ⇒
     (M,Oi,Os) sat P controls f ⇒
     (M,Oi,Os) sat f:
   thm
val Controls_Eq =
   |- ∀M Oi Os P f.
     (M,Oi,Os) sat P controls f ⇔ (M,Oi,Os) sat P says f impf f:
   thm
val DC = fn: thm -> thm -> thm
val DIFF_UNIV_SUBSET =
   |- (𝕌(:α) DIFF s ∪ t = 𝕌(:α)) ⇔ s ⊆ t:
   thm
val DOMI_TRANS = fn: thm -> thm -> thm
val DOMS_TRANS = fn: thm -> thm -> thm
val Derived_Controls =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P speaks_for Q ⇒
     (M,Oi,Os) sat Q controls f ⇒
     (M,Oi,Os) sat P controls f:
   thm
val Derived_Speaks_For =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P speaks_for Q ⇒
     (M,Oi,Os) sat P says f ⇒
     (M,Oi,Os) sat Q says f:
   thm
val Disjunction1 =
   |- ∀M Oi Os f1 f2. (M,Oi,Os) sat f1 ⇒ (M,Oi,Os) sat f1 orf f2:
   thm
val Disjunction2 =
   |- ∀M Oi Os f1 f2. (M,Oi,Os) sat f2 ⇒ (M,Oi,Os) sat f1 orf f2:
   thm
val Disjunctive_Syllogism =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 orf f2 ⇒ (M,Oi,Os) sat notf f1 ⇒ (M,Oi,Os) sat f2:
   thm
val Double_Negation =
   |- ∀M Oi Os f. (M,Oi,Os) sat notf (notf f) ⇒ (M,Oi,Os) sat f:
   thm
val EQF_ANDF1 = fn: thm -> thm -> thm
val EQF_ANDF2 = fn: thm -> thm -> thm
val EQF_CONTROLS = fn: thm -> thm -> thm
val EQF_EQF1 = fn: thm -> thm -> thm
val EQF_EQF2 = fn: thm -> thm -> thm
val EQF_IMPF1 = fn: thm -> thm -> thm
val EQF_IMPF2 = fn: thm -> thm -> thm
val EQF_NOTF = fn: thm -> thm -> thm
val EQF_ORF1 = fn: thm -> thm -> thm
val EQF_ORF2 = fn: thm -> thm -> thm
val EQF_REPS = fn: thm -> thm -> thm
val EQF_SAYS = fn: thm -> thm -> thm
val EQN_EQN = fn: thm -> thm -> thm -> thm
val EQN_LT = fn: thm -> thm -> thm -> thm
val EQN_LTE = fn: thm -> thm -> thm -> thm
val HS = fn: thm -> thm -> thm
val Hypothetical_Syllogism =
   |- ∀M Oi Os f1 f2 f3.
     (M,Oi,Os) sat f1 impf f2 ⇒
     (M,Oi,Os) sat f2 impf f3 ⇒
     (M,Oi,Os) sat f1 impf f3:
   thm
val IDEMP_SPEAKS_FOR = fn: term -> thm
val IL_DOMI = fn: thm -> thm -> thm -> thm
val INTER_EQ_UNIV =
   |- ∀s1 s2. (s1 ∩ s2 = 𝕌(:α)) ⇔ (s1 = 𝕌(:α)) ∧ (s2 = 𝕌(:α)):
   thm
val Idemp_Speaks_For =
   |- ∀M Oi Os P. (M,Oi,Os) sat P speaks_for P:
   thm
val Image_SUBSET =
   |- ∀R1 R2. R2 ⊆ᵣ R1 ⇒ ∀w. R2 w ⊆ R1 w:
   thm
val Image_UNION =
   |- ∀R1 R2 w. (R1 ∪ᵣ R2) w = R1 w ∪ R2 w:
   thm
val Image_cmp =
   |- ∀R1 R2 R3 u. (R1 ∘ᵣ R2) u ⊆ R3 ⇔ R2 u ⊆ {y | R1 y ⊆ R3}:
   thm
val MONO_SPEAKS_FOR = fn: thm -> thm -> thm
val MP_SAYS = fn: term -> term -> term -> thm
val MP_Says =
   |- ∀M Oi Os P f1 f2.
     (M,Oi,Os) sat P says (f1 impf f2) impf P says f1 impf P says f2:
   thm
val Modus_Ponens =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 ⇒ (M,Oi,Os) sat f1 impf f2 ⇒ (M,Oi,Os) sat f2:
   thm
val Modus_Tollens =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 impf f2 ⇒
     (M,Oi,Os) sat notf f2 ⇒
     (M,Oi,Os) sat notf f1:
   thm
val Mono_speaks_for =
   |- ∀M Oi Os P P' Q Q'.
     (M,Oi,Os) sat P speaks_for P' ⇒
     (M,Oi,Os) sat Q speaks_for Q' ⇒
     (M,Oi,Os) sat P quoting Q speaks_for P' quoting Q':
   thm
val QUOTING_LR = fn: thm -> thm
val QUOTING_RL = fn: thm -> thm
val Quoting =
   |- ∀M Oi Os P Q f. (M,Oi,Os) sat P quoting Q says f eqf P says Q says f:
   thm
val Quoting_Eq =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P quoting Q says f ⇔ (M,Oi,Os) sat P says Q says f:
   thm
val REPS = fn: thm -> thm -> thm -> thm
val REP_SAYS = fn: thm -> thm -> thm
val Rep_Controls_Eq =
   |- ∀M Oi Os A B f.
     (M,Oi,Os) sat reps A B f ⇔ (M,Oi,Os) sat A controls B says f:
   thm
val Rep_Says =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat reps P Q f ⇒
     (M,Oi,Os) sat P quoting Q says f ⇒
     (M,Oi,Os) sat Q says f:
   thm
val Reps =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat reps P Q f ⇒
     (M,Oi,Os) sat P quoting Q says f ⇒
     (M,Oi,Os) sat Q controls f ⇒
     (M,Oi,Os) sat f:
   thm
val Reps_Eq =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat reps P Q f ⇔
     (M,Oi,Os) sat P quoting Q says f impf Q says f:
   thm
val SAYS = fn: term -> thm -> thm
val SAYS_SIMP1 = fn: thm -> thm
val SAYS_SIMP2 = fn: thm -> thm
val SL_DOMS = fn: thm -> thm -> thm -> thm
val SPEAKS_FOR = fn: thm -> thm -> thm
val SUBSET_Image_SUBSET =
   |- ∀R1 R2 R3.
     (∀w1. R2 w1 ⊆ R1 w1) ⇒ ∀w. {w | R1 w ⊆ R3} ⊆ {w | R2 w ⊆ R3}:
   thm
val Says =
   |- ∀M Oi Os P f. (M,Oi,Os) sat f ⇒ (M,Oi,Os) sat P says f:
   thm
val Says_Simplification1 =
   |- ∀M Oi Os P f1 f2.
     (M,Oi,Os) sat P says (f1 andf f2) ⇒ (M,Oi,Os) sat P says f1:
   thm
val Says_Simplification2 =
   |- ∀M Oi Os P f1 f2.
     (M,Oi,Os) sat P says (f1 andf f2) ⇒ (M,Oi,Os) sat P says f2:
   thm
val Simplification1 =
   |- ∀M Oi Os f1 f2. (M,Oi,Os) sat f1 andf f2 ⇒ (M,Oi,Os) sat f1:
   thm
val Simplification2 =
   |- ∀M Oi Os f1 f2. (M,Oi,Os) sat f1 andf f2 ⇒ (M,Oi,Os) sat f2:
   thm
val Speaks_For =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P speaks_for Q impf P says f impf Q says f:
   thm
val TRANS_SPEAKS_FOR = fn: thm -> thm -> thm
val Trans_Speaks_For =
   |- ∀M Oi Os P Q R.
     (M,Oi,Os) sat P speaks_for Q ⇒
     (M,Oi,Os) sat Q speaks_for R ⇒
     (M,Oi,Os) sat P speaks_for R:
   thm
val UNIV_DIFF_SUBSET =
   |- ∀R1 R2. R1 ⊆ R2 ⇒ (𝕌(:α) DIFF R1 ∪ R2 = 𝕌(:α)):
   thm
val aclDrules_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool | (TY, TY)fun | ind |
                  TY itself | TY list | num | one | TY option | TY po |
                  (TY, TY)prod | TY recspace | TY set | (TY, TY)sum |
                  unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD
  DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP
  EXT_POINT Efn F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT
  FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  NIL NONE NOTIN NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O
  O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND
  OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP
  OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PRE PREFIX
  PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET
  PreOrder Princ_CASE Princ_size RC RCOMPL RDOM RDOM_DELETE
  REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV S SC SCANL SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
  UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder WeakOrder
  ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf antisymmetric
  approx bool_size case chooser controls count countable delN dest_rec
  diag diamond domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on
  equivalence findi findq fupdLast iBIT_cases iLab il imapKS impf
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS lift2 listRel list_CASE list_size literal_case lt lte
  measure meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair nsnd nub num_CASE num_to_pair o one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf pair_CASE pair_size pair_to_num pairwise partition
  prod_PO prop quoting rcdiamond reflexive repPO reps sLab sat says
  schroeder_close set sl smapKS some speaks_for splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total transitive tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val aclrules_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool | (TY, TY)fun | ind |
                  TY itself | TY list | num | one | TY option | TY po |
                  (TY, TY)prod | TY recspace | TY set | (TY, TY)sum |
                  unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD
  DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP
  EXT_POINT Efn F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT
  FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  NIL NONE NOTIN NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O
  O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND
  OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP
  OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PRE PREFIX
  PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET
  PreOrder Princ_CASE Princ_size RC RCOMPL RDOM RDOM_DELETE
  REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV S SC SCANL SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
  UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder WeakOrder
  ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf antisymmetric
  approx bool_size case chooser controls count countable delN dest_rec
  diag diamond domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on
  equivalence findi findq fupdLast iBIT_cases iLab il imapKS impf
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS lift2 listRel list_CASE list_size literal_case lt lte
  measure meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair nsnd nub num_CASE num_to_pair o one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf pair_CASE pair_size pair_to_num pairwise partition
  prod_PO prop quoting rcdiamond reflexive repPO reps sLab sat says
  schroeder_close set sl smapKS some speaks_for splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total transitive tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val and_says_lemma =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P meet Q says f impf P says f andf Q says f:
   thm
type conv = Abbrev.conv
val domi_antisymmetric =
   |- ∀M Oi Os l1 l2.
     (M,Oi,Os) sat l1 domi l2 ⇒
     (M,Oi,Os) sat l2 domi l1 ⇒
     (M,Oi,Os) sat l1 eqi l2:
   thm
val domi_reflexive =
   |- ∀M Oi Os l. (M,Oi,Os) sat l domi l:
   thm
val domi_transitive =
   |- ∀M Oi Os l1 l2 l3.
     (M,Oi,Os) sat l1 domi l2 ⇒
     (M,Oi,Os) sat l2 domi l3 ⇒
     (M,Oi,Os) sat l1 domi l3:
   thm
val doms_antisymmetric =
   |- ∀M Oi Os l1 l2.
     (M,Oi,Os) sat l1 doms l2 ⇒
     (M,Oi,Os) sat l2 doms l1 ⇒
     (M,Oi,Os) sat l1 eqs l2:
   thm
val doms_reflexive =
   |- ∀M Oi Os l. (M,Oi,Os) sat l doms l:
   thm
val doms_transitive =
   |- ∀M Oi Os l1 l2 l3.
     (M,Oi,Os) sat l1 doms l2 ⇒
     (M,Oi,Os) sat l2 doms l3 ⇒
     (M,Oi,Os) sat l1 doms l3:
   thm
val eqf_and_impf =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 eqf f2 ⇔
     (M,Oi,Os) sat (f1 impf f2) andf (f2 impf f1):
   thm
val eqf_andf1 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat f andf g ⇒
     (M,Oi,Os) sat f' andf g:
   thm
val eqf_andf2 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat g andf f ⇒
     (M,Oi,Os) sat g andf f':
   thm
val eqf_controls =
   |- ∀M Oi Os P f f'.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat P controls f ⇒
     (M,Oi,Os) sat P controls f':
   thm
val eqf_eq =
   |- (Efn Oi Os M (f1 eqf f2) = 𝕌(:β)) ⇔ (Efn Oi Os M f1 = Efn Oi Os M f2):
   thm
val eqf_eqf1 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat f eqf g ⇒
     (M,Oi,Os) sat f' eqf g:
   thm
val eqf_eqf2 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat g eqf f ⇒
     (M,Oi,Os) sat g eqf f':
   thm
val eqf_impf1 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat f impf g ⇒
     (M,Oi,Os) sat f' impf g:
   thm
val eqf_impf2 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat g impf f ⇒
     (M,Oi,Os) sat g impf f':
   thm
val eqf_notf =
   |- ∀M Oi Os f f'.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat notf f ⇒
     (M,Oi,Os) sat notf f':
   thm
val eqf_orf1 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat f orf g ⇒
     (M,Oi,Os) sat f' orf g:
   thm
val eqf_orf2 =
   |- ∀M Oi Os f f' g.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat g orf f ⇒
     (M,Oi,Os) sat g orf f':
   thm
val eqf_reps =
   |- ∀M Oi Os P Q f f'.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat reps P Q f ⇒
     (M,Oi,Os) sat reps P Q f':
   thm
val eqf_sat =
   |- ∀M Oi Os f1 f2.
     (M,Oi,Os) sat f1 eqf f2 ⇒ ((M,Oi,Os) sat f1 ⇔ (M,Oi,Os) sat f2):
   thm
val eqf_says =
   |- ∀M Oi Os P f f'.
     (M,Oi,Os) sat f eqf f' ⇒
     (M,Oi,Os) sat P says f ⇒
     (M,Oi,Os) sat P says f':
   thm
val eqi_Eq =
   |- ∀M Oi Os l1 l2.
     (M,Oi,Os) sat l1 eqi l2 ⇔ (M,Oi,Os) sat l2 domi l1 andf l1 domi l2:
   thm
val eqn_eqn =
   |- (M,Oi,Os) sat c1 eqn n1 ⇒
   (M,Oi,Os) sat c2 eqn n2 ⇒
   (M,Oi,Os) sat n1 eqn n2 ⇒
   (M,Oi,Os) sat c1 eqn c2:
   thm
val eqn_lt =
   |- (M,Oi,Os) sat c1 eqn n1 ⇒
   (M,Oi,Os) sat c2 eqn n2 ⇒
   (M,Oi,Os) sat n1 lt n2 ⇒
   (M,Oi,Os) sat c1 lt c2:
   thm
val eqn_lte =
   |- (M,Oi,Os) sat c1 eqn n1 ⇒
   (M,Oi,Os) sat c2 eqn n2 ⇒
   (M,Oi,Os) sat n1 lte n2 ⇒
   (M,Oi,Os) sat c1 lte c2:
   thm
val eqs_Eq =
   |- ∀M Oi Os l1 l2.
     (M,Oi,Os) sat l1 eqs l2 ⇔ (M,Oi,Os) sat l2 doms l1 andf l1 doms l2:
   thm
val il_domi =
   |- ∀M Oi Os P Q l1 l2.
     (M,Oi,Os) sat il P eqi l1 ⇒
     (M,Oi,Os) sat il Q eqi l2 ⇒
     (M,Oi,Os) sat l2 domi l1 ⇒
     (M,Oi,Os) sat il Q domi il P:
   thm
val reps_def_lemma =
   |- ∀M Oi Os P Q f.
     Efn Oi Os M (reps P Q f) =
     Efn Oi Os M (P quoting Q says f impf Q says f):
   thm
val satList_CONS =
   |- ∀h t M Oi Os.
     (M,Oi,Os) satList (h::t) ⇔ (M,Oi,Os) sat h ∧ (M,Oi,Os) satList t:
   thm
val satList_conj =
   |- ∀l1 l2 M Oi Os.
     (M,Oi,Os) satList l1 ∧ (M,Oi,Os) satList l2 ⇔
     (M,Oi,Os) satList (l1 ++ l2):
   thm
val satList_def =
   |- ∀M Oi Os formList.
     (M,Oi,Os) satList formList ⇔
     FOLDR (λx y. x ∧ y) T (MAP (λf. (M,Oi,Os) sat f) formList):
   thm
val satList_grammars =
   (Rules:
  (50)   TY  ::=  TY -> TY [fun] (R-associative)
  (60)   TY  ::=  TY + TY [sum] (R-associative)
  (70)   TY  ::=  TY # TY [prod] (R-associative)
         TY  ::=  (TY, TY, TY, TY)Form | (TY, TY)IntLevel |
                  (TY, TY, TY, TY, TY)Kripke | TY Princ |
                  (TY, TY)SecLevel | bool | (TY, TY)fun | ind |
                  TY itself | TY list | num | one | TY option | TY po |
                  (TY, TY)prod | TY recspace | TY set | (TY, TY)sum |
                  unit
         TY  ::=  TY[TY] (array type)
Type abbreviations:
  ('a, 'b, 'c, 'd) Form = (α, β, γ, δ) aclfoundation$Form
  ('a, 'b) IntLevel = (α, β) aclfoundation$IntLevel    
  ('a, 'b, 'c, 'd, 'e) Kripke = (α, β, γ, δ, ε) aclfoundation$Kripke
  'a Princ = α aclfoundation$Princ                      
  ('a, 'b) SecLevel = (α, β) aclfoundation$SecLevel    
  bool = min$bool                                        
  ('a, 'b) fun = (α, β) min$fun                        
  ind = min$ind                                          
  'a itself = α bool$itself                             
  'a list = α list$list                                 
  num = num$num                                          
  one = one$one                                           (not printed)
  'a option = α option$option                           
  'a po = α aclfoundation$po                            
  ('a, 'b) prod = (α, β) pair$prod                     
  'a recspace = α ind_type$recspace                     
  'a set = (α, min$bool) min$fun                         (not printed)
  ('a, 'b) sum = (α, β) sum$sum                        
  unit = one$one                                         ,
    (0)    TM  ::=  "OLEAST" <..binders..> "." TM |
                "LEAST" <..binders..> "." TM |
                "some" <..binders..> "." TM |
                "∃!" <..binders..> "." TM [?!] |
                "?!" <..binders..> "." TM |
                "∃" <..binders..> "." TM [?] |
                "?" <..binders..> "." TM |
                "∀" <..binders..> "." TM [!] |
                "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                "λ" <..binders..> "." TM | "\" <..binders..> "." TM
(1)    TM  ::=  "case" TM "of" TM "|" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM "|" TM  [case magic$default - %case%] |
                "case" TM "of" TM  [case magic$default - %case%]
(4)    TM  ::=  TM "::" TM (restricted quantification operator)
(5)    TM  ::=  TM TM  (binder argument concatenation)
(8)    TM  ::=  "let" LTM< _ letnil, _ letcons,;> "in" TM  [ _ let]
(9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
(12)   TM  ::=  TM "=>" TM  [case magic$default - %arrow%]
                (non-associative)
(50)   TM  ::=  TM "," TM   (R-associative)
(70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
(80)   TM  ::=  TM ":-" TM   (non-associative)
(100)  TM  ::=  TM "⇎" TM  [<=/=>] | TM "<=/=>" TM | TM "⇔" TM  [<=>] |
                TM "<=>" TM | TM "=" TM
                (non-associative)
(200)  TM  ::=  TM "⇒" TM  [==>] | TM "==>" TM   (R-associative)
(300)  TM  ::=  TM "∨" TM  [\/] | TM "\/" TM   (R-associative)
(310)  TM  ::=  TM ":>" TM   (L-associative)
(320)  TM  ::=  TM "=+" TM   (non-associative)
(400)  TM  ::=  TM "∧" TM  [/\] | TM "/\" TM   (R-associative)
(425)  TM  ::=  TM "equiv_on" TM | TM "∉" TM  [NOTIN] | TM "NOTIN" TM |
                TM "∈" TM  [IN] | TM "IN" TM
                (non-associative)
(450)  TM  ::=  TM "≼" TM  [<<=] | TM "<<=" TM | TM "PERMUTES" TM |
                TM "⊂" TM  [PSUBSET] | TM "PSUBSET" TM |
                TM "⊆" TM  [SUBSET] | TM "SUBSET" TM | TM "≥" TM  [>=] |
                TM ">=" TM | TM "≤" TM  [<=] | TM "<=" TM | TM ">" TM |
                TM "<" TM | TM "⊆ᵣ" TM  [RSUBSET] | TM "RSUBSET" TM |
                TM "≠" TM | TM "<>" TM
                (non-associative)
(460)  TM  ::=  TM "with" TM  [record update] |
                TM ":=" TM  [record field update] |
                TM "updated_by" TM  [functional record update]
                (R-associative)
(480)  TM  ::=  TM "++" TM   (L-associative)
(490)  TM  ::=  TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                TM "##" TM
                (R-associative)
(500)  TM  ::=  TM "DELETE" TM | TM "DIFF" TM | TM "∪" TM  [UNION] |
                TM "UNION" TM | TM "<*>" TM  [APPLICATIVE_FAPPLY] |
                TM "−" TM  [-] | TM "-" TM | TM "+" TM |
                TM "∪ᵣ" TM  [RUNION] | TM "RUNION" TM
                (L-associative)
(540)  TM  ::=  TM "satList" TM | TM "sat" TM   (R-associative)
(550)  TM  ::=  TM "eqf" TM   (R-associative)
(560)  TM  ::=  TM "impf" TM   (R-associative)
(570)  TM  ::=  TM "orf" TM   (R-associative)
(580)  TM  ::=  TM "andf" TM   (R-associative)
(590)  TM  ::=  TM "lt" TM | TM "lte" TM | TM "eqn" TM | TM "eqs" TM |
                TM "doms" TM | TM "eqi" TM | TM "domi" TM |
                TM "controls" TM | TM "says" TM
                (R-associative)
(600)  TM  ::=  TM "×" TM  [CROSS] | TM "CROSS" TM |
                TM "∩" TM  [INTER] | TM "INTER" TM | TM "DIV" TM |
                TM "*" TM | TM "\\" TM | TM "∩ᵣ" TM  [RINTER] |
                TM "RINTER" TM
                (L-associative)
(601)  TM  ::=  TM "⊗" TM  [*,] | TM "*," TM   (R-associative)
(615)  TM  ::=  TM "speaks_for" TM   (R-associative)
(620)  TM  ::=  TM "quoting" TM   (R-associative)
(630)  TM  ::=  TM "meet" TM   (R-associative)
(650)  TM  ::=  TM "MOD" TM   (L-associative)
(700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
(800)  TM  ::=  TM "∘ᵣ" TM  [O] | TM "O" TM | TM "∘" TM  [o] | TM "o" TM
                (R-associative)
(899)  TM  ::=  TM ":" TY  (type annotation)
(900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "¬" TM  [~] | "~" TM
(2000) TM  ::=  TM TM  (function application)   (L-associative)
(2100) TM  ::=  TM "³" | TM "²" | TM "ᵀ"  [inv] | TM "^="  [EQC] |
                TM "^*"  [RTC] | TM "⁺"  [TC] | TM "^+"  [TC]
(2200) TM  ::=  "𝕌" TM | "univ" TM
(2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
       TM  ::=  "[" LTM<NIL,CONS,;> "]"  [] |
                "{" LTM<EMPTY,INSERT,;> "}"  [] |
                "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                "{" TM "|" TM "}"  [gspec special] | "(" ")"  [one] |
                "<|" LTM< _ record nil, _ record cons,;> "|>"  [] |
                "(" TM ")"  [just parentheses, no term produced]
Known constants:
    _ fakeconst4.case,S10.case magic,7.default ! ## & () * ** *, + ++ ,
  - /\ 0 :- :> < <<= <= <=/=> <=> <> = =+ ==> > >= ? ?! @ ABS_DIFF
  ABS_num ABS_prod ABS_sum AC ALL_DISTINCT ALL_EL AND_EL APPEND
  APPLICATIVE_FAPPLY APPLY_REDUNDANT_ROWS_INFO ARB ASM_MARKER ASSOC
  Abbrev BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED BUTFIRSTN BUTLAST
  BUTLASTN CARD CHOICE COMM COMPL COND CONS COUNT_LIST COUNT_LIST_AUX CR
  CROSS CURRY Cong DATATYPE DELETE DFUNSET DIFF DISJOINT DIV DIV2 DIVMOD
  DROP EL ELL EMPTY EMPTY_REL EQC EVEN EVERY EVERY2 EVERYi EXISTS EXP
  EXT_POINT Efn F FACT FAIL FCOMM FF FILTER FIND FINITE FIRSTN FLAT
  FOLDL FOLDL2 FOLDR FOLDRi FRONT FST FUNPOW FUNSET Form_CASE Form_size
  GENLIST GENLIST_AUX GSPEC GUESS_EXISTS GUESS_EXISTS_GAP
  GUESS_EXISTS_POINT GUESS_FORALL GUESS_FORALL_GAP GUESS_FORALL_POINT HD
  HOARE_SPEC I IDEM IMAGE IN INDEX_FIND INDEX_OF INDUCTIVE_INVARIANT
  INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT INTER INVOL ISL ISR
  IS_EL IS_NONE IS_NUM_REP IS_PREFIX IS_REDUNDANT_ROWS_INFO
  IS_REMOVABLE_QUANT_FUN IS_SOME IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET
  Id IfCases IntLevel_CASE IntLevel_size Jext K KS Kripke_CASE
  Kripke_size LAST LASTN LEAST LEFT_ID LEN LENGTH LET LEX LINV LINV_OPT
  LIST_APPLY LIST_BIND LIST_ELEM_COUNT LIST_IGNORE_BIND LIST_LIFT2
  LIST_REL LIST_RELi LIST_TO_SET LLEX LRC LUPDATE Lifn LinearOrder Lsfn
  MAP MAP2 MAPi MAPi_ACC MAX MAX_SET MEM MIN MIN_SET MOD MODEQ MONOID
  NIL NONE NOTIN NRC NULL NUMERAL NUMFST NUMLEFT NUMRIGHT NUMSND Name O
  O1 ODD OLEAST ONE_ONE ONTO OPTION_ALL OPTION_APPLY OPTION_BIND
  OPTION_CHOICE OPTION_GUARD OPTION_IGNORE_BIND OPTION_JOIN OPTION_MAP
  OPTION_MAP2 OPTION_MCOMP OPTREL OPT_MMAP OR_EL OUTL OUTR OWHILE Order
  PAD_LEFT PAD_RIGHT PERMUTES PI PMATCH PMATCH_EQUIV_ROWS
  PMATCH_EXPAND_PRED PMATCH_FLATTEN_FUN PMATCH_INCOMPLETE
  PMATCH_IS_EXHAUSTIVE PMATCH_ROW PMATCH_ROW_COND PMATCH_ROW_COND_EX
  PMATCH_ROW_COND_NOT_EX_OR_EQ PMATCH_ROW_LIFT PMATCH_ROW_REDUNDANT
  PMATCH_ROW_magic_0 PMATCH_ROW_magic_1 PMATCH_ROW_magic_2
  PMATCH_ROW_magic_3 PMATCH_ROW_magic_4 PMATCH_magic_1 PO POW PRE PREFIX
  PREIMAGE PRIM_REC PRIM_REC_FUN PROD_ALL PROD_IMAGE PROD_SET PSUBSET
  PreOrder Princ_CASE Princ_size RC RCOMPL RDOM RDOM_DELETE
  REDUNDANT_ROWS_INFOS_CONJ REDUNDANT_ROWS_INFOS_DISJ RELPOW
  REL_RESTRICT REMPTY REPLICATE REP_num REP_prod REP_sum REST RESTRICT
  RES_ABSTRACT RES_EXISTS RES_EXISTS_UNIQUE RES_FORALL RES_SELECT REV
  REVERSE RIGHT_ID RINTER RINV RPROD RRANGE RRESTRICT RSUBSET RTC RUNION
  RUNIV S SC SCANL SCANR SEG SET_TO_LIST SIGMA SIMPLE_GUESS_EXISTS
  SIMPLE_GUESS_FORALL SIMP_REC SIMP_REC_REL SING SINGL SN SND SNOC SOME
  SOME_EL SPLITL SPLITP SPLITP_AUX SPLITR STRONGEST_REDUNDANT_ROWS_INFO
  STRONGEST_REDUNDANT_ROWS_INFO_AUX STRORD SUBSET SUC SUC_REP SUFFIX SUM
  SUM_ACC SUM_ALL SUM_IMAGE SUM_SET SURJ SWAP SecLevel_CASE
  SecLevel_size StrongLinearOrder StrongOrder Subset_PO T TAKE TC THE TL
  TL_T TT TYPE_DEFINITION UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
  UNZIP_SND UPDATE W WCR WF WFP WFREC WHILE WeakLinearOrder WeakOrder
  ZERO ZERO_REP ZIP ZRECSPACE \/ \\ _ inject_number andf antisymmetric
  approx bool_size case chooser controls count countable delN dest_rec
  diag diamond domi doms dropWhile enumerate eqf eqi eqn eqs equiv_on
  equivalence findi findq fupdLast iBIT_cases iLab il imapKS impf
  internal_mult intpKS inv inv_image invtri invtri0 irreflexive isPREFIX
  itself_case jKS lift2 listRel list_CASE list_size literal_case lt lte
  measure meet mk_rec napp nat_elim__magic ncons nf nfoldl nfst nlen
  nlistrec nmap nnil notf npair nsnd nub num_CASE num_to_pair o one
  one_CASE one_size one_weakorder option_ABS option_CASE option_REP
  option_size orf pair_CASE pair_size pair_to_num pairwise partition
  prod_PO prop quoting rcdiamond reflexive repPO reps sLab sat satList
  says schroeder_close set sl smapKS some speaks_for splitAtPki stmarker
  sum_CASE sum_size symmetric the_fun the_value total transitive tri
  trichotomous tri⁻¹ unint univ wellfounded ~ ² ³ Π ∅ ∅ᵣ ∑ ≠ 𝕌 𝕌ᵣ
Overloading:
                     -> 
    (λ(x :α). list$CONS x (list$NIL :α list))
    (λ(h :α) (l :α list). bool$~ (bool$IN h (list$LIST_TO_SET l)))
    (λ(x :α itself). 𝕌((:α) :α itself))
  &                  ->  nat_elim__magic
  ()                 ->  one
  **                 ->  EXP
  *,                 ->  npair
  ++                 ->  APPEND ++
  <<=                ->  (λ(x :α list) (y :α list). list$isPREFIX x y)
  <=/=>              ->  (λ(x :bool) (y :bool). bool$~ (min$= x y))
  <=>                ->  =
  <>                 ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  =+                 ->  UPDATE
  ALL_EL             ->  EVERY
  APPLICATIVE_FAPPLY ->  LIST_APPLY OPTION_APPLY
  BUTFIRSTN          ->  DROP
  BUTLAST            ->  FRONT
  EVERY2             ->  LIST_REL
  FIRSTN             ->  TAKE
  INFINITE           ->  (λ(s :α -> bool). bool$~ (pred_set$FINITE s))
  IS_EL              -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  IS_PREFIX          ->  (λ(x :α list) (y :α list). list$isPREFIX y x)
  Id                 ->  =
  MEM                -> 
    (λ(x :α) (l :α list). bool$IN x (list$LIST_TO_SET l))
  NOTIN              ->  (λ(x :α) (y :α -> bool). bool$~ (bool$IN x y))
  OPTION_MAP2        ->  OPTION_MAP2 OPTION_MAP2
  PERMUTES           -> 
    (λ(f :α -> α) (s :α -> bool). pred_set$BIJ f s s)
  PI                 ->  PROD_IMAGE
  RELPOW             ->  NRC
  REMPTY             ->  EMPTY_REL
  SIGMA              ->  SUM_IMAGE
  SINGL              ->  (λ(x :α). list$CONS x (list$NIL :α list))
  SOME_EL            ->  EXISTS
  \\                 ->  RDOM_DELETE
  _ inject_number    ->  nat_elim__magic
  case               -> 
    Kripke_CASE Form_CASE SecLevel_CASE IntLevel_CASE Princ_CASE
    list_CASE option_CASE sum_CASE num_CASE pair_CASE itself_case
    literal_case COND
  lift2              ->  OPTION_MAP2
  listRel            ->  LIST_REL
  nnil               ->  0
  set                ->  LIST_TO_SET
  tri⁻¹              ->  invtri
  univ               ->  (λ(x :α itself). 𝕌((:α) :α itself))
  ²                  ->  (λ(x :num). arithmetic$EXP x (2n :num))
  ³                  ->  (λ(x :num). arithmetic$EXP x (3n :num))
  Π                  ->  PROD_IMAGE
  ∅                  ->  EMPTY
  ∅ᵣ                 ->  EMPTY_REL
  ∑                  ->  SUM_IMAGE
  ≠                  ->  (λ(x :α) (y :α). bool$~ (min$= x y))
  𝕌                  ->  (λ(x :α itself). 𝕌((:α) :α itself))
  𝕌ᵣ                 ->  RUNIV
User printing functions:
  if gd then tr else fl       ->  bool.COND
  LET f x       ->  bool.LET
  𝕌(:α)       ->  pred_set.UNIV):
   type_grammar.grammar * term_grammar.grammar
val satList_nil =
   |- (M,Oi,Os) satList []:
   thm
val sat_TT =
   |- (M,Oi,Os) sat TT:
   thm
val sat_allworld =
   |- ∀M f. (M,Oi,Os) sat f ⇔ ∀w. w ∈ Efn Oi Os M f:
   thm
val sat_andf_eq_and_sat =
   |- (M,Oi,Os) sat f1 andf f2 ⇔ (M,Oi,Os) sat f1 ∧ (M,Oi,Os) sat f2:
   thm
val sat_def =
   |- ∀M Oi Os f. (M,Oi,Os) sat f ⇔ (Efn Oi Os M f = 𝕌(:'world)):
   thm
val says_and_lemma =
   |- ∀M Oi Os P Q f.
     (M,Oi,Os) sat P says f andf Q says f impf P meet Q says f:
   thm
val sl_doms =
   |- ∀M Oi Os P Q l1 l2.
     (M,Oi,Os) sat sl P eqs l1 ⇒
     (M,Oi,Os) sat sl Q eqs l2 ⇒
     (M,Oi,Os) sat l2 doms l1 ⇒
     (M,Oi,Os) sat sl Q doms sl P:
   thm
val speaks_for_SUBSET =
   |- ∀R3 R2 R1. R2 ⊆ᵣ R1 ⇒ ∀w. {w | R1 w ⊆ R3} ⊆ {w | R2 w ⊆ R3}:
   thm
type tactic = Abbrev.tactic
eqtype term
type thm
type thm_tactic = Abbrev.thm_tactic
val world_F =
   |- ∀M Oi Os w. w ∉ Efn Oi Os M FF:
   thm
val world_T =
   |- ∀M Oi Os w. w ∈ Efn Oi Os M TT:
   thm
val world_and =
   |- ∀M Oi Os f1 f2 w.
     w ∈ Efn Oi Os M (f1 andf f2) ⇔
     w ∈ Efn Oi Os M f1 ∧ w ∈ Efn Oi Os M f2:
   thm
val world_eq =
   |- ∀M Oi Os f1 f2 w.
     w ∈ Efn Oi Os M (f1 eqf f2) ⇔
     (w ∈ Efn Oi Os M f1 ⇔ w ∈ Efn Oi Os M f2):
   thm
val world_eqn =
   |- ∀M Oi Os n1 n2 w. w ∈ Efn Oi Os m (n1 eqn n2) ⇔ (n1 = n2):
   thm
val world_imp =
   |- ∀M Oi Os f1 f2 w.
     w ∈ Efn Oi Os M (f1 impf f2) ⇔
     w ∈ Efn Oi Os M f1 ⇒ w ∈ Efn Oi Os M f2:
   thm
val world_lt =
   |- ∀M Oi Os n1 n2 w. w ∈ Efn Oi Os m (n1 lt n2) ⇔ n1 < n2:
   thm
val world_lte =
   |- ∀M Oi Os n1 n2 w. w ∈ Efn Oi Os m (n1 lte n2) ⇔ n1 ≤ n2:
   thm
val world_not =
   |- ∀M Oi Os f w. w ∈ Efn Oi Os M (notf f) ⇔ w ∉ Efn Oi Os M f:
   thm
val world_or =
   |- ∀M f1 f2 w.
     w ∈ Efn Oi Os M (f1 orf f2) ⇔
     w ∈ Efn Oi Os M f1 ∨ w ∈ Efn Oi Os M f2:
   thm
val world_says =
   |- ∀M Oi Os P f w.
     w ∈ Efn Oi Os M (P says f) ⇔
     ∀v. v ∈ Jext (jKS M) P w ⇒ v ∈ Efn Oi Os M f:
   thm
> > # # # # # # # # # ** types trace now on
> # # # # # # # # # ** Unicode trace now off
> Definition has been stored under "certsr1a_def"
<<HOL message: inventing new type variable names: 'a, 'b>>
Definition has been stored under "certsr2a_def"
<<HOL message: inventing new type variable names: 'a, 'b>>
Definition has been stored under "certificatesr3a_def"
val certificatesr3a_def =
   |- !(npriv :npriv) (privcmd :privcmd) (cmd :command).
     (certificatesr3a npriv privcmd cmd :('a, 'b) certificate list) =
     ((MAP
         (mkRCert :(command inst, principal, 'a, 'b) Form ->
                   ('a, 'b) certificate)
         (((certsr1a npriv privcmd cmd :
              (command inst, principal, 'a, 'b) Form list) ++
           (certsr2root npriv privcmd :
              (command inst, principal, 'a, 'b) Form list))
            :(command inst, principal, 'a, 'b) Form list) ++
       MAP
         (mkSCert (ca (0 :num)) :
            (command inst, principal, 'a, 'b) Form ->
            ('a, 'b) certificate)
         (certsr2signed npriv privcmd :
            (command inst, principal, 'a, 'b) Form list))
        :('a, 'b) certificate list):
   thm
val certsr1a_def =
   |- !(npriv :npriv) (privcmd :privcmd) (cmd :command).
     (certsr1a npriv privcmd cmd :
        (command inst, principal, 'd, 'e) Form list) =
     (((certs npriv privcmd :
          (command inst, principal, 'd, 'e) Form list) ++
       [reps (Name (Staff Alice)) (Name (Role Commander))
          (prop (SOME cmd :command inst) :
             (command inst, principal, 'd, 'e) Form);
        reps (Name (Staff Bob)) (Name (Role Operator))
          (prop (SOME cmd :command inst) :
             (command inst, principal, 'd, 'e) Form)])
        :(command inst, principal, 'd, 'e) Form list):
   thm
val certsr2a_def =
   |- !(npriv :npriv) (privcmd :privcmd) (cmd :command).
     (certsr2a npriv privcmd cmd :
        (command inst, principal, 'a, 'b) Form list) =
     (((((certsr1a npriv privcmd cmd :
            (command inst, principal, 'a, 'b) Form list) ++
        (certsr2root npriv privcmd :
           (command inst, principal, 'a, 'b) Form list))
          :(command inst, principal, 'a, 'b) Form list) ++
       (certsr2signed npriv privcmd :
          (command inst, principal, 'a, 'b) Form list))
        :(command inst, principal, 'a, 'b) Form list):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> Meson search level: ......
Meson search level: ..
Meson search level: .....
Meson search level: .....
Meson search level: ....
Meson search level: ..........
Meson search level: ....
val SM0r2_mapSM0r1_Alice_Commander_trap_privcmd_lemma =
   |- CFGInterpret
     ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
      (Os :'e po))
     (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
        (SM0StateInterp :state ->
                         (command inst, principal, 'd, 'e) Form)
        (certsr2a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
           (command inst, principal, 'd, 'e) Form list)
        (mapSM0r1input
           (mapSM0inputOperatorBob
              (Name (Role Commander) says
               (prop (SOME (PR privcmd) :command inst) :
                  (command inst, principal, 'd, 'e) Form)))::
             (ins :(command inst, principal, 'd, 'e) Form list))
        (s :state) (outs :output list)) ==>
   (M,Oi,Os) sat
   (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val th1 =
   |- ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
    (Os :'e po)) satList
   (certsr2a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
      (command inst, principal, 'd, 'e) Form list) ==>
   (M,Oi,Os) sat
   ((Name (KeyS (pubK Alice)) speaks_for Name (Staff Alice))
      :(command inst, principal, 'd, 'e) Form):
   thm
val th2 =
   |- ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
    (Os :'e po)) sat
   ((Name (Role Commander) speaks_for Name (Role Commander))
      :(command inst, principal, 'd, 'e) Form):
   thm
val th3 =
   |- ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
    (Os :'e po)) satList
   (certsr2a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
      (command inst, principal, 'd, 'e) Form list) ==>
   (M,Oi,Os) sat
   ((Name (KeyS (pubK Alice)) quoting Name (Role Commander) speaks_for
     Name (Staff Alice) quoting Name (Role Commander))
      :(command inst, principal, 'd, 'e) Form):
   thm
val th4 =
   |- ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
    (Os :'e po)) satList
   (certsr2a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
      (command inst, principal, 'd, 'e) Form list) ==>
   (M,Oi,Os) sat
   Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
   (prop (SOME (PR privcmd) :command inst) :
      (command inst, principal, 'd, 'e) Form) ==>
   (M,Oi,Os) sat
   Name (Staff Alice) quoting Name (Role Commander) says
   (prop (SOME (PR privcmd) :command inst) :
      (command inst, principal, 'd, 'e) Form):
   thm
val th5 =
   |- ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
    (Os :'e po)) satList
   (certsr2a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
      (command inst, principal, 'd, 'e) Form list) ==>
   (M,Oi,Os) sat
   Name (Role Commander) says
   (prop (SOME (PR privcmd) :command inst) :
      (command inst, principal, 'd, 'e) Form) impf
   (prop (NONE :command inst) :
      (command inst, principal, 'd, 'e) Form) /\
   (M,Oi,Os) sat
   reps (Name (Staff Alice)) (Name (Role Commander))
     (prop (SOME (PR privcmd) :command inst) :
        (command inst, principal, 'd, 'e) Form):
   thm
val th6 =
   |- ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
    (Os :'e po)) satList
   (certsr2a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
      (command inst, principal, 'd, 'e) Form list) ==>
   (M,Oi,Os) sat
   Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
   (prop (SOME (PR privcmd) :command inst) :
      (command inst, principal, 'd, 'e) Form) ==>
   (M,Oi,Os) sat
   (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 
> 
> 
> 
> 
> val SM0r2_Commander_Alice_trap_privcmd_justified_thm =
   |- !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR (M,Oi,Os) (trap (PR (privcmd :privcmd)))
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a (npriv :npriv) privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::
               (ins :(command inst, principal, 'd, 'e) Form list))
          (s :state) (outs :output list))
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     inputOKr2
       (Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
        (prop (SOME (PR privcmd) :command inst) :
           (command inst, principal, 'd, 'e) Form)) /\
     CFGInterpret (M,Oi,Os)
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::ins) s outs) /\
     (M,Oi,Os) sat
     (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 


> > > 
> 
> 
> 

> > 
> 
> 
> 
> 
> 
> 
> 
> 
> Meson search level: .......
val SM0r2_Commander_mapSM0r1input_trap_privcmd_justifed_thm =
   |- !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR (M,Oi,Os) (trap (PR (privcmd :privcmd)))
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a (npriv :npriv) privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (mapSM0r1input
             (mapSM0inputOperatorBob
                (Name (Role Commander) says
                 (prop (SOME (PR privcmd) :command inst) :
                    (command inst, principal, 'd, 'e) Form)))::
               (ins :(command inst, principal, 'd, 'e) Form list))
          (s :state) (outs :output list))
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     inputOKr2
       (mapSM0r1input
          (mapSM0inputOperatorBob
             (Name (Role Commander) says
              (prop (SOME (PR privcmd) :command inst) :
                 (command inst, principal, 'd, 'e) Form)))) /\
     CFGInterpret (M,Oi,Os)
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (mapSM0r1input
             (mapSM0inputOperatorBob
                (Name (Role Commander) says
                 (prop (SOME (PR privcmd) :command inst) :
                    (command inst, principal, 'd, 'e) Form)))::ins) s
          outs) /\
     (M,Oi,Os) sat
     (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> val certificatesr3a_certsr2a_map_thm =
   |- !(npriv :npriv) (privcmd :privcmd).
     MAP
       (certificateInterpret :('a, 'b) certificate ->
                              (command inst, principal, 'a, 'b) Form)
       (certificatesr3a npriv privcmd (PR privcmd) :
          ('a, 'b) certificate list) =
     (certsr2a npriv privcmd (PR privcmd) :
        (command inst, principal, 'a, 'b) Form list):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> Meson search level: ....
val SM0r3_mkinMsg_SM0r2_Alice_Commander_trap_privcmd_lemma =
   |- CFG2Interpret
     ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
      (Os :'e po))
     (CFG2
        (MsgInterpret :inMsg -> (command inst, principal, 'd, 'e) Form)
        (certificateInterpret :('d, 'e) certificate ->
                               (command inst, principal, 'd, 'e) Form)
        (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
        (certificatesr3a (npriv :npriv) (privcmd :privcmd)
           (PR privcmd) :('d, 'e) certificate list)
        (SM0StateInterp :state ->
                         (command inst, principal, 'd, 'e) Form)
        (mkinMsg
           (mapSM0r1input
              (mapSM0inputOperatorBob
                 (Name (Role Commander) says
                  (prop (SOME (PR privcmd) :command inst) :
                     (command inst, principal, 'd, 'e) Form))))::
             (ins :inMsg list)) (s :state) (outs :output list)) ==>
   (M,Oi,Os) sat
   (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> val SM0r3_Commander_Alice_privcmd_trap_privcmd_justified_with_refinements_thm
   =
   |- !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR2 (M,Oi,Os) (trap (PR (privcmd :privcmd)))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a (npriv :npriv) privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))::
               (ins :inMsg list)) (s :state) (outs :output list))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form) ins
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     inputOKr2
       (MsgInterpret
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))) :
          (command inst, principal, 'd, 'e) Form) /\
     CFG2Interpret (M,Oi,Os)
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))::ins)
          s outs) /\
     (M,Oi,Os) sat
     (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val th1 =
   |- (!(M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
       (Os :'e po).
      CFG2Interpret (M,Oi,Os)
        (CFG2
           (MsgInterpret :inMsg ->
                          (command inst, principal, 'd, 'e) Form)
           (certificateInterpret :('d, 'e) certificate ->
                                  (command inst, principal, 'd, 'e)
                                  Form)
           (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
           (certificatesr3a (npriv :npriv) (privcmd :privcmd)
              (PR privcmd) :('d, 'e) certificate list)
           (SM0StateInterp :state ->
                            (command inst, principal, 'd, 'e) Form)
           (mkinMsg
              (mapSM0r1input
                 (mapSM0inputOperatorBob
                    (Name (Role Commander) says
                     (prop (SOME (PR privcmd) :command inst) :
                        (command inst, principal, 'd, 'e) Form))))::
                (ins :inMsg list)) (s :state) (outs :output list)) ==>
      (M,Oi,Os) sat
      (prop (NONE :command inst) :
         (command inst, principal, 'd, 'e) Form)) ==>
   !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR2 (M,Oi,Os) (trap (PR privcmd))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))::ins)
          s outs)
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form) ins
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     inputOKr2
       (MsgInterpret
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))) :
          (command inst, principal, 'd, 'e) Form) /\
     CFG2Interpret (M,Oi,Os)
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))::ins)
          s outs) /\
     (M,Oi,Os) sat
     (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 


> > > 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> # # # # # # # # val SM0r3_Commander_Alice_privcmd_trap_privcmd_justified_thm =
   |- !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR2 (M,Oi,Os) (trap (PR (privcmd :privcmd)))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a (npriv :npriv) privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (MSG Alice (Order Commander (PR privcmd) :order)
             (sign (privK Alice)
                (hash
                   (SOME (Order Commander (PR privcmd) :order) :
                      order option)))::(ins :inMsg list)) (s :state)
          (outs :output list))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form) ins
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     inputOKr2
       (MsgInterpret
          (MSG Alice (Order Commander (PR privcmd) :order)
             (sign (privK Alice)
                (hash
                   (SOME (Order Commander (PR privcmd) :order) :
                      order option)))) :
          (command inst, principal, 'd, 'e) Form) /\
     CFG2Interpret (M,Oi,Os)
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (MSG Alice (Order Commander (PR privcmd) :order)
             (sign (privK Alice)
                (hash
                   (SOME (Order Commander (PR privcmd) :order) :
                      order option)))::ins) s outs) /\
     (M,Oi,Os) sat
     (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
> 
*** Emacs/HOL command completed ***

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 



> > > > 
> 
> 
> 
> 
> 
> val SM0r3_Alice_TR2_iff_TR_trap_privcmd =
   |- !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR2 (M,Oi,Os) (trap (PR (privcmd :privcmd)))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a (npriv :npriv) privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))::
               (ins2 :inMsg list)) (s :state) (outs :output list))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form) ins2
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     TR (M,Oi,Os) (trap (PR privcmd))
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::
               (ins :(command inst, principal, 'd, 'e) Form list)) s
          outs)
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd))) (Out s (trap (PR privcmd))::outs)):
   thm
val th1 =
   |- ((MsgInterpret
       (mkinMsg
          (mapSM0r1input
             (mapSM0inputOperatorBob
                (Name (Role Commander) says
                 (prop (SOME (PR (privcmd :privcmd)) :command inst) :
                    (command inst, principal, 'd, 'e) Form))))) :
       (command inst, principal, 'd, 'e) Form) =
    Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
    (prop (SOME (PR privcmd) :command inst) :
       (command inst, principal, 'd, 'e) Form)) ==>
   (MAP
      (certificateInterpret :('d, 'e) certificate ->
                             (command inst, principal, 'd, 'e) Form)
      (certificatesr3a (npriv :npriv) privcmd (PR privcmd) :
         ('d, 'e) certificate list) =
    (certsr2a npriv privcmd (PR privcmd) :
       (command inst, principal, 'd, 'e) Form list)) ==>
   (!(M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
       (Os :'e po).
      CFGInterpret (M,Oi,Os)
        (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
           (SM0StateInterp :state ->
                            (command inst, principal, 'd, 'e) Form)
           (certsr2a npriv privcmd (PR privcmd) :
              (command inst, principal, 'd, 'e) Form list)
           ((MsgInterpret
               (mkinMsg
                  (mapSM0r1input
                     (mapSM0inputOperatorBob
                        (Name (Role Commander) says
                         (prop (SOME (PR privcmd) :command inst) :
                            (command inst, principal, 'd, 'e)
                            Form))))) :
               (command inst, principal, 'd, 'e) Form)::
                (ins :(command inst, principal, 'd, 'e) Form list))
           (s :state) (outs :output list)) ==>
      (M,Oi,Os) sat
      (prop (NONE :command inst) :
         (command inst, principal, 'd, 'e) Form)) ==>
   (!(M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
       (Os :'e po).
      CFG2Interpret (M,Oi,Os)
        (CFG2
           (MsgInterpret :inMsg ->
                          (command inst, principal, 'd, 'e) Form)
           (certificateInterpret :('d, 'e) certificate ->
                                  (command inst, principal, 'd, 'e)
                                  Form)
           (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
           (certificatesr3a npriv privcmd (PR privcmd) :
              ('d, 'e) certificate list)
           (SM0StateInterp :state ->
                            (command inst, principal, 'd, 'e) Form)
           (mkinMsg
              (mapSM0r1input
                 (mapSM0inputOperatorBob
                    (Name (Role Commander) says
                     (prop (SOME (PR privcmd) :command inst) :
                        (command inst, principal, 'd, 'e) Form))))::
                (ins2 :inMsg list)) s outs) ==>
      (M,Oi,Os) sat
      (prop (NONE :command inst) :
         (command inst, principal, 'd, 'e) Form)) ==>
   !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR2 (M,Oi,Os) (trap (PR privcmd))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))::ins2)
          s outs)
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form) ins2
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     TR (M,Oi,Os) (trap (PR privcmd))
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          ((MsgInterpret
              (mkinMsg
                 (mapSM0r1input
                    (mapSM0inputOperatorBob
                       (Name (Role Commander) says
                        (prop (SOME (PR privcmd) :command inst) :
                           (command inst, principal, 'd, 'e) Form))))) :
              (command inst, principal, 'd, 'e) Form)::ins) s outs)
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd))) (Out s (trap (PR privcmd))::outs)):
   thm
val th2 =
   |- ((MsgInterpret
       (mkinMsg
          (mapSM0r1input
             (mapSM0inputOperatorBob
                (Name (Role Commander) says
                 (prop (SOME (PR (privcmd :privcmd)) :command inst) :
                    (command inst, principal, 'd, 'e) Form))))) :
       (command inst, principal, 'd, 'e) Form) =
    Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
    (prop (SOME (PR privcmd) :command inst) :
       (command inst, principal, 'd, 'e) Form)) ==>
   (MAP
      (certificateInterpret :('d, 'e) certificate ->
                             (command inst, principal, 'd, 'e) Form)
      (certificatesr3a (npriv :npriv) privcmd (PR privcmd) :
         ('d, 'e) certificate list) =
    (certsr2a npriv privcmd (PR privcmd) :
       (command inst, principal, 'd, 'e) Form list)) ==>
   (!(M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
       (Os :'e po).
      CFGInterpret (M,Oi,Os)
        (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
           (SM0StateInterp :state ->
                            (command inst, principal, 'd, 'e) Form)
           (certsr2a npriv privcmd (PR privcmd) :
              (command inst, principal, 'd, 'e) Form list)
           ((MsgInterpret
               (mkinMsg
                  (mapSM0r1input
                     (mapSM0inputOperatorBob
                        (Name (Role Commander) says
                         (prop (SOME (PR privcmd) :command inst) :
                            (command inst, principal, 'd, 'e)
                            Form))))) :
               (command inst, principal, 'd, 'e) Form)::
                (ins :(command inst, principal, 'd, 'e) Form list))
           (s :state) (outs :output list)) ==>
      (M,Oi,Os) sat
      (prop (NONE :command inst) :
         (command inst, principal, 'd, 'e) Form)) ==>
   !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR2 (M,Oi,Os) (trap (PR privcmd))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))::
               (ins2 :inMsg list)) s outs)
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form) ins2
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     TR (M,Oi,Os) (trap (PR privcmd))
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          ((MsgInterpret
              (mkinMsg
                 (mapSM0r1input
                    (mapSM0inputOperatorBob
                       (Name (Role Commander) says
                        (prop (SOME (PR privcmd) :command inst) :
                           (command inst, principal, 'd, 'e) Form))))) :
              (command inst, principal, 'd, 'e) Form)::ins) s outs)
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd))) (Out s (trap (PR privcmd))::outs)):
   thm
val th3 =
   |- mapSM0r1input
     (mapSM0inputOperatorBob
        (Name (Role Commander) says
         (prop (SOME (PR (privcmd :privcmd)) :command inst) :
            (command inst, principal, 'd, 'e) Form)))::
       (ins :(command inst, principal, 'd, 'e) Form list) =
   (MsgInterpret
      (mkinMsg
         (mapSM0r1input
            (mapSM0inputOperatorBob
               (Name (Role Commander) says
                (prop (SOME (PR privcmd) :command inst) :
                   (command inst, principal, 'd, 'e) Form))))) :
      (command inst, principal, 'd, 'e) Form)::ins:
   thm
val th4 =
   |- CFGInterpret
     ((M :(command inst, 'b, principal, 'd, 'e) Kripke),(Oi :'d po),
      (Os :'e po))
     (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
        (SM0StateInterp :state ->
                         (command inst, principal, 'd, 'e) Form)
        (certsr2a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
           (command inst, principal, 'd, 'e) Form list)
        ((MsgInterpret
            (mkinMsg
               (mapSM0r1input
                  (mapSM0inputOperatorBob
                     (Name (Role Commander) says
                      (prop (SOME (PR privcmd) :command inst) :
                         (command inst, principal, 'd, 'e) Form))))) :
            (command inst, principal, 'd, 'e) Form)::
             (ins :(command inst, principal, 'd, 'e) Form list))
        (s :state) (outs :output list)) ==>
   (M,Oi,Os) sat
   (prop (NONE :command inst) :(command inst, principal, 'd, 'e) Form):
   thm
val th5 =
   |- ((MsgInterpret
       (mkinMsg
          (mapSM0r1input
             (mapSM0inputOperatorBob
                (Name (Role Commander) says
                 (prop (SOME (PR (privcmd :privcmd)) :command inst) :
                    (command inst, principal, 'd, 'e) Form))))) :
       (command inst, principal, 'd, 'e) Form) =
    Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
    (prop (SOME (PR privcmd) :command inst) :
       (command inst, principal, 'd, 'e) Form)) ==>
   (MAP
      (certificateInterpret :('d, 'e) certificate ->
                             (command inst, principal, 'd, 'e) Form)
      (certificatesr3a (npriv :npriv) privcmd (PR privcmd) :
         ('d, 'e) certificate list) =
    (certsr2a npriv privcmd (PR privcmd) :
       (command inst, principal, 'd, 'e) Form list)) ==>
   !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR2 (M,Oi,Os) (trap (PR privcmd))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))::
               (ins2 :inMsg list)) (s :state) (outs :output list))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form) ins2
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     TR (M,Oi,Os) (trap (PR privcmd))
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          ((MsgInterpret
              (mkinMsg
                 (mapSM0r1input
                    (mapSM0inputOperatorBob
                       (Name (Role Commander) says
                        (prop (SOME (PR privcmd) :command inst) :
                           (command inst, principal, 'd, 'e) Form))))) :
              (command inst, principal, 'd, 'e) Form)::
               (ins :(command inst, principal, 'd, 'e) Form list)) s
          outs)
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd))) (Out s (trap (PR privcmd))::outs)):
   thm
val th6 =
   |- (MsgInterpret
      (mkinMsg
         (mapSM0r1input
            (mapSM0inputOperatorBob
               (Name (Role Commander) says
                (prop (SOME (PR (privcmd :privcmd)) :command inst) :
                   (command inst, principal, 'd, 'e) Form))))) :
      (command inst, principal, 'd, 'e) Form) =
   Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
   (prop (SOME (PR privcmd) :command inst) :
      (command inst, principal, 'd, 'e) Form):
   thm
val th7 =
   |- (MAP
      (certificateInterpret :('d, 'e) certificate ->
                             (command inst, principal, 'd, 'e) Form)
      (certificatesr3a (npriv :npriv) (privcmd :privcmd) (PR privcmd) :
         ('d, 'e) certificate list) =
    (certsr2a npriv privcmd (PR privcmd) :
       (command inst, principal, 'd, 'e) Form list)) ==>
   !(NS :state -> command trType -> state)
      (Out :state -> command trType -> output)
      (M :(command inst, 'b, principal, 'd, 'e) Kripke) (Oi :'d po)
      (Os :'e po).
     TR2 (M,Oi,Os) (trap (PR privcmd))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (mkinMsg
             (mapSM0r1input
                (mapSM0inputOperatorBob
                   (Name (Role Commander) says
                    (prop (SOME (PR privcmd) :command inst) :
                       (command inst, principal, 'd, 'e) Form))))::
               (ins2 :inMsg list)) (s :state) (outs :output list))
       (CFG2
          (MsgInterpret :inMsg ->
                         (command inst, principal, 'd, 'e) Form)
          (certificateInterpret :('d, 'e) certificate ->
                                 (command inst, principal, 'd, 'e) Form)
          (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (certificatesr3a npriv privcmd (PR privcmd) :
             ('d, 'e) certificate list)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form) ins2
          (NS s (trap (PR privcmd)))
          (Out s (trap (PR privcmd))::outs)) <=>
     TR (M,Oi,Os) (trap (PR privcmd))
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list)
          (Name (KeyS (pubK Alice)) quoting Name (Role Commander) says
           (prop (SOME (PR privcmd) :command inst) :
              (command inst, principal, 'd, 'e) Form)::
               (ins :(command inst, principal, 'd, 'e) Form list)) s
          outs)
       (CFG (inputOKr2 :(command inst, principal, 'd, 'e) Form -> bool)
          (SM0StateInterp :state ->
                           (command inst, principal, 'd, 'e) Form)
          (certsr2a npriv privcmd (PR privcmd) :
             (command inst, principal, 'd, 'e) Form list) ins
          (NS s (trap (PR privcmd))) (Out s (trap (PR privcmd))::outs)):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> 
Process HOL finished
